<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title></title>
    <link rel="shortcut icon" href="/node-express-library-teoria/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/node-express-library-teoria/favicon.ico" type="image/x-icon"> 
    <link href="/node-express-library-teoria/assets/css/syntax.css" rel="stylesheet">
    <link rel="stylesheet" href="/node-express-library-teoria/assets/css/styles.css">
    <link rel='stylesheet' href='https://use.fontawesome.com/releases/v5.0.13/css/all.css' integrity='sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp' crossorigin='anonymous'>
    <link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
  </head>
  <body class='preview-zenburn'>
   <a id="top"></a>
    <a class="github-fork-ribbon" href="https://github.com/victorponz/node-express-library-teoria" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div id='write-wrapper'>
      <nav class="topnav" id="myTopnav">
  
    <a href="/node-express-library-teoria/" >Índice</a>
  
    <a href="/node-express-library-teoria/search.html" class="active">Buscar</a>
  
  <a href="javascript:void(0);" class="icon" onclick="showMenu()">
    <i class="fa fa-bars"></i>
  </a>
</nav>


      <div id='write'>
        <div class="search">
	<form action="/node-express-library-teoria/search.html" method="get">
  <label for="search-box">Búsqueda</label>
  <input type="text" id="search-box" name="query">
  <input type="submit" value="Buscar">
</form>

<ul id="search-results"></ul>

<script>
  window.store = {
    
      "esqueleto-de-la-aplicacion": {
        "title": "Tutorial Express - parte 1: Esqueleto de la aplicación",
        "content": "Este segundo artículo de nuestro Tutorial Express muestra cómo puede crear un “esqueleto” para un proyecto de sitio web que luego puede completar con rutas, plantillas/vistas, y llamadas a base de datos especifícas del sitio.\n\n\n  \n    \n      Prerequisitos:\n      \n        Configurar un entorno de desarrollo de Node. Revise el Tutorial Express.\n      \n    \n    \n      Objetivo:\n      \n        Poder empezar sus nuevos proyectos web usando el\n        Generador de Aplicaciones Express.\n      \n    \n  \n\n\nVisión General\n\nEste artículo muestra cómo puedes crear un sitio web “esqueleto” usando la herramienta Generador de Aplicaciones Express, que luego puedes completar con rutas, vistas/plantillas, y llamadas a base de datos específicas del sitio. En este caso usaremos la herramienta para crear el framework para nuestro sitio web, al que luego agregaremos todo el código que el sitio necesite. El proceso es extremadamente simple, requiriendo sólo que se invoque el generador en la línea de comandos con un nombre para el nuevo proyecto, opcionalmente especificando también el motor de plantillas y el generador de CSS a utilizar.\n\nLas siguientes secciones muestran como puedes llamar al generador de aplicaciones, y proporcionan una pequeña explicación sobre las diferentes opciones para vistas y CSS. También explicaremos como está estructurado el esqueleto del sitio web. Al final, mostraremos cómo puedes ejecutar el sitio web para verificar que funciona.\n\n\n  -info- El Generador de Aplicaciones Express no es el único generador para aplicaciones Express, y el proyecto generado no es la única forma viable para estructurar sus archivos y directorios. El sitio generado, sin embargo, tiene una estructura modular que es fácil de extender y comprender. Para informacion sobre una mínima aplicación Express, vea el Ejemplo Hello world.\n\n\nUsando el generador de aplicaciones\n\nYa debe haber instalado el generador como parte de Configurar un entorno de desarrollo de Node. Como un rápido recordatorio, la herramienta generador se instala para todos los sitios usando el manejador de paquetes npm, como se muestra:\n\n1\nnpm install express-generator -g\n\n\nEl generador tiene un número de opciones, las cuales puede observar en la línea de comandos usando el comando --help (o bien -h):\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n&gt; express --help\n\n  Usage: express [options] [dir]\n\n  Options:\n\n        --version        output the version number\n    -e, --ejs            add ejs engine support\n        --pug            add pug engine support\n        --hbs            add handlebars engine support\n    -H, --hogan          add hogan.js engine support\n    -v, --view &lt;engine&gt;  add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)\n        --no-view        use static html instead of view engine\n    -c, --css &lt;engine&gt;   add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)\n        --git            add .gitignore\n    -f, --force          force on non-empty directory\n    -h, --help           output usage information\n\n\nSimplemente puedes especificar express para crear un proyecto dentro del directorio actual usando el motor de plantillas Jade y CSS plano (si especifica un nombre de directorio entonces el proyecto será creado en un subdirectorio con ese nombre).\n\n1\nexpress\n\n\nTambién puedes seleccionar el motor de plantillas para las vistas usando --view y/o un motor generador de CSS usando --css.\n\n\n  -info- Las otras opciones para elegir motores de plantillas (e.g. --hogan, --ejs, --hbs etc.) están descontinuadas. Use --view (o bien -v)!\n\n\n¿Qué motor de vistas debo usar?\n\nEl Generador de Aplicaciones Express le permite configurar un número de populares motores de plantillas, incluyendo EJS, Hbs, Pug (Jade), Twig, y Vash, aunque si no se especifica una opcion de vista, selecciona Jade por defecto. Express puede soportar un gran número de motores de plantillas aquí una lista.\n\n\n  -info- Si quieres usar un motor de plantillas que no es soportado por el generador entonces échale un vistazo al artículo Usando motores de plantillas con Express (Express docs) y la documentación de su motor de plantillas.\n\n\nGeneralmente hablando debes seleccionar un motor de plantillas que le brinde toda la funcionalidad que necesite y le permita ser productivo rápidamente — o en otras palabras, en la misma forma en que selecciona cualquier otro componente. Alguna de las cosas a considerar cuando se comparan motores de plantillas:\n\n\n  Tiempo de productividad — Si tu equipo ya tiene experiencia con un lenguaje de plantillas entonces es probable que sean más productivos usando ese lenguaje. Si no, debería considerar la curva de aprendizaje relativa del motor de plantillas candidato.\n  Popularidad y actividad — Revise la popularidad del motor y si tiene una comunidad activa. Es importante obtener soporte para el motor cuando tenga problemas durante la vida útil del sitio web.\n  Estilo — Algunos motores de plantillas usan marcas específicas para indicar inserción de contenido dentro del HTML “ordinario”, mientras que otros construyen el HTML usando una sintaxis diferente (por ejemplo, usando indentación (sangría) y nombres de bloque).\n  Tiempo Renderizado/desempeño.\n  \n    Características — debe considerar si los motores que elija poseen las siguientes características disponibles:\n\n    \n      Herencia del diseño: Le permite definir una plantilla base y luego “heredar” sólo las partes que desea que sean diferentes para una página particular. Típicamente esto es un mejor enfoque que construir plantillas incluyendo un número de componentes requeridos, contruyéndolas desde cero cada vez.\n      Soporte para incluir: Le permite construir plantillas incluyendo otras plantillas.\n      Control conciso de la sintaxis de variables y ciclos.\n      Habilidad para filtrar valores de variables a nivel de las plantillas (e.g. convertir variables en mayúsculas, o darle formato a una fecha).\n      Habilidad para generar formatos de salida distintos al HTML (e.g. JSON o XML).\n      Soporte para operaciones asíncronas y de transmisión.\n      Pueden ser usadas tanto en el cliente como en el servidor. Si un motor de plantillas puede ser usado del lado del cliente esto da la posibilidad de servir datos y tener todo o la mayoría del renderizado del lado del cliente.\n    \n  \n\n\n\n  -info- En Internet hay muchos recursos que le ayudarán a comparar diferentes opciones.\n\n\nPara este proyecto usaremos el motor de plantillas Pug (este es el recientemente renombrado motor Jade), ya que es de los más populares lenguajes de plantillas Express/JavaScript y es soportado por el generador por defecto.\n\n¿Qué motor de hojas de estilo CSS debería usar?\n\nEl Generador de Aplicaciones Express le permite crear un proyecto que puede usar los más comunes motores de hojas de estilos CSS: LESS, SASS, Compass, Stylus.\n\n\n  -info- CSS tiene algunas limitaciones que dificultan ciertas tareas. Los motores de hojas de estilos CSS le permiten usar una sintaxis más poderosa para definir su CSS, y luego compilar la definición en texto plano para su uso en los navegadores .\n\n\nComo los motores de plantillas, debería usar el motor CSS que le permita a su equipo ser más productivo. Para este proyecto usaremos CSS ordinario (opción por defecto) ya que nuestros requerimientos no son lo suficientemente complicados para justificar el uso de un motor CSS.\n\n¿Qué base de datos debería usar?\n\nEl código generado no usa o incluye ninguna base de datos. Las aplicaciones Express pueden usar cualquier mecanismo de bases de datos soportado por Node (Express por si mismo no define ningún comportamiento o requerimiento para el manejo de bases de datos).\n\nDiscutiremos la integración con una base de datos en un posterior artículo.\n\nCreando el proyecto\n\nPara el ejemplo que vamos a crear la app Local Library, crearemos un proyecto llamado express-locallibrary-tutorial usando la librería de plantillas Pug y ningún motor CSS.\n\nPrimero navega a donde quieras crear el proyecto y luego ejecute el Generador de Aplicaciones Express en la línea de comandos como se muestra:\n\n1\nexpress express-locallibrary-tutorial --view=pug\n\n\nEl generador creará (y listará) los archivos del proyecto.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n   create : express-locallibrary-tutorial\n   create : express-locallibrary-tutorial/package.json\n   create : express-locallibrary-tutorial/app.js\n   create : express-locallibrary-tutorial/public/images\n   create : express-locallibrary-tutorial/public\n   create : express-locallibrary-tutorial/public/stylesheets\n   create : express-locallibrary-tutorial/public/stylesheets/style.css\n   create : express-locallibrary-tutorial/public/javascripts\n   create : express-locallibrary-tutorial/routes\n   create : express-locallibrary-tutorial/routes/index.js\n   create : express-locallibrary-tutorial/routes/users.js\n   create : express-locallibrary-tutorial/views\n   create : express-locallibrary-tutorial/views/index.pug\n   create : express-locallibrary-tutorial/views/layout.pug\n   create : express-locallibrary-tutorial/views/error.pug\n   create : express-locallibrary-tutorial/bin\n   create : express-locallibrary-tutorial/bin/www\n\n   install dependencies:\n     &gt; cd express-locallibrary-tutorial &amp;&amp; npm install\n\n   run the app:\n     &gt; SET DEBUG=express-locallibrary-tutorial:* &amp; npm start\n\n\nAl final de la lista el generador mostrará instrucciones sobre como instalar las dependencias necesarias (mostradas en el archivo package.json) y luego como ejecutar la aplicación (las instrucciones anteriores son para windows; en Linux/macOS serán ligeramente diferentes).\n\nEjecutando el esqueleto del sitio web\n\nEn este punto tenemos un esqueleto completo de nuestro proyecto. El sitio web no hace mucho actualmente, pero es bueno ejecutarlo para ver como funciona.\n\n\n  \n    Primero instale las dependencias (el comando install recuperará todas las dependencias listadas en sel archivo package.json del proyecto).\n\n    1\n2\n cd express-locallibrary-tutorial\n npm install\n    \n  \n  \n    Luego ejecute la aplicación.\n\n    \n      \n        En Windows, use este comando:\n\n        1\nSET DEBUG=express-locallibrary-tutorial:* &amp; npm start\n        \n      \n      \n        En macOS o Linux, use este comando:\n\n        1\nDEBUG=express-locallibrary-tutorial:* npm start\n        \n      \n    \n  \n  \n    Luego abre en el navegador http://localhost:3000/ para acceder a la aplicación.\n  \n\n\nDeberías ver una página parecida a esta:\n\n\n\nTienes una aplicación Express funcional, ejecutándose en localhost:3000.\n\n\n  -info- También podrías ejecutar la app usando el comando npm start. Especificado la variable DEBUG como se muestra para habilitar el logging/debugging por consola. Por ejemplo, cuando visites la página mostrada arriba verás la información de depuración como esta:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n$ SET DEBUG=express-locallibrary-tutorial:* &amp;#x26; npm start\n\n$ express-locallibrary-tutorial@0.0.0 start D:\\express-locallibrary-tutorial\n$ node ./bin/www\n\nexpress-locallibrary-tutorial:server Listening on port 3000 +0ms\nGET / 200 288.474 ms - 170\nGET /stylesheets/style.css 200 5.799 ms - 111\nGET /favicon.ico 404 34.134 ms - 1335\n  \n\n\nHabilita el reinicio del servidor cuando los archivos sean modificados\n\nCualquier cambio que le haga a su sitio web Express no será visible hasta que reinicie el servidor. Tener que detener y reiniciar el servidor cada vez que hacemos un cambio, se vuelve irritante, así que es beneficioso tomarse un tiempo y automatizar el reinicio del servidor cuando sea necesario.\n\nUna de las herramientas más sencillas para este propósito es nodemon. Éste usualmente se instala globalmente (ya que es una “herramienta”), pero aquí lo instalaremos y usaremos localmente como una dependencia de desarrollo, así cualquier desarrollador que esté trabajando con el proyecto lo obtendrá automáticamente cuando instale la aplicación. Usa el siguiente comando en el directorio raíz del esqueleto del proyecto:\n\n1\nnpm install --save-dev nodemon\n\n\nSi abres el archivo package.json de tu proyecto verás una nueva sección con esta dependencia:\n\n1\n2\n3\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.20\"\n  }\n\n\nDebido a que la herramienta no fue instalada globalmente no podemos ejecutarla desde la línea de comandos (a menos que la agreguemos a la ruta) pero podemos llamarla desde un script npm porque npm sabe todo sobre los paquetes instalados. Busca la sección scripts de tu package.json. Inicialmente contendrá una línea, la cual comienza con \"start\". Actualízala colocando una coma al final de la línea, y agregue la línea \"devstart\" mostrada abajo:\n\n1\n2\n3\n4\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n\n\nAhora podemos iniciar el servidor casi exactamente como antes, pero especificando el comando devstart:\n\n\n  \n    En Windows, use este comando:\n\n    1\nSET DEBUG=express-locallibrary-tutorial:* &amp; npm run devstart\n    \n  \n  \n    En macOS or Linux, use este comando:\n\n    1\nDEBUG=express-locallibrary-tutorial:* npm run devstart\n    \n  \n\n\n\n  -info Ahora si modificas cualquier archivo del proyecto el servidor se reiniciará. Aún necesitarás recargar el navegador para refrescar la página.\n\n  Ahora tendremos que llamar “npm run &lt;nombre del script&gt;” en vez de npm start, porque “start” es actualmente un comando npm que es mapeado al nombre del script. Podríamos haber reemplazado el comando en el script start pero sólo queremos usar nodemon durante el desarrollo, así que tiene sentido crear un nuevo script para este comando.\n\n\nEl proyecto generado\n\nObservemos el proyecto que hemos creado.\n\nEstructura del directorio\n\nEl proyecto generado, ahora que has instalado las dependencias, tiene la siguiente estructura de archivos (los archivos son los elementos que no están precedidos con “/”). El archivo package.json define las dependencias de la aplicación y otra información. También define un script de inicio que es el punto de entrada de la aplicación, el archivo JavaScript /bin/www. Éste establece algunos de los manejadores de error de la aplicación y luego carga el archivo app.js para que haga el resto del trabajo. Las rutas se almacenan en módulos separados en el directorio /routes. las plantillas se almacenan en el directorio /views.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n/express-locallibrary-tutorial\n    app.js\n    /bin\n        www\n    package.json\n    /node_modules\n        [about 4,500 subdirectories and files]\n    /public\n        /images\n        /javascripts\n        /stylesheets\n            style.css\n    /routes\n        index.js\n        users.js\n    /views\n        error.pug\n        index.pug\n        layout.pug\n\n\nLas siguientes secciones describen los archivos con más detalle.\n\npackage.json\n\nEl archivo package.json define las dependencias de la aplicación y otra información:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"name\": \"express-locallibrary-tutorial\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.18.2\",\n    \"cookie-parser\": \"~1.4.3\",\n    \"debug\": \"~2.6.9\",\n    \"express\": \"~4.16.2\",\n    \"morgan\": \"~1.9.0\",\n    \"pug\": \"~2.0.0-rc.4\",\n    \"serve-favicon\": \"~2.4.5\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^1.14.11\"\n  }\n}\n\n\nLas dependencias incluyen el paquete express y los paquetes para el motor de plantillas elegido (pug). Adicionalmente, tenemos los siguientes paquetes que son útiles en muchas aplicaciones web:\n\n\n  body-parser: Esto analiza la parte del cuerpo de una solicitud HTTP entrante y facilita la extracción de diferentes partes de la información contenida. Por ejemplo, puede usar esto para leer los parámetros POST.\n  cookie-parser: Se utiliza para analizar el encabezado de la cookie y rellenar req.cookies (esencialmente proporciona un método conveniente para acceder a la información de la cookie).\n  debug: Una pequeña utilidad de depuración de node modelada a partir de la técnica de depuración del núcleo de node.\n  morgan: Un middleware registrador de solicitudes HTTP para node.\n  serve-favicon: Middleware de node para servir un favicon (este es el icono utilizado para representar el sitio dentro de la pestaña del navegador, marcadores, etc.).\n\n\nLa sección de scripts define un script de “start”, que es lo que invocamos cuando llamamos a npm start para iniciar el servidor. Desde la definición del script, puede ver que esto realmente inicia el archivo JavaScript ./bin/www con node. También define un script “devstart”, que invocamos cuando llamamos a npm run devstart en su lugar. Esto inicia el mismo archivo ./bin/www, pero con nodemon en lugar de node.\n\n1\n2\n3\n4\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n\nEste archivo es el equivalente a composer.json en Symfony\nEl archivo www\n\nEl archivo /bin/www es el punto de entrada de la aplicación. Lo primero que hace es require() del punto de entrada de la aplicación “real” (app.js, en la raíz del proyecto) que configura y devuelve el objeto de la aplicación express ().\n\n1\n2\n3\n4\n5\n6\n7\n#!/usr/bin/env node\n\n/**\n * Module dependencies.\n */\n\nvar app = require('../app');\n\n\n\n  -info- require() es una función de node global que se usa para importar módulos en el archivo actual. Aquí especificamos el módulo app.js utilizando una ruta relativa y omitiendo la extensión de archivo opcional (.js).\n\n\nEl resto del código en este archivo configura un servidor HTTP de node con la aplicación configurada en un puerto específico (definido en una variable de entorno o 3000 si la variable no está definida), y comienza a escuchar e informar errores y conexiones del servidor.\n\napp.js\n\nEste archivo crea un objeto de aplicación rápida, configura la aplicación con varias configuraciones y middleware, y luego exporta la aplicación desde el módulo. El siguiente código muestra solo las partes del archivo que crean y exportan el objeto de la aplicación:\n\n1\n2\n3\n4\nvar express = require('express');\nvar app = express();\n...\nmodule.exports = app;\n\n\nDe vuelta en el archivo de punto de entrada www anterior, es este objeto module.exports que se proporciona al llamante cuando se importa este archivo.\n\nPermite trabajar a través del archivo app.js en detalle. Primero importamos algunas bibliotecas de node útiles en el archivo usando require (), incluyendo express, serve-favicon, morgan, cookie-parser y body-parser que previamente descargamos para nuestra aplicación usando npm; y path, que es una biblioteca central de nodos para analizar rutas de archivos y directorios.\n\n1\n2\n3\n4\n5\n6\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\n\n\nLuego require() carga los módulos de nuestro directorio de rutas. Estos modules/files contienen código para manejar conjuntos particulares de “routes” relacionadas (rutas URL). Cuando extendemos la aplicación esqueleto, por ejemplo, para enumerar todos los libros de la biblioteca, agregaremos un nuevo archivo para tratar las rutas relacionadas con los libros.\n\n1\n2\nvar index = require('./routes/index');\nvar users = require('./routes/users');\n\n\n\n  -warning– En este punto, acabamos de importar el módulo; aún no hemos utilizado sus rutas (esto sucede un poco más abajo en el archivo).\nA continuación, creamos el objeto app usando nuestro módulo express importado y luego lo usamos para configurar el motor de vista (plantilla). Hay dos partes para configurar el motor. Primero establecemos el valor ‘views’ para especificar la carpeta donde se almacenarán las plantillas (en este caso, la subcarpeta /views). Luego establecemos el valor de view engine para especificar la biblioteca de plantillas (en este caso, “pug”).\n\n\n1\n2\n3\n4\n5\nvar app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');\n\nEl siguiente conjunto de funciones llama a app.use() para agregar las bibliotecas middleware a la cadena de manejo de solicitudes. Además de las bibliotecas de terceros que importamos anteriormente, usamos el middleware express.static para que Express sirva todos los archivos estáticos en el directorio /public en la raíz del proyecto.\n\n1\n2\n3\n4\n5\n6\n7\n// uncomment after placing your favicon in /public\n//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\nAhora que todo el otro middleware está configurado, agregamos nuestro código de manejo de rutas (previamente importado) a la cadena de manejo de solicitudes. El código importado definirá rutas particulares para las diferentes partes del sitio:\n\n1\n2\napp.use('/', index);\napp.use('/users', users);\n\nEl último middleware del archivo agrega métodos de controlador para errores y respuestas HTTP 404.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// catch 404 and forward to error handler\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\n\n// error handler\napp.use(function(err, req, res, next) {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\n\nEl objeto de la aplicación Express (aplicación) ahora está completamente configurado. El último paso es agregarlo a las exportaciones del módulo (esto es lo que permite que sea importado por /bin/www).\n\n1\nmodule.exports = app;\n\n\nRutas\n\nEl archivo de ruta /routes/users.js se muestra a continuación (los archivos de ruta comparten una estructura similar, por lo que no necesitamos mostrar también index.js). Primero carga el módulo express y lo usa para obtener un objeto express.Router. Luego, especifica una ruta en ese objeto y, por último, exporta el enrutador desde el módulo (esto es lo que permite importar el archivo a app.js).\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvar express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n\nLa ruta define una devolución de llamada que se invocará cada vez que se detecte una solicitud HTTP GET con el patrón correcto. El patrón coincidente es la ruta especificada cuando se importa el módulo (‘/users’) más lo que esté definido en este archivo (‘/’). En otras palabras, esta ruta se utilizará cuando se reciba una URL de /users/.\n\n\n  -info- Pruébalo ejecutando el servidor con node y visitando la URL en el navegador: http://localhost:3000/users/. Deberías ver un mensaje: ‘respond with a resource’.\nUna cosa de interés anterior es que la función de devolución de llamada tiene el tercer argumento next y, por lo tanto, es una función de middleware en lugar de una simple devolución de llamada de ruta. Si bien el código actualmente no usa el argumento next, puede ser útil en el futuro si desea agregar varios controladores de ruta a la ruta de ruta '/'.\n\n\nVistas (templates)\n\nLas vistas (plantillas) se almacenan en el directorio /views (como se especifica en app.js) y reciben la extensión de archivo .pug. El método Response.render() se usa para representar una plantilla específica junto con los valores de las variables con nombre pasadas en un objeto y, a continuación, envía el resultado como respuesta. En el siguiente código de /routes/index.js, puedes ver cómo esa ruta genera una respuesta usando la plantilla “index” pasando la variable de plantilla “title”.\n\n1\n2\n3\n4\n/* GET home page. */\nrouter.get('/', function(req, res) {\n  res.render('index', { title: 'Express' });\n});\n\nLa plantilla correspondiente para la ruta anterior se proporciona a continuación (index.pug). Hablaremos más sobre la sintaxis más adelante. Todo lo que necesitas saber por ahora es que la variable title (con el valor 'Express') se inserta donde se especifica en la plantilla.\n\n1\n2\n3\n4\n5\nextends layout\n\nblock content\n  h1= title\n  p Welcome to #{title}\n\n\nReto\n\n\n  -reto-Crea una nueva ruta en routes/users.js que mostrará el texto “You are so cool” en la URL /users/cool/. Pruébalo ejecutando el servidor y visitando http://localhost:3000/users/cool/ en tu navegador\n\n\n",
        "url": "/node-express-library-teoria/esqueleto-de-la-aplicacion"
      }
      ,
    
      "sitio-web-biblioteca": {
        "title": "Tutorial Express - parte 1: Sitio web Biblioteca",
        "content": "El primer artículo de nuestra serie de tutoriales prácticos explica lo que aprenderá y proporciona una descripción general del sitio web de ejemplo de la “biblioteca local” en el que trabajaremos y evolucionaremos en artículos posteriores.\n\n\n  \n    \n      Prerequisitos:\n      \n        Leer la\n        Introducción a Express.\n        Para los siguientes artículos, también deberá haber\n          configurado un entorno de desarrollo de Node.\n      \n    \n    \n      Objetivo:\n      \n        Presentar la aplicación de ejemplo utilizada en este tutorial, y\n            permitir a los lectores comprender qué temas se tratarán.\n      \n    \n  \n\n\nVisión General\n\nBienvenido al tutorial de MDN “Biblioteca Local” Express (Node), en el cual desarrollamos un sitio web que podría usarse para administrar el catálogo de una biblioteca local.\n\nEn esta serie de artículos tutoriales, usted:\n\n\n  Usará la herramienta Express Application Generator para crear un sitio web esquemático y una aplicación.\n  Iniciará y detendrá el servidor web Node.\n  Usará una base de datos para almacenar los datos de la aplicación.\n  Creará rutas para solicitar diferente información y plantillas (“vistas”) para representar los datos como HTML para que se muestren en el navegador\n  Trabajará con formularios\n  Implementará su aplicación en producción\n\n\nYa se ha aprendido sobre algunos de estos temas y se ha referido brevemente a otros. Al final de la serie de tutoriales, debe saber lo suficiente como para desarrollar aplicaciones Express simples usted mismo.\n\nThe LocalLibrary website\n\nLocalLibrary es el nombre del website que vamos a desarrollar en esta serie de tutoriales. Tal como esperas, el objetivo del website es proveer un catalogo online para una pequeña libreria, donde los usuarios exploren los libros disponibles y administren sus cuentas.\n\nEste ejemplo ha sido cuidadosamente elegido porque puede escalarse para mostrar tantos o pocos detalles como necesitemos, de igual forma puede usarse para presentar casi todas las caracteristicas de Express. Mas importante aún, nos permite proporcionar una ruta guiada a traves de la funcionalidad que necesita cualquier sitio web:\n\n\n  En los primeros articulos definiremos una biblioteca simple, unicamente de navegacion, que los miembros de la biblioteca usaran para saber que libros estan disponibles. Esto permite explorar las operationes mas comunes de los sitios web: lectura y presentacion de contenido de una base de datos.\n  A medida que avancemos, el ejemplo de la biblioteca se extenderá naturalmente para mostrar las caracteristicas mas avanzadas del sitio web. Por ejemplo, podemos extender la biblioteca para que se creen nuevos libros, de esta manera conoceremos como usar los formularios (forms) y la autenticacion de usuarios.\n\n\nAunque este ejemplo se puede extender mucho mas, se llama LocalLibrary por una razón , esperamos mostrar informacion minima que le ayudara a comenzar a utilizar Express rapidamente. Como resultado, almacenaremos informacion acerca de libros, copias de libros, autores y otra informacion clave. Sin embargo, no almacenaremos informacion sobre otros elementos que una biblioteca pueda tener, o proveer la infraestructura necesaria para soportar multiples sitios u otras caracteristicas de grandes bibliotecas.\n\nEstoy atascado, donde puedo obtener el codigo fuente?\n\nA medida que avance, le proporcionaremos los fragmentos de codigo adecuado para que usted los copie y pegue en cada punto, ademas, habrá otro código con el proposito de que usted lo complete para afianzar su conocimiento (con alguna orientacion).\n\nSi aun asi sigues atasaco, puedes encontrar la version completamente desarrollada del sitio web en Github aqui.\n\n\n  Nota: Las versiones especificas de node, Express, y los otros modulos con los que se probó esta documentación estan enumeradas en el projecto package.json.\n\n\n",
        "url": "/node-express-library-teoria/sitio-web-biblioteca"
      }
      ,
    
      "entorno-desarrollo-node-express": {
        "title": "Crear un entorno de desarrollo",
        "content": "Ahora que sabes para que sirve Express,  vamos a mostrar como preparar y testear un entorno de desarrollo Node/Express en: Windows, Linux (Ubuntu), y macOS. Este artículo te va a dar todo lo que se necesita para poder empezar a desarrollar apps en Express, sin importar el sistema operativo que se use.\n\n\n  \n    \n      Prerequisitos:\n      \n        Saber como abrir una terminal / línea de comando. Saber como instalar\n        paquetes de software en su sistema operativo de su computadora de\n        desarrollo.\n      \n    \n    \n      Objectivo:\n      \n        Configurar un entorno de desarrollo para Express (X.XX) en su\n        computadora.\n      \n    \n  \n\n\nNotas acerca del entorno de desarrollo\n\nNode y Express hacen muy fácil configurar su computadora con el propósito de iniciar el desarrollo de aplicaciones web. Esta sección provee unas notas acerca de qué herramientas son necesarias, explica algunos de los métodos más simples para instalar Node (y Express) en Ubuntu, macOS y Windows, y muestra como puede probar su instalación.\n\nQué es el entorno de desarrollo Express?\n\nEl entorno de desarrollo Express incluye una instalación de Nodejs, el npm administrador de paquetes, y (opcionalmente) el Generador de Aplicaciones de Express en su computadora local.\n\nNode y el administrador de paquetes npm se instalan juntos desde paquetes binarios, instaladores, administradores de paquetes del sistema operativo o desde los fuentes (como se muestra en las siguientes secciones). Express es entonces instalado por npm como una dependencia individual de sus aplicaciones web Express (conjuntamente con otras librerías como motores de plantillas, controladores de bases de datos, middleware de autenticación, middleware para servir archivos estáticos, etc.)\n\nnpm puede ser usado también para (globalmente) instalar el Generador de Aplicaciones de Express, una herramienta manual para crear la estructura de las web apps de Express que siguen el patrón MVC. El generador de aplicaciones es opcional porque no necesita utilizar esta herramienta para crear apps que usan Express, o construir apps Express que tienen el mismo diseño arquitectónico o dependencias. No obstante estaremos usandolo, porque hace mucho más fácil, y promueve una estructura modular de aplicación.\n\n\n  -info-A diferencia de otros frameworks web , el entorno de desarrollo no incluye un servidor web independiente. Una aplicación web Node/Express crea y ejecuta su propio servidor web!\n\n\nHay otras herramientas periféricas que son parte de un entorno de desarrollo típico, incluyendo editores de texto o IDEs para edición de código, y herramientas de administración de control de fuentes como Git para administrar con seguridad diferentes versiones de su código. Asumimos que usted ya tiene instaladas esta clase de herramientas (en particular un editor de texto).\n\nQué sistemas operativos son soportados?\n\nNode puede ser ejecutado en Windows, macOS, varias “versiones” de Linux, Docker, etc. (hay una lista completa de paginas de Downloads de nodejs). Casi cualquier computadora personal podría tener el desempeño necesario para ejecutar Node durante el desarrollo. Express es ejecutado en un entorno Node, y por lo tanto puede ejecutarse en cualquier plataforma que ejecute Node.\n\nEn este articulo proveemos instrucciones para configurarlo para Windows, macOS, and Ubuntu Linux.\n\n¿Qué versión de Node/Express puedo usar?\n\nHay varias versiones de Node — recientes que contienen reparaciones de bugs, soporte para versiones mas recientes de ECMAScript (JavaScript) estándares, y mejoras a las APIs de Node .\n\nGeneralmente se debe usar la versión más reciente LTS (Long Term Support), una versión como esta es más estable que la versión “actual”, mientras que sigue teniendo características relativamente recientes (y continua siendo activamente actualizado). Debería utilizar la versión Actual si necesita una característica que no esta presente en la versión LTS.\n\nPara Express siempre se debe utilizar la versión más reciente.\n\n¿Qué pasa con bases de datos y otras dependencias?\n\nOtras dependencias, tales como los controladores de bases de datos, motores de plantillas, motores de autenticación, etc. son parte de la aplicación, y son importadas dentro del entorno de la aplicación utilizando el administrador de paquetes npm.\n\nInstalar Node\n\nPara poder utilizar Express primero tienes que instalar Nodejs y el Administrador de Paquetes de Node (npm) en su sistema operativo. Las siguientes secciones explican la forma más fácil de instalar la versión Soporte de Largo-Plazo (LTS) de Nodejs en Ubuntu Linux 16.04, macOS, y Windows 10.\n\n\n  -info-Las secciones de abajo muestran la forma más fácil de instalar Node y npm en nuestras plataformas de sistemas operativo a elegir. Si esta utilizando otro SO o solo quiere ver alguna de otros enfoques para las plataformas actuales entonce vea Instalando Node.js via administrador de paquetes (nodejs.org).\n\n\nmacOS y Windows\n\nInstalar Node y npm en Windows y macOS es sencillo, porque simplemente debe utilizar el instalador provisto:\n\n\n  \n    Descargue el instalador requerido:\n\n    \n      Vaya a https://nodejs.org/es/\n      Seleccione el botón para descargar la versión LTS que es “Recomendada la mayoría de los usuarios”.\n    \n  \n  \n    Instala Node al dar doble-clic en el archivo de descarga y en seguida la instalación inicia.\n  \n\n\nUbuntu 20.04\n\nLa forma más fácil de instalar la versión LTS de Node es la usar el administrador de paquetes para obtenerlo del repositorio de distribuciones binarias de Ubuntu. Esto puede ser hecho muy simple al ejecutar los siguientes dos comandos en tu terminal:\n\n1\n2\ncurl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n\n\n  -warning-No instales directamente desde los repositorios normales de Ubuntu porque pueden contener versiones muy antiguas de Node.\n\n\nProbar su instalación de Nodejs y npm\n\nLa forma más fácil de probar que Node está instalado es ejecutar el comando “version” en su prompt de terminal/command y checar que una cadena de versión es devuelta:\n\n1\n2\n&gt;node -v\nv16.17.1\n\n\nEl administrador de paquetes npm de Nodejs también debería haber sido instalado y puede ser probado de la misma forma:\n\n1\n2\n&gt;npm -v\n8.19.2\n\n\nComo una prueba un poco más emocionante creemos un muy básico “servidor node” que simplemente imprima “Hola Mundo” en el navegador cuando visite la URL correcta en él:\n\n\n  \n    Copia el siguiente texto en un archivo llamado holanode.js. Este utiliza características básicas de Node (nada desde Express) y algo de sintaxis ES6:\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n //Load HTTP module\n const http = require(\"http\");\n const hostname = '127.0.0.1';\n const port = 3000;\n    \n //Create HTTP server and listen on port 3000 for requests\n const server = http.createServer((req, res) =&gt; {\n    \n   //Set the response HTTP header with HTTP status and Content type\n   res.statusCode = 200;\n   res.setHeader('Content-Type', 'text/plain');\n   res.end('Hello World\\n');\n });\n    \n //listen for request on port 3000, and as a callback function have the port listened on logged\n server.listen(port, hostname, () =&gt; {\n   console.log(`Server running at http://${hostname}:${port}/`);\n });\n    \n\n    El código importa el módulo “http” y lo usa para crear un servidor (createServer()) que escucha las solicitudes HTTP en el puerto 3000. Luego, el script imprime un mensaje en la consola con la URL del navegador que se puede usar para probar el servidor. La función createServer() toma como argumento una función callback que se invocará cuando se reciba una solicitud HTTP — esto simplemente devuelve una respuesta con un código de estado HTTP de 200 (“OK”) y el texto sin formato “Hello World”.\n\n    \n      -info-¡No te preocupes si aún no comprendes exactamente lo que está haciendo este código! ¡Explicaremos nuestro código con mayor detalle una vez que comencemos a usar Express!\n    \n  \n  \n    Inicia el servidor navegando en el mismo directorio que su archivo hellonode.js en su símbolo del sistema, y llamando a node junto con el nombre del script, así:\n\n    1\n2\n &gt;node hellonode.js\n Server running at http://127.0.0.1:3000/\n    \n  \n  \n    Navega a la URL http://127.0.0.1:3000. Sí todo esta funciona, el navegador simplemente debe mostrar la cadena de texto “Hello World”.\n  \n\n\nUsando npm\n\nJunto al propio node, npm es la herramienta más importante para trabajar con aplicaciones de node. npm se usa para obtener los paquetes (bibliotecas de JavaScript) que una aplicación necesita para el desarrollo, las pruebas y/o la producción, y también se puede usar para ejecutar pruebas y herramientas utilizadas en el proceso de desarrollo.\n\n\n  -info-Desde la perspectiva de Node, Express es solo otro paquete que necesita instalar usando npm y luego requerir en su propio código.\n\n\nSe puede usar npm manualmente para buscar por separado cada paquete necesario. Por lo general, administramos las dependencias utilizando un archivo de definición de texto plano llamado package.json. Este archivo enumera todas las dependencias para un “paquete” de JavaScript específico, incluido el nombre del paquete, la versión, la descripción, el archivo inicial a ejecutar, las dependencias de producción, las dependencias de desarrollo, las versiones de Node con las que puede trabajar, etc. El archivo package.json debería contener todo lo que npm necesita para buscar y ejecutar su aplicación (si estuviera escribiendo una biblioteca reutilizable, podría usar esta definición para cargar su paquete en el repositorio npm y ponerlo a disposición de otros usuarios).\n\nAgregando dependencias\n\nLos siguientes pasos muestran cómo puede usar npm para descargar un paquete, guardarlo en las dependencias del proyecto y luego requerirlo en una aplicación Node.\n\n\n  -info-Aquí mostramos las instrucciones para buscar e instalar el paquete Express. Más adelante mostraremos cómo este paquete y otros ya están especificados para nosotros utilizando el Generador de aplicaciones Express. Esta sección se proporciona porque es útil para comprender cómo funciona npm y qué está creando el generador de aplicaciones.\n\n\n\n  \n    Primero crea un directorio para su nueva aplicación y acceda a él:\n\n    1\n2\n mkdir myapp\n cd myapp\n    \n  \n  \n    Usa el comando npm init para crear un archivo package.json para su aplicación. Este comando te solicita varias cosas, incluido el nombre y la versión de su aplicación y el nombre del archivo de punto de entrada inicial (de forma predeterminada, esto es index.js). Por ahora, solo acepta los valores predeterminados:\n\n    1\n npm init\n    \n\n    Si muestras el archivo package.json (cat package.json), verás los valores predeterminados que aceptó, que finalizarán con la licencia.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n {\n   \"name\": \"myapp\",\n   \"version\": \"1.0.0\",\n   \"description\": \"\",\n   \"main\": \"index.js\",\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n   },\n   \"author\": \"\",\n   \"license\": \"ISC\"\n }\n    \n  \n  \n    Ahora instala Express en el directorio myapp y guárdalo en la lista de dependencias de su archivo package.json\n\n    1\n npm install express --save\n    \n\n    La sección de dependencias de su package.json ahora aparecerá al final del archivo package.json e incluirá Express.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n {\n   \"name\": \"myapp\",\n   \"version\": \"1.0.0\",\n   \"description\": \"\",\n   \"main\": \"index.js\",\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n   },\n   \"author\": \"\",\n   \"license\": \"ISC\",\n   \"dependencies\": {\n     \"express\": \"^4.16.3\"\n   }\n }\n    \n  \n  \n    Para usar la biblioteca, llama a la función require() como se muestra a continuación en tu archivo index.js.\n Crea un archivo llamado index.js en la raíz del directorio de la aplicación “myapp” con el contenido que se muestra a continuación.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n const express = require('express')\n const app = express();\n\n app.get('/', (req, res) =&gt; {\n   res.send('Hello World!')\n });\n\n app.listen(8000, () =&gt; {\n   console.log('Example app listening on port 8000!')\n });\n    \n\n    Este código muestra una aplicación web mínima “HelloWorld” Express. Esto importa el módulo “express” y lo usa para crear un servidor (app) que escucha las solicitudes HTTP en el puerto 8000 e imprime un mensaje en la consola que indica qué URL del navegador puede usar para probar el servidor. La función app.get () solo responde a las solicitudes HTTP GET con la ruta URL especificada ('/'), en este caso llamando a una función para enviar nuestro mensaje Hello World! .\n  \n  \n    Puedes iniciar el servidor llamando a node con el script en su símbolo del sistema:\n\n    1\n2\n &gt;node index.js\n Example app listening on port 8000\n    \n  \n  \n    Navega a la URL (http://127.0.0.1:8000/). Sí todo esta funciona, el navegador simplemente debe mostrar la cadena de texto “Hello World”.\n  \n\n\nDependencias de Desarrollo\n\nSi una dependencia solo se usa durante el desarrollo, debes guardarla como una “dependencia de desarrollo” (para que los usuarios de su paquete no tengan que instalarla en producción). Por ejemplo, para usar la popular herramienta Linting JavaScript eslint llamarías a npm como se muestra a continuación:\n\n1\nnpm install eslint --save-dev\n\n\nLa siguiente entrada se agregaría al paquete.json de su aplicación:\n\n1\n2\n3\n  \"devDependencies\": {\n    \"eslint\": \"^4.12.1\"\n  }\n\n\n\n  -info-“Linters” son herramientas que realizan análisis estáticos en el software para reconocer e informar la adhesión / no adhesión a algún conjunto de mejores prácticas de codificación.\n\n\nEjecutando tareas\n\nAdemás de definir y buscar dependencias, también puedes definir scripts con nombre en sus archivos package.json y llamar a npm para ejecutarlos con el comando run-script. Este enfoque se usa comúnmente para automatizar las pruebas en ejecución y partes de la cadena de herramientas de desarrollo o construcción (por ejemplo, ejecutar herramientas para minimizar JavaScript, reducir imágenes, LINT/analizar su código, etc.).\n\n\n  -info-Los ejecutadores de tareas como Gulp y Grunt también se pueden usar para ejecutar pruebas y otras herramientas externas.\n\n\nPor ejemplo, para definir un script para ejecutar la dependencia de desarrollo de eslint que especificamos en la sección anterior, podríamos agregar el siguiente bloque de script a nuestro archivo package.json (suponiendo que el origen de nuestra aplicación esté en una carpeta /src/js):\n\n1\n2\n3\n4\n5\n\"scripts\": {\n  ...\n  \"lint\": \"eslint src/js\"\n  ...\n}\n\n\nPara explicar un poco más, eslint src/js es un comando que podríamos ingresar en nuestra línea de terminal/linea de comandos para ejecutar eslint en archivos JavaScript contenidos en el directorio src/js dentro de nuestro directorio de aplicaciones. Incluir lo anterior dentro del archivo package.json de nuestra aplicación proporciona un acceso directo para este comando: lint.\n\nEntonces podríamos ejecutar eslint usando npm llamando a:\n\n1\n2\n3\nnpm run-script lint\n# OR (using the alias)\nnpm run lint\n\n\nEs posible que este ejemplo no parezca más corto que el comando original, pero puede incluir comandos mucho más grandes dentro de sus scripts npm, incluidas cadenas de comandos múltiples. Puede identificar un solo script npm que ejecute todas sus pruebas a la vez.\n\nInstalando Express Application Generator\n\nLa herramienta Express Application Generator genera un “esqueleto” de la aplicación Express. Instala el generador usando npm como se muestra (el indicador -g instala la herramienta globalmente para que pueda llamarla desde cualquier lugar):\n\n1\nnpm install express-generator -g\n\n\nPara crear una aplicación Express llamada “helloworld” con la configuración predeterminada, navegue hasta donde desea crearla y ejecute la aplicación como se muestra:\n\n1\nexpress helloworld\n\n\n\n  -info-También puedes especificar la biblioteca de plantillas para usar y una serie de otras configuraciones. Usa el comando --help para ver todas las opciones:\n\n  1\nexpress --help\n  \n\n\nnpm creará la nueva aplicación Express en una subcarpeta de su ubicación actual, mostrando el progreso de la compilación en la consola. Al finalizar, la herramienta mostrará los comandos que necesita ingresar para instalar las dependencias de Node e iniciar la aplicación.\n\n\n  -info-La nueva aplicación tendrá un archivo package.json en su directorio raíz. Puede abrir esto para ver qué dependencias están instaladas, incluidas Express y la biblioteca de plantillas Jade (pug):\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n{\n  \"name\": \"helloworld\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.18.2\",\n    \"cookie-parser\": \"~1.4.3\",\n    \"debug\": \"~2.6.9\",\n    \"express\": \"~4.15.5\",\n    \"jade\": \"~1.11.0\",\n    \"morgan\": \"~1.9.0\",\n    \"serve-favicon\": \"~2.4.5\"\n  }\n}\n  \n\n\nInstala todas las dependencias para la aplicación helloworld usando npm como se muestra:\n\n1\n2\ncd helloworld\nnpm install\n\n\nLuego ejecuta la aplicación (los comandos son ligeramente diferentes para Windows y Linux/macOS), como se muestra a continuación:\n\n1\n2\n3\n4\n5\n6\n7\n8\n#  Ejecute helloworld en Windows con símbolo del sistema\nSET DEBUG=helloworld:* &amp; npm start\n\n#  Ejecute helloworld en Windows con PowerShell\nSET DEBUG=helloworld:* | npm start\n\n#  Ejecute helloworld en Linux/macOS\nDEBUG=helloworld:* npm start\n\n\nEl comando DEBUG crea registros útiles, lo que resulta en una salida como la que se muestra a continuación.\n\n1\n2\n3\n4\n5\n6\n&gt;SET DEBUG=helloworld:* &amp; npm start\n\n&gt; helloworld@0.0.0 start D:\\Github\\expresstests\\helloworld\n&gt; node ./bin/www\n\n  helloworld:server Listening on port 3000 +0ms\n\n\nAbre un navegador y navegue a http://127.0.0.1:3000/ para ver la página de bienvenida Express predeterminada.\n\n\n\nHablaremos más sobre la aplicación generada cuando lleguemos al artículo sobre la generación de una aplicación esqueleto.\n\nResumen\n\nAhora tiene un entorno de desarrollo de Node en funcionamiento en su computadora que puede usarse para crear aplicaciones web Express. También ha visto cómo se puede usar npm para importar Express en una aplicación, y también cómo puede crear aplicaciones usando la herramienta Express Application Generator y luego ejecutarlas.\n\nEn el siguiente artículo, comenzaremos a trabajar a través de un tutorial para crear una aplicación web completa utilizando este entorno y las herramientas asociadas.\n\nVer también\n\n\n  Downloads page (nodejs.org)\n  Installing Node.js via package manager (nodejs.org)\n  Installing Express (expressjs.com)\n  Express Application Generator (expressjs.com)\n\n\n",
        "url": "/node-express-library-teoria/entorno-desarrollo-node-express"
      }
      ,
    
      "node-introduccion": {
        "title": "Introducción",
        "content": "En este primer articulo de Express resolveremos las preguntas “¿Qué es Node?” y “¿Qué es Express?”, y te daremos una visión general de que hace especial al framework web “Express”. Delinearemos las características principales, y te mostraremos algunos de los principales bloques de construcción de una aplicación en Express (aunque en este punto no tendrás todavía un entorno de desarrollo en que probarlo).\n\n\n  \n    \n      Pre-requisitos:\n      \n        \n          Conocimientos básicos de informática. Noción general sobre\n          programación lado servidor de sitios web, y en particular los mecanismos de las interacciones\n          cliente-servidor en sitios web.\n        \n      \n    \n    \n      Objetivo:\n      \n        \n          Ganar familiaridad con lo que es Express y cómo encaja con Node, qué\n          funcionalidad proporciona y los pilares de construcción de una\n          aplicación Express.\n        \n      \n    \n  \n\n\nInstalación de node\n\nPara instalar node.js\n\n1\n2\ncurl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n\nY para instalar el gestor de paquetes nmp\n\n1\nsudo apt install npm\n\n\nAdemás vamos a instalar nodemon  para que rearranque automáticamente el servidor al realizar cualquier cambio en un archivo de la aplicación.\n\n1\nsudo npm install -g nodemon\n\n\n¿Qué son Express y Node?\n\nNode (o más correctamente: Node.js) es un entorno que trabaja en tiempo de ejecución, de código abierto, multi-plataforma, que permite a los desarrolladores crear toda clase de herramientas de lado servidor y aplicaciones en JavaScript. La ejecución en tiempo real está pensada para usarse fuera del contexto de un explorador web (es decir, ejecutarse directamente en una computadora o sistema operativo de servidor). Como tal, el entorno omite las APIs de JavaScript específicas del explorador web y añade soporte para APIs de sistema operativo más tradicionales que incluyen HTTP y bibliotecas de sistemas de ficheros.\n\nDesde una perspectiva de desarrollo de servidor web, Node tiene un gran número de ventajas:\n\n\n  ¡Gran rendimiento! Node ha sido diseñado para optimizar el rendimiento y la escalabilidad en aplicaciones web y es un muy buen complemento para muchos problemas comunes de desarrollo web (ej, aplicaciones web en tiempo real).\n  El código está escrito en “simple JavaScript”, lo que significa que se pierde menos tiempo ocupándose de las “conmutaciones de contexto” entre lenguajes cuando estás escribiendo tanto el código del explorador web como del servidor.\n  JavaScript es un lenguaje de programación relativamente nuevo y se beneficia de los avances en diseño de lenguajes cuando se compara con otros lenguajes de servidor web tradicionales (ej, Python, PHP, etc.) Muchos otros lenguajes nuevos y populares se compilan/convierten a JavaScript de manera que puedes también usar CoffeeScript, ClosureScript, Scala, LiveScript, etc.\n  El gestor de paquetes de Node (NPM del inglés: Node Packet Manager) proporciona acceso a cientos o miles de paquetes reutilizables. Tiene además la mejor en su clase resolución de dependencias y puede usarse para automatizar la mayor parte de la cadena de herramientas de compilación.\n  Es portable, con versiones que funcionan en Microsoft Windows, OS X, Linux, Solaris, FreeBSD, OpenBSD, WebOS, y NonStop OS. Además, está bien soportado por muchos de los proveedores de hospedaje web, que proporcionan infraestructura específica y documentación para hospedaje de sitios Node.\n  Tiene un ecosistema y comunidad de desarrolladores de terceros muy activa, con cantidad de gente deseosa de ayudar.\n\n\nPuedes crear de forma sencilla un servidor web básico para responder cualquier petición simplemente usando el paquete HTTP de Node, como se muestra abajo. Este, creará un servidor y escuchará cualquier clase de peticiones en la URL http://127.0.0.1:8000/; cuando se reciba una petición, se responderá enviando en texto la respuesta: “Hola Mundo!”.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// Se carga el módulo de HTTP\nvar http = require(\"http\");\n\n// Creación del servidor HTTP, y se define la escucha\n// de peticiones en el puerto 8000\nhttp.createServer(function(request, response) {\n\n   // Se define la cabecera HTTP, con el estado HTTP (OK: 200) y el tipo de contenido\n   response.writeHead(200, {'Content-Type': 'text/plain'});\n\n   // Se responde, en el cuerpo de la respuesta con el mensaje \"Hello World\"\n   response.end('Hola Mundo!\\n');\n}).listen(8000);\n\n// Se escribe la URL para el acceso al servidor\nconsole.log('Servidor en la url http://127.0.0.1:8000/');\n\n\nOtras tareas comunes de desarrollo web no están directamente soportadas por el mismo Node. Si quieres añadir el manejo específico de diferentes verbos HTTP (ej, GET, POST, DELETE, etc.), gestionar de forma separada las peticiones por medio de diferentes direcciones URL (“rutas”), servir ficheros estáticos o usar plantillas para crear la respuesta de forma dinámica, necesitarás escribir el código por tí mismo, o ¡puedes evitar reinventar la rueda usando un framework web!\n\nExpress es el framework web más popular de Node, y es la librería subyacente para un gran número de otros frameworks web de Node populares. Proporciona mecanismos para:\n\n\n  Escritura de manejadores de peticiones con diferentes verbos HTTP en diferentes caminos URL (rutas).\n  Integración con motores de renderización de “vistas” para generar respuestas mediante la introducción de datos en plantillas.\n  Establecer ajustes de aplicaciones web como qué puerto usar para conectar, y la localización de las plantillas que se utilizan para renderizar la respuesta.\n  Añadir procesamiento de peticiones “middleware” adicional en cualquier punto dentro de la tubería de manejo de la petición.\n\n\nA pesar de que Express es en sí mismo bastante minimalista, los desarrolladores han creado paquetes de middleware compatibles para abordar casi cualquier problema de desarrollo web. Hay librerías para trabajar con cookies, sesiones, inicios de sesión de usuario, parámetros URL, datos POST, cabeceras de seguridad y muchos más. Puedes encontrar una lista de paquetes middleware mantenida por el equipo de Express en Express Middleware (junto con una lista de algunos de los paquetes más populares de terceros).\n\n\n  -info-Esta flexibilidad es una espada de doble filo. Hay paquetes de middleware para abordar casi cualquier problema o requerimiento, pero deducir cuáles son los paquetes adecuados a usar algunas veces puede ser un auténtico reto. Tampoco hay una “forma correcta” de estructurar una aplicación, y muchos ejemplos que puedes encontrar en la Internet no son óptimos, o sólo muestran una pequeña parte de lo que necesitas hacer para desarrollar una aplicación web.\n\n\n¿Dónde comenzó?\n\nNode fué lanzado inicialmente, sólo para Linux, en 2009. El gestor de paquetes NPM fué lanzado en 2010, y el soporte nativo para Windows fue añadido en 2012. La versión actual LTS (Long Term Suppport) es Node v12.18.0 mientras que la última versión es Node 14.4.0. Ésto es sólo una pequeña foto de una historia muy rica; profundiza en Wikipedia si quieres saber más).\n\nExpress fue lanzado inicialmente en Noviembre de 2010 y está ahora en la versión 4.17.1 de la API. Puedes comprobar en el changelog la información sobre cambios en la versión actual, y en GitHub notas de lanzamiento históricas más detalladas.\n\n¿Qué popularidad tiene Node/Express?\n\nLa popularidad de un framework web es importante porque es un indicador de se continuará manteniendo y qué recursos tienen más probabilidad de estar disponibles en términos de documentación, librerías de extensiones y soporte técnico.\n\nNo existe una medida disponible de inmediato y definitiva de la popularidad de los frameworks de lado servidor (aunque sitios como Hot Frameworks intentan asesorar sobre popularidad usando mecanismos como contar para cada plataforma el número de preguntas sobre proyectos en GitHub y StackOverflow). Una pregunta mejor es si Node y Express son lo “suficientemente populares” para evitar los problemas de las plataformas menos populares. ¿Continúan evolucionando? ¿Puedes conseguir la ayuda que necesitas? ¿Hay alguna posibilidad de que consigas un trabajo remunerado si aprendes Express?\n\nDe acuerdo con el número de compañías de perfil alto que usan Express, el número de gente que contribuye al código base, y el número de gente que proporciona soporte tanto libre como pagado, podemos entonces decir que sí, !Express es un framework popular!\n\n¿Es Express dogmático?\n\nLos frameworks web frecuentemente se refieren a sí mismos como “dogmáticos” (“opinionated”) o “no dogmáticos” (“unopinionated”).\n\nLos frameworks dogmáticos son aquellos que opinan acerca de la “manera correcta” de gestionar cualquier tarea en particular. Ofrecen soporte para el desarrollo rápido en un dominio en particular (resolver problemas de un tipo en particular) porque la manera correcta de hacer cualquier cosa está generalmente bien comprendida y bien documentada. Sin embargo pueden ser menos flexibles para resolver problemas fuera de su dominio principal, y tienden a ofrecer menos opciones para elegir qué componentes y enfoques pueden usarse.\n\nLos framewoks no dogmáticos, en contraposición, tienen muchas menos restricciones sobre el modo mejor de unir componentes para alcanzar un objetivo, o incluso qué componentes deberían usarse. Hacen más fácil para los desarrolladores usar las herramientas más adecuadas para completar una tarea en particular, si bien al coste de que necesitas encontrar esos componentes por tí mismo.\n\nExpress es no dogmático, transigente. Puedes insertar casi cualquier middleware compatible que te guste dentro de la cadena de manejo de la petición, en casi cualquier orden que te apetezca. Puedes estructurar la app en un fichero o múltiples ficheros y usar cualquier estructura de directorios. ¡Algunas veces puedes sentir que tienes demasiadas opciones!\n\n¿Cómo es el código para Express?\n\nEn sitios web o aplicaciones web dinámicas, que accedan a bases de datos, el servidor espera a recibir peticiones HTTP del navegador (o cliente). Cuando se recibe una petición, la aplicación determina cuál es la acción adecuada correspondiente, de acuerdo a la estructura de la URL y a la información (opcional) indicada en la petición con los métodos POST o GET. Dependiendo de la acción a realizar, puede que se necesite leer o escribir en la base de datos, o realizar otras acciones necesarias para atender la petición correctamente. La aplicación ha de responder al navegador, normalmente, creando una página HTML dinámicamente para él, en la que se muestre la información pedida, usualmente dentro de un elemento especifico para este fin, en una plantilla HTML.\n\nExpress posee métodos para especificar que función ha de ser llamada dependiendo del verbo HTTP usado en la petición (GET, POST, SET, etc.) y la estructura de la URL (“ruta”). También tiene los métodos para especificar que plantilla (“view”) o gestor de visualización utilizar, donde están guardadas las plantillas de HTML que han de usarse y como generar la visualización adecuada para cada caso. El middleware de Express, puede usarse también para añadir funcionalidades para la gestión de cookies, sesiones y usuarios, mediante el uso de parámetros, en los métodos POST/GET. Puede utilizarse además cualquier sistema de trabajo con bases de datos, que sea soportado por Node (Express no especifica ningún método preferido para trabajar con bases de datos).\n\nEn las siguientes secciones, se explican algunos puntos comunes que se pueden encontrar cuando se trabaja con código de Node y Express.\n\nHola Mundo! - en Express\n\nPrimero consideremos el tradicional ejemplo de Hola Mundo! (se comentará cada parte a continuación).\n\n\n  -info- Si tiene Node y Express instalado (o piensa instalarlos posteriormente) puede guardar este código en un archivo llamado app.js y ejecutarlo posteriormente en la linea de comandos invocándolo mediante: node app.js.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nvar express = require('express');\nvar app = express();\n\napp.get('/', function(req, res) {\n  res.send('Hola Mundo!');\n});\n\napp.listen(3000, function() {\n  console.log('Aplicación ejemplo, escuchando el puerto 3000!');\n});\n\n\nLas primeras dos líneas incluyen (mediante la orden require()) el módulo de Express y crean una aplicación de Express. Este elemento se denomina comúnmente app, y posee métodos para el enrutamiento de las peticiones HTTP, configuración del ‘middleware’, y visualización de las vistas de HTML, uso del motores de ‘templates’, y gestión de las configuraciones de las aplicaciones que controlan la aplicación (por ejemplo el entorno, las definiciones para enrutado … etcetera.)\n\nLas líneas que siguen en el código (las tres líneas que comienzan con app.get) muestran una definición de ruta que se llamará cuando se reciba una petición HTTP GET con una dirección ('/') relativa al directorio raíz. La función ‘callback’ coge una petición y una respuesta como argumentos, y ejecuta un send() en la respuesta, para enviar la cadena de caracteres: “Hola Mundo!”.\n\nEl bloque final de código, define y crea el servidor, escuchando el puerto 3000 e imprime un comentario en la consola. Cuando se está ejecutando el servidor, es posible ir hasta la dirección localhost:3000 en un navegador, y ver como el servidor de este ejemplo devuelve el mensaje de respuesta.\n\nImportando y creando módulos\n\nUn módulo es una librería o archivo JavaScript que puede ser importado dentro de otro código utilizando la función require() de Node. Por sí mismo, Express es un módulo, como lo son el middleware y las librerías de bases de datos que se utilizan en las aplicaciones Express.\n\nEl código mostrado abajo, muestra como puede importarse un módulo con base a su nombre, como ejemplo se utiliza el framework Express . Primero se invoca la función require(), indicando como parámetro el nombre del módulo o librería como una cadena ('express'), posteriormente se invoca el objeto obtenido para crear una aplicación Express.\n\nPosteriormente, se puede acceder a las propiedades y funciones del objeto Aplicación.\n\n1\n2\nvar express = require('express');\nvar app = express();\n\n\nTambién podemos crear nuestros propios módulos que puedan posteriormente ser importados de la misma manera.\n\n\n  -info-Usted puede desear crear sus propios módulos, esto le permitirá organizar su código en partes más administrables; una aplicación que reside en un solo archivo es difícil de entender y manejar.El utilizar módulos independientes también le permite administrar el espacio de nombres, de esta manera unicamente las variables que exporte explícitamente son importadas cuando utilice un módulo.\n\n\nPara hacer que los objetos estén disponibles fuera de un módulo, solamente es necesario asignarlos al objeto exports. Por ejemplo, el módulo mostrado a continuación square.js es un archivo que exporta los métodos area() y perimeter() :\n\n1\n2\nexports.area = function(width) { return width * width; };\nexports.perimeter = function(width) { return 4 * width; };\n\n\nNosotros podemos importar este módulo utilizando la función require(), y entonces podremos invocar los métodos exportados de la siguiente manera:\n\n1\n2\n3\n4\n// Utilizamos la función require() El nombre del archivo se ingresa sin la extensión (opcional) .js\nvar square = require('./square');\n// invocamos el metodo area()\nconsole.log('El área de un cuadrado con lado de 4 es ' + square.area(4));\n\n\n\n  -info- Usted también puede especificar una ruta absoluta a la ubicación del módulo (o un nombre como se realizó inicialmente).\n\n\nSi usted desea exportar completamente un objeto en una asignación en lugar de construir cada propiedad por separado, debe asignarlo al módulo module.exports como se muestra a continuación (también puede hacer esto al inicio de un constructor o de otra función.)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule.exports = {\n  area: function(width) {\n    return width * width;\n  },\n\n  perimeter: function(width) {\n    return 4 * width;\n  }\n};\n\n\nPara más información acerca de módulos vea Modulos (Node API docs).\n\nUsando APIs asíncronas\n\nEl código JavaScript usa frecuentemente APIs asíncronas antes que sincrónicas para operaciones que tomen algún tiempo en completarse. En una API sincrónica cada operación debe completarse antes de que la siguiente pueda comenzar. Por ejemplo, la siguiente función de registro es síncrona, y escribirá en orden el texto en la consola (Primero, Segundo).\n\n1\n2\nconsole.log('Primero');\nconsole.log('Segundo');\n\n\nEn contraste, en una API asincrónica, la API comenzará una operación e inmediatamente retornará (antes de que la operación se complete). Una vez que la operación finalice, la API usará algún mecanismo para realizar operaciones adicionales. Por ejemplo, el código de abajo imprimirá “Segundo, Primero” porque aunque el método setTimeout() es llamado primero y retorna inmediatamente, la operación no se completa por varios segundos.\n\n1\n2\n3\n4\nsetTimeout(function() {\n   console.log('Primero');\n   }, 3000);\nconsole.log('Segundo');\n\n\nUsar APIs asíncronas sin bloques es aun mas importante en Node que en el navegador, porque Node es un entorno de ejecución controlado por eventos de un solo hilo. “Un solo hilo” quiere decir que todas las peticiones al servidor son ejecutadas en el mismo hilo ( en vez de dividirse en procesos separados). Este modelo es extremadamente eficiente en términos de velocidad y recursos del servidor, pero eso significa que si alguna de sus funciones llama a métodos sincrónicos que tomen demasiado tiempo en completarse, bloquearan no solo la solicitud actual, sino también cualquier otra petición que este siendo manejada por tu aplicación web.\n\nHay muchas maneras para una API asincrónica de notificar a su aplicación que se ha completado. La manera mas común es registrar una función callback cuando usted invoca a una API asincrónica, la misma será llamada de vuelta cuando la operación se complete. Éste es el enfoque utilizado anteriormente.\n\n\n  -info- Usar “callbacks” puede ser un poco enmarañado si usted tiene una secuencia de operaciones asíncronas dependientes que deben ser llevadas a cabo en orden, porque esto resulta en múltiples niveles de “callbacks” anidadas. Este problema es comúnmente conocido como “callback hell” (callback del infierno). Este problema puede ser reducido con buenas practicas de código (vea http://callbackhell.com/), usando un módulo como async, o incluso avanzando a características de ES6 como las promesas.\n\n\n\n  -info-Una convención común para Node y Express es usar callbacks de error primero. En esta convención el primer valor en su función callback es un error, mientras que los argumentos subsecuentes contienen datos correctos. Hay una buena explicación de porque este enfoque es útil en este blog: The Node.js Way - Understanding Error-First Callbacks (fredkschott.com).\n\n\nCreando manejadores de rutas\n\nEn nuestro ejemplo anterior de “Hola Mundo!” en Express (véase mas arriba), definimos una función (callback) manejadora de ruta para peticiones HTTP GET a la raíz del sitio ('/').\n\n1\n2\n3\napp.get('/', function(req, res) {\n  res.send('Hello World!');\n});\n\n\nLa función callback toma una petición y una respuesta como argumentos. En este caso el método simplemente llama a send() en la respuesta para retornar la cadena “Hello World!”. Hay un número de otros métodos de respuesta para finalizar el ciclo de solicitud/respuesta, por ejemplo podrá llamar a res.json() para enviar una respuesta JSON o res.sendFile() para enviar un archivo.\n\n\n  -info- Usted puede utilizar cualquier nombre que quiera para los argumentos en las funciones callback; cuando la callback es invocada el primer argumento siempre sera la petición y el segundo siempre sera la respuesta. Tiene sentido nombrarlos de manera que pueda identificar el objeto con el que esta trabajando en el cuerpo de la callback.\n\n\nEl objeto que representa una aplicación de Express, también posee métodos para definir los manejadores de rutas para el resto de los verbos HTTP: post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), proppatch(), unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), subscribe(), unsubscribe(), patch(), search(), y connect().\n\nHay un método general para definir las rutas: app.all(), el cual será llamado en respuesta a cualquier método HTTP. Se usa para cargar funciones del middleware en una dirección particular para todos los métodos de peticiones. El siguiente ejemplo (de la documentación de Express) muestra el uso de los manejadores a /secret sin tener en cuenta el verbo HTTP utilizado (siempre que esté definido por el módulo http).\n\n1\n2\n3\n4\napp.all('/secret', function(req, res, next) {\n  console.log('Accediendo a la seccion secreta ...');\n  next(); // pasa el control al siguiente manejador\n});\n\n\nLas rutas le permiten igualar patrones particulares de caracteres en la URL, y extraer algunos valores de ella y pasarlos como parámetros al manejador de rutas (como atributo del objeto petición pasado como parámetro).\n\nUsualmente es útil agrupar manejadores de rutas para una parte del sitio juntos y accederlos usando un prefijo de ruta en común. (Ej: un sitio con una Wiki podría tener todas las rutas relacionadas a dicha sección en un archivo y siendo accedidas con el prefijo de ruta /wiki/. En Express esto se logra usando el objeto express.Router. Ej: podemos crear nuestra ruta wiki en un módulo llamado wiki.js, y entonces exportar el objeto Router, como se muestra debajo:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// wiki.js - Modulo de rutas Wiki\n\nvar express = require('express');\nvar router = express.Router();\n\n// Home page route\nrouter.get('/', function(req, res) {\n  res.send('Página de inicio Wiki');\n});\n\n// About page route\nrouter.get('/about', function(req, res) {\n  res.send('Acerca de esta wiki');\n});\n\nmodule.exports = router;\n\n\n\n  -info-Agregar rutas al objeto Router es como agregar rutas al objeto app (como se vio anteriormente).\n\n\nPara usar el router en nuestro archivo app principal, necesitamos require() el módulo de rutas (wiki.js), entonces llama a use() en la aplicación Express para agregar el Router al software intermediario que maneja las rutas. Las dos rutas serán accesibles entonces desde /wiki/ y /wiki/about/.\n\n1\n2\n3\nvar wiki = require('./wiki.js');\n// ...\napp.use('/wiki', wiki);\n\n\nLe mostraremos mucho más sobre como trabajar con rutas, y en particular, acerca de como usar el Router, más adelante en la sección Rutas y controladores .\n\nUsando middleware\n\nEl “middleware” es ampliamente utilizado en las aplicaciones de Express: desde tareas para servir archivos estáticos, a la gestión de errores o la compresión de las respuestas HTTP. Mientras las funciones de enrutamiento, con el objeto express.Router, se encargan del ciclo petición-respuesta, al gestionar la respuesta adecuada al cliente, las funciones de middleware normalmente realizan alguna operación al gestionar una petición o respuesta y a continuación llaman a la siguiente función en la “pila”, que puede ser otra función de middleware u otra función de enrutamiento. El orden en el que las funciones de middleware son llamadas depende del desarrollador de la aplicación.\n\n\n  -info-El middleware puede realizar cualquier operación: hacer cambios a una petición, ejecutar código, realizar cambios a la petición o al objeto pedido, puede también finalizar el ciclo de petición-respuesta. Si no finaliza el ciclo debe llamar a la función next() para pasar el control de la ejecución a la siguiente función del middleware ( o a la petición quedaría esperando una respuesta … ).\n\n\nLa mayoría de las aplicaciones usan middleware desarrollado por terceras partes, para simplificar funciones habituales en el desarrollo web, como puede ser: gestión de cookies, sesiones, autentificado de usuarios, peticiones POST y datos en JSON, registros de eventos, etc. Puede encontrar en el siguiente enlace una lista de middleware mantenido por el equipo de Express (que también incluye otros paquetes populares de terceras partes). Las librerías de Express están disponibles con la aplicación NPM (Node Package Manager).\n\nPara usar estas colecciones, primero ha de instalar la aplicación usando NPM. Por ejemplo para instalar el registro de peticiones HTTP morgan, se haría con el comando Bash:\n\n1\nnpm install morgan\n\n\nEntonces podrías llamar a la función use() en un objeto de aplicación Express para utilizar este middleware a su aplicación.\n\n1\n2\n3\n4\n5\nvar express = require('express');\nvar logger = require('morgan');\nvar app = express();\napp.use(logger('dev'));\n...\n\n\n\n  -info-Las funciones Middleware y routing son llamadas en el orden que son declaradas. Para algunos middleware el orden es importante (por ejemplo si el middleware de sesion depende del middleware de cookie, entonces el manejador de cookie tiene que ser llamado antes). Casi siempre es el caso que el middleware es llamado antes de configurar las rutas, o tu manejador de rutas no tendra acceso a la funcionalidad agregada por tu middleware.\n\n\nTu puedes escribir tu propia funcion middleware, y si quieres hacerlo así (solo para crear código de manejo de error). La única diferencia entre una función middleware y un callback manejador de rutas es que las funciones middleware tienen un tercer argumento next, cuyas funciones middleware son esperadas para llamarlas si ellas no completan el ciclo request (cuando la función midleware es llamada, esta contiene la próxima función que debe ser llamada).\n\nPuedes agregar una función middleware a la cadena de procesamiento con cualquier app.use() o app.add(), dependiendo de si quiere aplicar el middleware a todas las respuestas o a respuestas con un verbo particular HTTP (GET, POST, etc). Usted especifica rutas, lo mismo en ambos casos, aunque la ruta es opcional cuando llama app.use().\n\nEl ejemplo de abajo muestra como puede agregar la función middleware usando ambos métodos, y con/sin una ruta.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvar express = require('express');\nvar app = express();\n\n// An example middleware function\nvar a_middleware_function = function(req, res, next) {\n  // ... perform some operations\n  next(); // Call next() so Express will call the next middleware function in the chain.\n}\n\n// Function added with use() for all routes and verbs\napp.use(a_middleware_function);\n\n// Function added with use() for a specific route\napp.use('/someroute', a_middleware_function);\n\n// A middleware function added for a specific HTTP verb and route\napp.get('/', a_middleware_function);\n\napp.listen(3000);\n\n\n\n  -info-Arriba declaramos la función middleware separadamente y la configuramos como el callback. En nuestra función previous manejadora de ruta declaramos la función callback cuando esta fué usada. En JavaScript, cuealquer aproximación es valida.\n\n\nLa documentación Express tiene mucha mas documentación excelente acerca del uso y escritura de middleware Express.\n\nSirviendo archivos estáticos\n\nPuede utilizar el middleware express.static para servir archivos estáticos, incluyendo sus imagenes, CSS y JavaScript (static() es la única función middleware que es actualmente parte de Express). Por ejemplo, podria utilizar la linea de abajo para servir imágenes, archivos CSS, y archivos JavaScript desde un directorio nombrado ‘public’ al mismo nivel desde donde llama a node:\n\n1\napp.use(express.static('public'));\n\n\nCualesquiere archivos en el directorio público son servidos al agregar su nombre de archivo (relativo a la ubicación del directorio “público” ) de la ubicación URL. Por ejemplo:\n\n1\n2\n3\n4\nhttp://localhost:3000/images/dog.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/about.html\n\n\nPuede llamar static() multiples ocasiones a servir multiples directorios. Si un archivo no puede ser encontrado por una función middleware entonces este simplemente será pasado en la subsequente middleware (el orden en que el middleware está basado en su orden de declaración).\n\n1\n2\napp.use(express.static('public'));\napp.use(express.static('media'));\n\n\nTambién puede crear un prefijo virtual para sus URLs estáticas, aun más teniendo los archivos agregados en la ubicación URL. Por ejemplo, aqui especificamos a mount path tal que los archivos son bajados con el prefijo “/media”:\n\n1\napp.use('/media', express.static('public'));\n\n\nAhora, puede bajar los archivos que estan en el directorio publico del path con prefijo /media.\n\n1\n2\n3\nhttp://localhost:3000/media/images/dog.jpg\nhttp://localhost:3000/media/video/cat.mp4\nhttp://localhost:3000/media/cry.mp3\n\n\nPara más información, ver Sirviendo archivos estáticos en Express.\n\nManejando errores\n\nLos errores manejados por una o más funciones especiales middleware que tienen cuatro argumentos, en lugar de las usuales tres: (err, req, res, next). For example:\n\n1\n2\n3\n4\napp.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\n\nEstas pueden devolver cualquier contenido, pero deben ser llamadas despues de todas las otras app.use() llamadas de rutas tal que ellas son las últimas middleware en el proceso de manejo de request!\n\nExpress viene con un manejador de error integrado, el que se ocupa de error remanente que pudiera ser encontrado en la app. Esta función middleware manejador de error esta agregada al final del stack de funciones middleware. Si pasa un error a next() y no lo maneja en un manejador de error, este sera manejado por el manejador de error integrado; el error sera escrito en el cliente con el rastreo de pila.\n\n\n  -info-El rastreo de pila no esta incluido en el ambiente de producción. Para ejecutarlo en modo de producción necesita configurar la variable de ambiente NODE_ENV to ‘production'.\n\n  HTTP404 y otros códigos de estatus de “error” no son tratados como errores. Si quiere manejar estos, puede agregar una función middleware para hacerlo. Para mas información vea las FAQ.\n\n\nPara mayor información vea Manejo de error (Docs. Express).\n\nUsando Bases de datos\n\nLas apps de Express pueden usar cualquier mecanismo de bases de datos suportadas por Node (Express en sí mismo no define ninguna conducta/requerimiento especifico adicional para administración de bases de datos). Hay muchas opciones, incluyendo PostgreSQL, MySQL, Redis, SQLite, MongoDB, etc.\n\nCon el propósito de usar éste, debe primero instalar el manejador de bases de datos utilizando NPM. Por ejemplo, para instalar el manejador para el popular NoSQL MongoDB querría utilizar el comando:\n\n1\nnpm install mongodb\n\n\nLa base de datos por si misma puede ser instalada localmente o en un servidor de la nube. En su codigo Express requiere el manejador, conectarse a la base de datos, y entonces ejecutar operaciones crear, leer, actualizar, y borrar (CLAB). }El ejemplo de abajo (de la documentación Express documentation) muestra como puede encontrar registros en la colección “mamiferos” usando MongoDB.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nvar MongoClient = require('mongodb').MongoClient;\n\nMongoClient.connect('mongodb://localhost:27017/animals', function(err, db) {\n  if (err) throw err;\n\n  db.collection('mammals').find().toArray(function (err, result) {\n    if (err) throw err;\n\n    console.log(result);\n  });\n});\n\n\nOtra aproximación popular es acceder a su base de datos indirectamente, via an Mapeo Objeto Relacional (“MOR”). En esta aproximación usted define sus datos como “objetos” o “modelos” y el MOR mapea estos a través del delineamiento básico de la base de datos. Esta aproximación tiene el beneficio de que como un desarrollador puede continuar pensando en términos de objetos de JavaScript mas que en semántica de bases de datos, y en esto hay un lugar obvio para ejecutar la validación y chequeo de entrada de datos. Hablaremos más de bases de datos en un artículo posterior.\n\nPara más información ver Integracion de Bases de Datos (docs Express ).\n\nRenderización de data (vistas)\n\nEl Motor de plantilla (referido como “motor de vistas” por Express) le permite definir la estructura de documento de salida en una plantilla, usando marcadores de posición para datos que seran llenados cuando una pagina es generada. Las plantillas son utilizadas generalmete para crear HTML, pero tambien pueden crear otros tipos de documentos. Express tiene soporte para numerosos motores de plantillas, y hay una util comparación de los motores más populares aquí: Comparando Motores de Plantillas de JavaScript: Jade, Mustache, Dust and More.\n\nEn su código de configuración de su aplicación usted configura el motor de plantillas para usar y su localización Express podiría buscar plantillas usando las configuraciones de ‘vistas’ y ‘motores de vistas’, mostrado abajo (tendría también que instalar el paquete conteniendo su librería de plantillas!)\n\n1\n2\n3\n4\n5\n6\n7\n8\nvar express = require('express');\nvar app = express();\n\n// Set directory to contain the templates ('views')\napp.set('views', path.join(__dirname, 'views'));\n\n// Set view engine to use, in this case 'some_template_engine_name'\napp.set('view engine', 'some_template_engine_name');\n\n\nLa apariencia de la plantilla dependera de qué motor use. Asumiendo que tiene un archivo de plantillas nombrado “index.&lt;template_extension&gt;” este contiene placeholders para variables de datos nombradas ‘title’ y “message”, podría llamar Response.render() en una función manejadora de rutas para crear y enviar la HTML response:\n\n1\n2\n3\napp.get('/', function(req, res) {\n  res.render('index', { title: 'About dogs', message: 'Dogs rock!' });\n});\n\n\nPara más información vea Usando motores de plantillas con Express.\n\nEstructura de Archivos\n\nExpress no hace asunciones en términos de estructura o que componentes usted usa. Rutas, vistas, archivos estáticos, y otras lógicas de aplicación específica puede vivir en cualquier número de archivos con cualquier estructura de directorio. Mientras que esto es perfectamente posible, se puede tener toda la aplicación en un solo archivo, en Express, tipicamente esto tiene sentido al desplegar su aplicacion dentro de archivos basados en función (e.g. administracion de cuentas, blogs, tableros de discusion) y dominio de problema arquitectonico (e.g. modelo, vista or controlador si tu pasas a estar usando una arquitectura MVC).\n\nEn un tópico posterior usaremos el Generador de Aplicaciones Express Application Generator, el que crea un esquelo de una app modular que podemos facilmente extender para crear aplicaciones web.\n\nResumen\n\n¡Felicitaciones, ha completado el primer paso en su viaje Express/Node! Ahora debes comprender los principales beneficios de Express y Node, y más o menos cómo se verían las partes principales de una aplicación Express (rutas, middleware, manejo de errores y plantillas). ¡También debe comprender que con Express como un framework unopinionated, la forma en que une estas partes y las bibliotecas que usa dependen en gran medida de usted!\n\nPor supuesto, Express es deliberadamente un un framework de aplicaciones web muy ligero, por lo que gran parte de sus beneficios y potencial proviene de bibliotecas y características de terceros. Lo veremos con más detalle en los siguientes artículos. En nuestro próximo artículo, veremos cómo configurar un entorno de desarrollo de Node, para que pueda comenzar a ver código de Express en acción.\n\nVer también\n\n\n  Modules (Node API docs)\n  Express (home page)\n  Basic routing (Express docs)\n  Routing guide (Express docs)\n  Using template engines with Express (Express docs)\n  Using middleware (Express docs)\n  Writing middleware for use in Express apps (Express docs)\n  Database integration (Express docs)\n  Serving static files in Express (Express docs)\n  Error handling (Express docs)\n\n\n",
        "url": "/node-express-library-teoria/node-introduccion"
      }
      
    
  };
</script>
<script src="/node-express-library-teoria/assets/js/lunr.min.js"></script>
<script src="/node-express-library-teoria/assets/js/search.js"></script>

</div>

        <a href="#top" id='back-to-top-link'><i class='fa fa-angle-up'></i></a>
         <hr>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Licencia de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Esta obra está bajo una <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional</a>.

      </div>
    </div>    
    <script src="/node-express-library-teoria/assets/js/main.js"></script>
      <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-56FXN2KND3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-56FXN2KND3');
  </script>
  

  </body>
</html>
