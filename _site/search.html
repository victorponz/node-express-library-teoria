<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title></title>
    <link rel="shortcut icon" href="/node-express-library-teoria/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/node-express-library-teoria/favicon.ico" type="image/x-icon"> 
    <link href="/node-express-library-teoria/assets/css/syntax.css" rel="stylesheet">
    <link rel="stylesheet" href="/node-express-library-teoria/assets/css/styles.css">
    <link rel='stylesheet' href='https://use.fontawesome.com/releases/v5.0.13/css/all.css' integrity='sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp' crossorigin='anonymous'>
    <link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
  </head>
  <body class='preview-zenburn'>
   <a id="top"></a>
    <a class="github-fork-ribbon" href="https://github.com/victorponz/node-express-library-teoria" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div id='write-wrapper'>
      <nav class="topnav" id="myTopnav">
  
    <a href="/node-express-library-teoria/" >Índice</a>
  
    <a href="/node-express-library-teoria/search.html" class="active">Buscar</a>
  
  <a href="javascript:void(0);" class="icon" onclick="showMenu()">
    <i class="fa fa-bars"></i>
  </a>
</nav>


      <div id='write'>
        <div class="search">
	<form action="/node-express-library-teoria/search.html" method="get">
  <label for="search-box">Búsqueda</label>
  <input type="text" id="search-box" name="query">
  <input type="submit" value="Buscar">
</form>

<ul id="search-results"></ul>

<script>
  window.store = {
    
      "trabajar-con-formularios": {
        "title": "Tutorial Express - parte 6: Trabajar con formularios",
        "content": "Introducción\n\nUn formulario HTML es un grupo de uno o más campos/widgets en una página web que se puede usar para recopilar información de los usuarios para enviarla a un servidor. Los formularios son un mecanismo flexible para recopilar información del usuario porque hay entradas de formulario adecuadas disponibles para ingresar muchos tipos diferentes de datos: cuadros de texto, casillas de verificación, botones de radio, selectores de fecha, etc. Los formularios también son una forma relativamente segura de compartir datos con el servidor. , ya que nos permiten enviar datos en solicitudes POST con protección contra falsificación de solicitudes entre sitios. (CSRF - Cross Site Request Forgery)\n\n¡Trabajar con formularios puede ser complicado! Los desarrolladores deben escribir HTML para el formulario, validar y desinfectar adecuadamente los datos ingresados en el servidor (y posiblemente también en el navegador), volver a publicar el formulario con mensajes de error para informar a los usuarios sobre cualquier campo no válido, manejar los datos cuando se hayan enviado correctamente. y finalmente responder al usuario de alguna manera para indicar el éxito.\n\nEn este tutorial, te mostraremos cómo se pueden realizar las operaciones anteriores en Express. En el camino, ampliaremos el sitio web de LocalLibrary para permitir que los usuarios creen, editen y eliminen elementos de la biblioteca.\n\nFormularios HTML\n\nPrimero, una breve descripción general de los formularios HTML. Considera un formulario HTML simple, con un solo campo de texto para ingresar el nombre de algún “equipo” y su etiqueta asociada:\n\n\n\nEl formulario se define en HTML como una colección de elementos dentro de las etiquetas &lt;form&gt;…&lt;/form&gt;, que contienen al menos un elemento de entrada de type=\"submit\".\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n&lt;form action=\"/team_name_url/\" method=\"post\"&gt;\n  &lt;label for=\"team_name\"&gt;Enter name: &lt;/label&gt;\n  &lt;input\n    id=\"team_name\"\n    type=\"text\"\n    name=\"name_field\"\n    value=\"Default name for team.\" /&gt;\n  &lt;input type=\"submit\" value=\"OK\" /&gt;\n&lt;/form&gt;\n\n\nSi bien aquí hemos incluido solo un campo (de texto) para ingresar el nombre del equipo, un formulario puede contener cualquier número de otros elementos de entrada y sus etiquetas asociadas. El atributo de tipo del campo define qué tipo de widget se mostrará. El nombre y la identificación del campo se utilizan para identificar el campo en JavaScript/CSS/HTML, mientras que el valor define el valor inicial del campo cuando se muestra por primera vez. La etiqueta del equipo coincidente se especifica mediante la etiqueta de label (consulta “Ingrese el nombre” más arriba), con un campo for que contiene el valor de identificación de la entrada asociada.\n\nLa entrada de envío se mostrará como un botón (de forma predeterminada); el usuario puede presionarlo para cargar los datos contenidos en los otros elementos de entrada al servidor (en este caso, solo el nombre del equipo). Los atributos del formulario definen el método HTTP utilizado para enviar los datos y el destino de los datos en el servidor (action):\n\n\n  action: el recurso/URL donde se enviarán los datos para su procesamiento cuando se envíe el formulario. Si no se establece (o se establece en una cadena vacía), el formulario se enviará de nuevo a la URL de la página actual.\n  method: El método HTTP utilizado para enviar los datos: POST o GET`.\n    \n      El método POST siempre debe usarse si los datos van a resultar en un cambio en la base de datos del servidor, ya que esto puede hacerse más resistente a los ataques de solicitud de falsificación entre sitios.\n      El método GET solo debe usarse para formularios que no cambian los datos del usuario (por ejemplo, un formulario de búsqueda). Se recomienda para cuando desees poder marcar o compartir la URL.\n    \n  \n\n\nProceso de manejo de formularios\n\nEl manejo de formularios utiliza las mismas técnicas que aprendimos para mostrar información sobre nuestros modelos: la ruta envía nuestra solicitud a una función de controlador que realiza las acciones de base de datos requeridas, incluida la lectura de datos de los modelos, luego genera y devuelve una página HTML. Lo que complica más las cosas es que el servidor también debe poder procesar los datos proporcionados por el usuario y volver a mostrar el formulario con información de error si hay algún problema.\n\nA continuación se muestra un diagrama de flujo de proceso para procesar solicitudes de formularios, que comienza con una solicitud de una página que contiene un formulario (que se muestra en verde):\n\n\n\nComo se muestra en el diagrama anterior, las cosas principales que debe hacer el código de manejo de formularios son:\n\n\n  Mostrar el formulario predeterminado la primera vez que lo solicite el usuario.\n    \n      El formulario puede contener campos en blanco (p. ej., si estás creando un nuevo registro), o se puede completar previamente con valores iniciales (p. ej., si estás cambiando un registro o tiene valores iniciales predeterminados útiles).\n    \n  \n  Recibir datos enviados por el usuario, generalmente en una solicitud HTTP POST.\n  Validar y desinfectar los datos.\n  Si algún dato no es válido, volver a mostrar el formulario, esta vez con los valores completados por el usuario y los mensajes de error para los campos problemáticos.\n  Si todos los datos son válidos, realizar las acciones requeridas (p. ej., guardar los datos en la base de datos, enviar un correo electrónico de notificación, devolver el resultado de una búsqueda, cargar un archivo, etc.\n  Una vez completadas todas las acciones, redirigir al usuario a otra página.\n\n\nA menudo, el código de manejo de formularios se implementa utilizando una ruta GET para la visualización inicial del formulario y una ruta POST a la misma ruta para manejar la validación y el procesamiento de los datos del formulario. Este es el enfoque que se utilizará en este tutorial.\n\nExpress en sí mismo no proporciona ningún soporte específico para las operaciones de manejo de formularios, pero puedes usar middleware para procesar los parámetros POST y GET del formulario y para validar/desinfectar sus valores.\n\nValidación y sanitización\n\nAntes de almacenar los datos de un formulario, se deben validar y sanitizar:\n\nLa validación verifica que los valores ingresados sean apropiados para cada campo (estén en el rango correcto, formato, etc.) y que se hayan proporcionado valores para todos los campos obligatorios.\nLa sanitización elimina/reemplaza caracteres en los datos que podrían usarse para enviar contenido malicioso al servidor.\n\nPara este tutorial, usaremos el popular módulo express-validator para realizar tanto la validación como la sanitización de los datos de nuestro formulario.\n\nInstalación\n\nInstala el módulo ejecutando el siguiente comando en la raíz del proyecto.\n\n1\nnpm install express-validator\n\n\nUsando express-validator\n\n\n  -info- La guía express-validator en GitHub proporciona una buena descripción general de la API. Te recomiendo que leas eso para tener una idea de todas sus capacidades (incluido el uso de la validación de esquemas y la creación de https://express-validator.github.io/docs/custom-validators-sanitizers.html). A continuación, cubrimos solo un subconjunto que es útil para LocalLibrary.\n\n\nPara usar el validador en nuestros controladores, especificamos las funciones particulares que queremos importar desde el módulo express-validator, como se muestra a continuación:\n\n1\nconst { body, validationResult } = require(\"express-validator\");\n\n\nHay muchas funciones disponibles que te permiten verificar y sanitizar los datos de los parámetros de la solicitud, el cuerpo, los encabezados, las cookies, etc., o todos a la vez. Para este tutorial, usaremos principalmente el body y el validationResult.\n\nLas funciones se definen como sigue:\n\n\n  \n    body([fields, message]) Especifica un conjunto de campos en el cuerpo de la solicitud (un parámetro POST) para validar y/o sanitizar junto con un mensaje de error opcional que se puede mostrar si fallan las pruebas. Los criterios de validación y saneamiento están conectados en cadena con el método body(). Por ejemplo, la línea a continuación define primero que estamos revisando el campo name y que un error de validación generará un mensaje de error “Empty name”. Luego llamamos al método de sanitización trim() para eliminar los espacios en blanco desde el principio y el final de la cadena, y luego isLength() para verificar que la cadena resultante no esté vacía. Finalmente, llamamos a escape() para eliminar los caracteres HTML de la variable que podrían usarse en los ataques de secuencias de comandos entre sitios de JavaScript.\n\n    1\n2\n3\n4\n5\n[\n  // …\n  body(\"name\", \"Empty name\").trim().isLength({ min: 1 }).escape(),\n  // …\n];\n    \n\n    Esta prueba verifica que el campo age sea una fecha válida y usa optional() para especificar que las cadenas nulas y vacías no fallarán en la validación.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n[\n  // …\n  body(\"age\", \"Invalid age\")\n    .optional({ checkFalsy: true })\n    .isISO8601()\n    .toDate(),\n  // …\n];\n    \n\n    También puedes conectar en cadena diferentes validadores y agregar mensajes que se muestran si los validadores anteriores son verdaderos.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n[\n  // …\n  body(\"name\")\n    .trim()\n    .isLength({ min: 1 })\n    .withMessage(\"Name empty.\")\n    .isAlpha()\n    .withMessage(\"Name must be alphabet letters.\"),\n  // …\n];\n    \n  \n  \n    validationResult(req) Ejecuta la validación, haciendo que los errores estén disponibles en forma de un objeto validationResult. Este se invoca en una devolución de llamada separada, como se muestra a continuación:\n  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n  (req, res, next) =&gt; {\n    // Extract the validation errors from a request.\n    const errors = validationResult(req);\n  \n    if (!errors.isEmpty()) {\n      // There are errors. Render form again with sanitized values/errors messages.\n      // Error messages can be returned in an array using `errors.array()`.\n    } else {\n      // Data from form is valid.\n    }\n  };\n\n\nUsamos el método isEmpty() del resultado de la validación para verificar si hubo errores, y su método array() para obtener el conjunto de mensajes de error. Consulta la API de validationResults para obtener más información.\n\nLas cadenas de validación y sanitización son middleware que deben pasarse al controlador de ruta Express (lo hacemos indirectamente, a través del controlador). Cuando se ejecuta el middleware, cada validador/sanitizador se ejecuta en el orden especificado.\n\nCubriremos algunos ejemplos reales cuando implementemos los formularios LocalLibrary a continuación.\n\nDiseño de formulario\n\nMuchos de los modelos de la biblioteca están relacionados o son dependientes; por ejemplo, un libro requiere un autor y también puede tener uno o más géneros. Esto plantea la cuestión de cómo debemos manejar el caso en el que un usuario desea:\n\n\n  Crear un objeto cuando sus objetos relacionados aún no existan (por ejemplo, un libro donde el objeto de autor no se ha definido).\n  Eliminar un objeto que todavía está siendo utilizado por otro objeto (por ejemplo, eliminando un género que todavía está siendo utilizado por un libro).\n\n\nPara este proyecto, simplificaremos la implementación indicando que un formulario solo puede:\n\n\n  Crear un objeto usando objetos que ya existen (por lo que los usuarios tendrán que crear las instancias de author y genre requeridas antes de intentar crear cualquier objeto de libro).\n  Eliminar un objeto si otros objetos no hacen referencia a él (por ejemplo, no podrás eliminar un book hasta que se hayan eliminado todos los objetos BookInstance asociados).\n\n\n\n  -info-Una implementación más “robusta” podría permitirte crear los objetos dependientes al crear un nuevo objeto y eliminar cualquier objeto en cualquier momento (por ejemplo, eliminando objetos dependientes o eliminando referencias al objeto eliminado de la base de datos).\n\n\nRutas\n\nPara implementar nuestro código de manejo de formularios, necesitaremos dos rutas que tengan el mismo patrón de URL. La primera ruta (GET) se usa para mostrar un nuevo formulario vacío para crear el objeto. La segunda ruta (POST) se utiliza para validar los datos ingresados por el usuario y luego guardar la información y redirigir a la página de detalles (si los datos son válidos) o volver a mostrar el formulario con errores (si los datos no son válidos).\n\nYa hemos creado las rutas para todas las páginas de creación de nuestro modelo en /routes/catalog.js (en un tutorial anterior). Por ejemplo, las rutas de genre se muestran a continuación:\n\n1\n2\n3\n4\n5\n// GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).\nrouter.get(\"/genre/create\", genre_controller.genre_create_get);\n\n// POST request for creating Genre.\nrouter.post(\"/genre/create\", genre_controller.genre_create_post);\n\n\nFormulario Genre\n\nEste subartículo muestra cómo definimos nuestra página para crear objetos Genre (este es un buen lugar para comenzar porque el Genre tiene solo un campo, su nombre y no tiene dependencias). Como cualquier otra página, necesitamos configurar rutas, controladores y vistas.\n\nMétodos de validación y sanitización de importaciones\n\nPara usar express-validator en nuestros controladores, debemos solicitar las funciones que queremos usar del módulo ‘express-validator’.\n\nAbre /controllers/genreController.js y agrega la siguiente línea en la parte superior del archivo:\n\n1\nconst { body, validationResult } = require(\"express-validator\");\n\n\n\n  -info-Esta sintaxis nos permite usar el body y el validationResult como las funciones de middleware asociadas, como verá en la sección de ruta posterior a continuación. es equivalente a:\n\n  1\n2\n3\nconst validator = require(\"express-validator\");\nconst body = validator.body;\nconst validationResult = validator.validationResult;\n  \n\n\nControlador ruta GET\n\nEn el método genre_create_get pega el siguiente código. Renderiza la plantilla  genre_form.pug pasándole title como parámetro:\n\n1\n2\n3\n4\n// Display Genre create form on GET.\nexports.genre_create_get = (req, res, next) =&gt; {\n  res.render(\"genre_form\", { title: \"Create Genre\" });\n};\n\n\nControlador ruta POST\n\nEn el método genre_create_post pega el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n// Handle Genre create on POST.\nexports.genre_create_post = [\n  // Validate and sanitize the name field.\n  body(\"name\", \"Genre name required\").trim().isLength({ min: 1 }).escape(),\n\n  // Process request after validation and sanitization.\n  (req, res, next) =&gt; {\n    // Extract the validation errors from a request.\n    const errors = validationResult(req);\n\n    // Create a genre object with escaped and trimmed data.\n    const genre = new Genre({ name: req.body.name });\n\n    if (!errors.isEmpty()) {\n      // There are errors. Render the form again with sanitized values/error messages.\n      res.render(\"genre_form\", {\n        title: \"Create Genre\",\n        genre,\n        errors: errors.array(),\n      });\n      return;\n    } else {\n      // Data from form is valid.\n      // Check if Genre with same name already exists.\n      Genre.findOne({ name: req.body.name }).exec((err, found_genre) =&gt; {\n        if (err) {\n          return next(err);\n        }\n\n        if (found_genre) {\n          // Genre exists, redirect to its detail page.\n          res.redirect(found_genre.url);\n        } else {\n          genre.save((err) =&gt; {\n            if (err) {\n              return next(err);\n            }\n            // Genre saved. Redirect to genre detail page.\n            res.redirect(genre.url);\n          });\n        }\n      });\n    }\n  },\n];\n\n\nLo primero que hay que tener en cuenta es que, en lugar de ser una única función de middleware (con argumentos (req, res, next)), el controlador especifica un array de funciones de middleware. La matriz se pasa a la función del enrutador y cada método se llama en orden.\n\n\n  -warning-Este enfoque es necesario porque los validadores son funciones de middleware.\n\n\nEl primer método del array define un validador de cuerpo (body()) que valida y sanitiza el campo. Usa trim() para eliminar cualquier espacio en blanco al final/adelante, verifica que el campo de nombre no esté vacío y luego usa escape() para eliminar cualquier carácter HTML peligroso).\n\n1\n2\n3\n4\n5\n[\n  // Validate that the name field is not empty.\n  body(\"name\", \"Genre name required\").trim().isLength({ min: 1 }).escape(),\n  // …\n];\n\n\nDespués de especificar los validadores, creamos una función de middleware para extraer cualquier error de validación. Usamos isEmpty() para verificar si hay algún error en el resultado de la validación. Si los hay, renderizamos el formulario nuevamente, pasando nuestro objeto Genre sanitizado y la matriz de mensajes de error (errors.array()).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n// Process request after validation and sanitization.\n(req, res, next) =&gt; {\n  // Extract the validation errors from a request.\n  const errors = validationResult(req);\n\n  // Create a genre object with escaped and trimmed data.\n  const genre = new Genre({ name: req.body.name });\n\n  if (!errors.isEmpty()) {\n    // There are errors. Render the form again with sanitized values/error messages.\n    res.render(\"genre_form\", {\n      title: \"Create Genre\",\n      genre,\n      errors: errors.array(),\n    });\n    return;\n  } else {\n    // Form data is valid.\n    // Save the result.\n    // …\n  }\n};\n\n\nSi los datos del nombre del género son válidos, verificamos si ya existe un género con el mismo nombre (ya que no queremos crear duplicados). Si es así, lo redirigimos a la página de detalles del género existente. Si no, guardamos el nuevo Género y redirigimos a su página de detalles.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n// Check if Genre with same name already exists.\nGenre.findOne({ name: req.body.name }).exec((err, found_genre) =&gt; {\n  if (err) {\n    return next(err);\n  }\n  if (found_genre) {\n    // Genre exists, redirect to its detail page.\n    res.redirect(found_genre.url);\n  } else {\n    genre.save((err) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      // Genre saved. Redirect to genre detail page.\n      res.redirect(genre.url);\n    });\n  }\n});\n\n\nEste mismo patrón se usa en todos nuestros controladores de correos: ejecutamos validadores (con sanitizadores), luego verificamos si hay errores y volvemos a presentar el formulario con información de error o guardamos los datos.\n\nVista\n\nLa misma vista se representa en los controladores/rutas GET y POST cuando creamos un nuevo género (y más adelante también se usa cuando actualizamos un género). En el caso GET, el formulario está vacío y solo pasamos una variable title. En el caso de POST, si el usuario ha introducido previamente datos no válidos; en la variable de género, devolvemos una versión limpia de los datos introducidos y en la variable de errores, devolvemos una serie de mensajes de error.\n\n1\n2\n3\n4\n5\n6\nres.render(\"genre_form\", { title: \"Create Genre\" });\nres.render(\"genre_form\", {\n  title: \"Create Genre\",\n  genre,\n  errors: errors.array(),\n});\n\n\nCrea /views/genre_form.pug y copia el texto a continuación.\n\nextends layout\n\nblock content\n  h1 #{title}\n\n  form(method='POST' action='')\n    div.form-group\n      label(for='name') Genre:\n      input#name.form-control(type='text', placeholder='Fantasy, Poetry etc.' name='name' value=(undefined===genre ? '' : genre.name))\n    button.btn.btn-primary(type='submit') Submit\n\n  if errors\n   ul\n    for error in errors\n     li!= error.msg\n\n\nGran parte de esta plantilla te resultará familiar de nuestros tutoriales anteriores. Primero, extendemos la plantilla base layout.pug y anulamos el bloque llamado content. Luego tenemos un encabezado con el title que pasamos desde el controlador (a través del método render()).\n\nA continuación, tenemos el código pug para nuestro formulario HTML que usa method=\"POST\" para enviar los datos al servidor y, dado que la acción es una cadena vacía, enviará los datos a la misma URL que la página.\n\nEl formulario define un solo campo obligatorio de tipo text llamado name. El valor predeterminado del campo depende de si la variable de género está definida. Si se llama desde la ruta GET, estará vacío ya que se trata de un formulario nuevo. Si se llama desde una ruta POST, contendrá el valor (no válido) ingresado originalmente por el usuario.\n\nLa última parte de la página es el código de error. Esto imprime una lista de errores, si se ha definido la variable de error (en otras palabras, esta sección no aparecerá cuando la plantilla se represente en la ruta GET).\n\n\n  -info-Esta es solo una forma de representar los errores. También puedea obtener los nombres de los campos afectados de la variable de error y utilizarlos para controlar dónde se representan los mensajes de error, si aplicar CSS personalizado, etc.\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación, abre el navegador en http://localhost:3000/, luego selecciona el enlace Create new Genre. Si todo está configurado correctamente, tu sitio debería parecerse a la siguiente captura de pantalla. Después de ingresar un valor, debe guardarse y accederás a la página de detalles del género.\n\n\n\nEl único error que validamos contra el lado del servidor es que el campo de género no debe estar vacío. La siguiente captura de pantalla muestra cómo se vería la lista de errores si no proporcionaras un género (resaltado en rojo).\n\n\n\nFormulario Author\n\nAl igual que con el formulario de Genre, para usar express-validator debemos requerir las funciones que queremos usar.\n\nAbre /controllers/authorController.js y agrega las siguientes líneas en la parte superior del archivo:\n\nControlador ruta GET\n\nEn el método author_create_get pega el siguiente código. Renderiza la plantilla  author_form.pug pasándole title como parámetro:\n\n1\n2\n3\n4\n// Display Author create form on GET.\nexports.author_create_get = (req, res, next) =&gt; {\n  res.render(\"author_form\", { title: \"Create Author\" });\n};\n\n\nControlador ruta POST\n\nEn el método author_create_post pega el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n// Handle Author create on POST.\nexports.author_create_post = [\n  // Validate and sanitize fields.\n  body(\"first_name\")\n    .trim()\n    .isLength({ min: 1 })\n    .escape()\n    .withMessage(\"First name must be specified.\")\n    .isAlphanumeric()\n    .withMessage(\"First name has non-alphanumeric characters.\"),\n  body(\"family_name\")\n    .trim()\n    .isLength({ min: 1 })\n    .escape()\n    .withMessage(\"Family name must be specified.\")\n    .isAlphanumeric()\n    .withMessage(\"Family name has non-alphanumeric characters.\"),\n  body(\"date_of_birth\", \"Invalid date of birth\")\n    .optional({ checkFalsy: true })\n    .isISO8601()\n    .toDate(),\n  body(\"date_of_death\", \"Invalid date of death\")\n    .optional({ checkFalsy: true })\n    .isISO8601()\n    .toDate(),\n  // Process request after validation and sanitization.\n  (req, res, next) =&gt; {\n    // Extract the validation errors from a request.\n    const errors = validationResult(req);\n\n    if (!errors.isEmpty()) {\n      // There are errors. Render form again with sanitized values/errors messages.\n      res.render(\"author_form\", {\n        title: \"Create Author\",\n        author: req.body,\n        errors: errors.array(),\n      });\n      return;\n    }\n    // Data from form is valid.\n\n    // Create an Author object with escaped and trimmed data.\n    const author = new Author({\n      first_name: req.body.first_name,\n      family_name: req.body.family_name,\n      date_of_birth: req.body.date_of_birth,\n      date_of_death: req.body.date_of_death,\n    });\n    author.save((err) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      // Successful - redirect to new author record.\n      res.redirect(author.url);\n    });\n  },\n];\n\n\n\n  -alert-Nunca valides nombres usando isAlphanumeric() (como hemos hecho anteriormente) ya que hay muchos nombres que usan otros conjuntos de caracteres. Lo hacemos aquí para demostrar cómo se usa el validador y cómo se puede conectar en cadena con otros validadores e informes de errores.\n\n\nVista\n\nCrea /views/author_form.pug y copia el texto a continuación.\n\nextends layout\n\nblock content\n  h1=title\n\n  form(method='POST' action='')\n    div.form-group\n      label(for='first_name') First Name:\n      input#first_name.form-control(type='text' placeholder='First name' name='first_name' required='true' value=(undefined===author ? '' : author.first_name) )\n      label(for='family_name') Family Name:\n      input#family_name.form-control(type='text' placeholder='Family name' name='family_name' required='true' value=(undefined===author ? '' : author.family_name))\n    div.form-group\n      label(for='date_of_birth') Date of birth:\n      input#date_of_birth.form-control(type='date' name='date_of_birth' value=(undefined===author ? '' : author.date_of_birth) )\n    button.btn.btn-primary(type='submit') Submit\n  if errors\n    ul\n      for error in errors\n        li!= error.msg\n\n\n\n  -alert-Algunos navegadores no admiten el tipo de entrada = \"date\", por lo que no obtendrás el widget selector de fecha o el marcador de posición predeterminado dd/mm/yyyy, sino que obtendrás un campo de texto sin formato vacío. Una solución es agregar explícitamente el placeholder = 'dd/mm/yyyy' para que en los navegadores menos capaces aún obtengaa información sobre el formato de texto deseado.\n\n\n\n  -reto-A la plantilla anterior le falta un campo para ingresar date-of_death Crea el campo siguiendo el mismo patrón que el grupo de formulario de fecha de nacimiento!\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación, abra su navegador en http://localhost:3000/, luego selecciona el enlace Create new author. Si todo está configurado correctamente, tu sitio debería parecerse a la siguiente captura de pantalla. Después de ingresar un valor, debe guardarse y accederás a la página de detalles del autor.\n\n\n\nFormulario Book\n\nAl igual que con los otros formularios, para usar express-validator debemos requerir las funciones que queremos usar.\n\nAbre /controllers/bookController.js y agrega las siguientes líneas en la parte superior del archivo:\n\n1\nconst { body, validationResult } = require(\"express-validator\");\n\n\nControlador ruta GET\n\nEn el método book_create_get pega el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n// Display book create form on GET.\nexports.book_create_get = (req, res, next) =&gt; {\n  // Get all authors and genres, which we can use for adding to our book.\n  async.parallel(\n    {\n      authors(callback) {\n        Author.find(callback);\n      },\n      genres(callback) {\n        Genre.find(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      res.render(\"book_form\", {\n        title: \"Create Book\",\n        authors: results.authors,\n        genres: results.genres,\n      });\n    }\n  );\n};\n\n\nEsto usa el módulo async (descrito en el Tutorial Express Parte 5: Visualización de datos) para obtener todos los objetos Author y Genre. Estos luego se pasan a la vista book_form.pug como variables denominadas authors y genres (junto con el título de la página).\n\nControlador ruta POST\n\nLocaliza el método book_create_post y pega este código:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n// Handle book create on POST.\nexports.book_create_post = [\n  // Convert the genre to an array.\n  (req, res, next) =&gt; {\n    if (!Array.isArray(req.body.genre)) {\n      req.body.genre =\n        typeof req.body.genre === \"undefined\" ? [] : [req.body.genre];\n    }\n    next();\n  },\n\n  // Validate and sanitize fields.\n  body(\"title\", \"Title must not be empty.\")\n    .trim()\n    .isLength({ min: 1 })\n    .escape(),\n  body(\"author\", \"Author must not be empty.\")\n    .trim()\n    .isLength({ min: 1 })\n    .escape(),\n  body(\"summary\", \"Summary must not be empty.\")\n    .trim()\n    .isLength({ min: 1 })\n    .escape(),\n  body(\"isbn\", \"ISBN must not be empty\").trim().isLength({ min: 1 }).escape(),\n  body(\"genre.*\").escape(),\n\n  // Process request after validation and sanitization.\n  (req, res, next) =&gt; {\n    // Extract the validation errors from a request.\n    const errors = validationResult(req);\n\n    // Create a Book object with escaped and trimmed data.\n    const book = new Book({\n      title: req.body.title,\n      author: req.body.author,\n      summary: req.body.summary,\n      isbn: req.body.isbn,\n      genre: req.body.genre,\n    });\n\n    if (!errors.isEmpty()) {\n      // There are errors. Render form again with sanitized values/error messages.\n\n      // Get all authors and genres for form.\n      async.parallel(\n        {\n          authors(callback) {\n            Author.find(callback);\n          },\n          genres(callback) {\n            Genre.find(callback);\n          },\n        },\n        (err, results) =&gt; {\n          if (err) {\n            return next(err);\n          }\n\n          // Mark our selected genres as checked.\n          for (const genre of results.genres) {\n            if (book.genre.includes(genre._id)) {\n              genre.checked = \"true\";\n            }\n          }\n          res.render(\"book_form\", {\n            title: \"Create Book\",\n            authors: results.authors,\n            genres: results.genres,\n            book,\n            errors: errors.array(),\n          });\n        }\n      );\n      return;\n    }\n\n    // Data from form is valid. Save book.\n    book.save((err) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      // Successful: redirect to new book record.\n      res.redirect(book.url);\n    });\n  },\n];\n\n\nLa estructura y el comportamiento de este código es casi exactamente el mismo que para crear un objeto Género o Autor. Primero validamos y desinfectamos los datos. Si los datos no son válidos, volvemos a mostrar el formulario junto con los datos ingresados originalmente por el usuario y una lista de mensajes de error. Si los datos son válidos, guardamos el nuevo registro del libro y redirigimos al usuario a la página de detalles del libro.\n\nLa principal diferencia con respecto al otro código de manejo de formularios es cómo desinfectamos la información del género. El formulario devuelve una matriz de elementos de Género (mientras que para otros campos devuelve una cadena). Para validar la información, primero convertimos la solicitud en una matriz (requerido para el siguiente paso).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n[\n  // Convert the genre to an array.\n  (req, res, next) =&gt; {\n    if (!Array.isArray(req.body.genre)) {\n      req.body.genre =\n        typeof req.body.genre === \"undefined\" ? [] : [req.body.genre];\n    }\n    next();\n  },\n  // …\n];\n\n\nLuego usamos un comodín (*) en el desinfectante para validar individualmente cada una de las entradas de la matriz de género. El siguiente código muestra cómo: esto se traduce como “desinfectar todos los elementos debajo del con el key genre”.\n\n1\n2\n3\n4\n5\n[\n  // …\n  body(\"genre.*\").escape(),\n  // …\n];\n\n\nLa última diferencia con respecto al otro código de manejo de formularios es que necesitamos pasar todos los géneros y autores existentes al formulario. Para marcar los géneros que el usuario verificó, iteramos a través de todos los géneros y agregamos el parámetro checked='true' a los que estaban en nuestros datos del POST (como se reproduce en el fragmento de código a continuación).\n\n1\n2\n3\n4\n5\n6\n7\n// Mark our selected genres as checked.\nfor (const genre of results.genres) {\n  if (book.genre.includes(genre._id)) {\n    // Current genre is selected. Set \"checked\" flag.\n    genre.checked = \"true\";\n  }\n}\n\n\nVista\n\nCrea el archivo book_form.pug y pega el siguiente código:\n\nextends layout\n\nblock content\n  h1= title\n\n  form(method='POST' action='')\n    div.form-group\n      label(for='title') Title:\n      input#title.form-control(type='text', placeholder='Name of book' name='title' required='true' value=(undefined===book ? '' : book.title) )\n    div.form-group\n      label(for='author') Author:\n      select#author.form-control(type='select', placeholder='Select author' name='author' required='true' )\n        - authors.sort(function(a, b) {let textA = a.family_name.toUpperCase(); let textB = b.family_name.toUpperCase(); return (textA &lt; textB) ? -1 : (textA &gt; textB) ? 1 : 0;});\n        for author in authors\n          if book\n            option(value=author._id selected=(author._id.toString()===book.author._id.toString() ? 'selected' : false) ) #{author.name}\n          else\n            option(value=author._id) #{author.name}\n    div.form-group\n      label(for='summary') Summary:\n      textarea#summary.form-control(type='textarea', placeholder='Summary' name='summary' required='true') #{undefined===book ? '' : book.summary}\n    div.form-group\n      label(for='isbn') ISBN:\n      input#isbn.form-control(type='text', placeholder='ISBN13' name='isbn' value=(undefined===book ? '' : book.isbn) required='true')\n    div.form-group\n      label Genre:\n      div\n        for genre in genres\n          div(style='display: inline; padding-right:10px;')\n            input.checkbox-input(type='checkbox', name='genre', id=genre._id, value=genre._id, checked=genre.checked )\n            label(for=genre._id) #{genre.name}\n    button.btn.btn-primary(type='submit') Submit\n\n  if errors\n    ul\n      for error in errors\n        li!= error.msg\n\n\nLa estructura y el comportamiento de la vista son casi los mismos que para la plantilla gender_form.pug.\n\nLas principales diferencias están en cómo implementamos los campos de tipo selección: Author y Genre.\n\n\n  El conjunto de géneros se muestra como casillas de verificación, utilizando el valor marcado que configuramos en el controlador para determinar si la casilla debe seleccionarse o no.\n  El conjunto de autores se muestra como una lista desplegable ordenada alfabéticamente de una sola selección. Si el usuario ha seleccionado previamente un autor de libro (es decir, al corregir valores de campo no válidos después del envío del formulario inicial o al actualizar los detalles del libro), el autor se volverá a seleccionar cuando se muestre el formulario. Aquí determinamos qué autor seleccionar comparando la identificación de la opción de autor actual con el valor ingresado previamente por el usuario (pasado a través de la variable book).\n\n\n\n  -alert-Si hay un error en el formulario enviado, entonces, cuando se vuelva a procesar el formulario, la identificación del autor del nuevo libro y las identificaciones de los autores de los libros existentes son del tipo Schema.Types.ObjectId. Entonces, para compararlos, primero debemos convertirlos en cadenas.\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación, abre tu navegador en http://localhost:3000/, luego selecciona el enlace Create new book. Si todo está configurado correctamente, tu sitio debería parecerse a la siguiente captura de pantalla. Después de enviar un libro válido, debe guardarse y accederás a la página de detalles del libro.\n\n\n\nFormulario BookInstance\n\nEste subartículo muestra cómo definir una página/formulario para crear objetos BookInstance. Esto es muy parecido a la forma que usamos para crear objetos Libro.\n\nMétodos de validación y sanitización de importaciones\n\nAbre /controllers/bookinstanceController.js y agrega las siguientes líneas en la parte superior del archivo:\n\n1\nconst { body, validationResult } = require(\"express-validator\");\n\n\nControlador ruta GET\n\nEn la parte superior del archivo, importa el modelo Book (necesario porque cada BookInstance está asociado con un libro en particular).\n\n1\nconst Book = require(\"../models/book\");\n\n\nBusca el método de controlador exportado bookinstance_create_get() y reemplázalo con el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n// Display BookInstance create form on GET.\nexports.bookinstance_create_get = (req, res, next) =&gt; {\n  Book.find({}, \"title\").exec((err, books) =&gt; {\n    if (err) {\n      return next(err);\n    }\n    // Successful, so render.\n    res.render(\"bookinstance_form\", {\n      title: \"Create BookInstance\",\n      book_list: books,\n    });\n  });\n};\n\n\nEl controlador obtiene una lista de todos los libros (book_list) y la pasa a la vista bookinstance_form.pug (junto con el título)\n\nControlador ruta POST\n\n\n  -reto-Encuentra el método de controlador exportado bookinstance_create_post() y crea al código necesario para guardar una Instancia\n\n\nVista\n\nCrea /views/bookinstance_form.pug y copie el texto a continuación.\n\nextends layout\n\nblock content\n  h1=title\n\n  form(method='POST' action='')\n    div.form-group\n      label(for='book') Book:\n      select#book.form-control(type='select' placeholder='Select book' name='book' required='true')\n        - book_list.sort(function(a, b) {let textA = a.title.toUpperCase(); let textB = b.title.toUpperCase(); return (textA &lt; textB) ? -1 : (textA &gt; textB) ? 1 : 0;});\n        for book in book_list\n          option(value=book._id, selected=(selected_book==book._id.toString() ? 'selected' : false) ) #{book.title}\n\n    div.form-group\n      label(for='imprint') Imprint:\n      input#imprint.form-control(type='text' placeholder='Publisher and date information' name='imprint' required='true' value=(undefined===bookinstance ? '' : bookinstance.imprint))\n    div.form-group\n      label(for='due_back') Date when book available:\n      input#due_back.form-control(type='date' name='due_back' value=(undefined===bookinstance ? '' : bookinstance.due_back))\n\n    div.form-group\n      label(for='status') Status:\n      select#status.form-control(type='select' placeholder='Select status' name='status' required='true')\n        option(value='Maintenance') Maintenance\n        option(value='Available') Available\n        option(value='Loaned') Loaned\n        option(value='Reserved') Reserved\n\n    button.btn.btn-primary(type='submit') Submit\n\n  if errors\n    ul\n      for error in errors\n        li!= error.msg\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación y abre el navegador en http://localhost:3000/. A continuación, selecciona el enlace Create new instance (copy) Si todo está configurado correctamente, tu sitio debería parecerse a la siguiente captura de pantalla. Después de enviar una BookInstance válida, debe guardarse y accederás a la página de detalles.\n\n\n\nFormulario para borrar Author\n\nComo se discutió en la sección de diseño de formularios, nuestra estrategia será permitir solo la eliminación de objetos a los que no hacen referencia otros objetos (en este caso, eso significa que no permitiremos que se elimine un Autor si está referenciado por un Libro). En términos de implementación, esto significa que el formulario debe confirmar que no hay libros asociados antes de que se elimine el autor. Si hay libros asociados, debe mostrarlos e indicar que deben eliminarse antes de que se pueda eliminar el objeto Autor.\n\nControlador ruta GET\n\nAbre /controllers/authorController.js. Busca el método de controlador exportado author_delete_get() y reemplázalo con el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n// Display Author delete form on GET.\nexports.author_delete_get = (req, res, next) =&gt; {\n  async.parallel(\n    {\n      author(callback) {\n        Author.findById(req.params.id).exec(callback);\n      },\n      authors_books(callback) {\n        Book.find({ author: req.params.id }).exec(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      if (results.author == null) {\n        // No results.\n        res.redirect(\"/catalog/authors\");\n      }\n      // Successful, so render.\n      res.render(\"author_delete\", {\n        title: \"Delete Author\",\n        author: results.author,\n        author_books: results.authors_books,\n      });\n    }\n  );\n};\n\n\nEl controlador obtiene la identificación de la instancia de autor que se eliminará del parámetro de URL (req.params.id). Utiliza el método async.parallel() para obtener el registro del autor y todos los libros asociados en paralelo. Cuando se han completado ambas operaciones, presenta la vista author_delete.pug, pasando variables para el title, author y author_books.\n\n\n  -info-Si findById() no devuelve resultados, el autor no está en la base de datos. En este caso, no hay nada que eliminar, por lo que mostramos inmediatamente la lista de todos los autores.\n\n  1\n2\n3\n4\n5\n6\n7\n  (err, results) =&gt; {\n    if (err) {\n      return next(err);\n    }\n    if (results.author == null) { // No results.\n       res.redirect('/catalog/authors');\n    }\n  \n\n\nControlador ruta POST\n\nBusca el método de controlador exportado author_delete_post() y reemplázalo con el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n// Handle Author delete on POST.\nexports.author_delete_post = (req, res, next) =&gt; {\n  async.parallel(\n    {\n      author(callback) {\n        Author.findById(req.body.authorid).exec(callback);\n      },\n      authors_books(callback) {\n        Book.find({ author: req.body.authorid }).exec(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      // Success\n      if (results.authors_books.length &gt; 0) {\n        // Author has books. Render in same way as for GET route.\n        res.render(\"author_delete\", {\n          title: \"Delete Author\",\n          author: results.author,\n          author_books: results.authors_books,\n        });\n        return;\n      }\n      // Author has no books. Delete object and redirect to the list of authors.\n      Author.findByIdAndRemove(req.body.authorid, (err) =&gt; {\n        if (err) {\n          return next(err);\n        }\n        // Success - go to author list\n        res.redirect(\"/catalog/authors\");\n      });\n    }\n  );\n};\n\n\nPrimero validamos que se haya proporcionado una identificación (esto se envía a través de los parámetros del cuerpo del formulario, en lugar de usar la versión en la URL). Luego obtenemos el autor y sus libros asociados de la misma manera que para la ruta GET. Si no hay libros, eliminamos el objeto de autor y redirigimos a la lista de todos los autores. Si todavía hay libros, simplemente volvemos a presentar el formulario, pasando el autor y la lista de libros que se eliminarán.\n\nVista\n\nCrea /views/author_delete.pug y copia el texto a continuación.\n\nextends layout\n\nblock content\n  h1 #{title}: #{author.name}\n  p= author.lifespan\n\n  if author_books.length\n\n    p #[strong Delete the following books before attempting to delete this author.]\n\n    div(style='margin-left:20px;margin-top:20px')\n\n      h4 Books\n\n      dl\n      each book in author_books\n        dt\n          a(href=book.url) #{book.title}\n        dd #{book.summary}\n\n  else\n    p Do you really want to delete this Author?\n\n    form(method='POST' action='')\n      div.form-group\n        input#authorid.form-control(type='hidden',name='authorid', required='true', value=author._id )\n\n      button.btn.btn-primary(type='submit') Delete\n\n\nLa vista extiende la plantilla layout, anulando el bloque denominado content. En la parte superior muestra los detalles del autor. Luego incluye una declaración condicional basada en el número de author_books (las cláusulas if y else).\n\n\n  Si hay libros asociados con el autor, la página enumera los libros y establece que deben eliminarse antes de que se pueda eliminar este autor.\n  Si no hay libros, la página muestra un mensaje de confirmación.\n  Si se hace clic en el botón Delete, la identificación del autor se envía al servidor en una solicitud POST y se eliminará el registro de ese autor.\n\n\nControl para borrar autores\n\nA continuación, agregaremos un control Delete a la vista de detalles del autor (la página de detalles es un buen lugar para eliminar un registro).\n\nAbre la vista author_detail.pug y agrega las siguientes líneas en la parte inferior.\n\nhr\np\n  a(href=author.url+'/delete') Delete author\n\n\n",
        "url": "/node-express-library-teoria/trabajar-con-formularios"
      }
      ,
    
      "visualizacion-de-datos": {
        "title": "Tutorial Express - parte 5: Visualización de datos",
        "content": "Ahora estamos listos para agregar las páginas que muestran los libros del sitio web de LocalLibrary y otros datos. Las páginas incluirán una página de inicio que muestra cuántos registros tenemos de cada tipo de modelo y una lista y páginas de detalles para todos nuestros modelos. En el camino, obtendremos experiencia práctica en la obtención de registros de la base de datos y en el uso de plantillas.\n\nDescripción general\n\nEn nuestros artículos tutoriales anteriores, definimos modelos Mongoose que podemos usar para interactuar con una base de datos y creamos algunos registros de biblioteca iniciales. Luego creamos todas las rutas necesarias para el sitio web de LocalLibrary, pero con funciones de “controlador ficticio” (estas son funciones de controlador de esqueleto que simplemente devuelven un mensaje “no implementado” cuando se accede a una página).\n\nEl siguiente paso es proporcionar implementaciones adecuadas para las páginas que muestran la información de nuestra biblioteca (veremos cómo implementar páginas con formularios para crear, actualizar o eliminar información en artículos posteriores). Esto incluye actualizar las funciones del controlador para obtener registros utilizando nuestros modelos y definir plantillas para mostrar esta información a los usuarios.\n\nComenzaremos brindando información general/temas básicos que explican cómo administrar operaciones asincrónas en funciones de controlador y cómo escribir plantillas usando Pug. Luego, proporcionaremos implementaciones para cada una de nuestras páginas principales de “solo lectura” con una breve explicación de cualquier característica especial o nueva que utilicen.\n\nAl final de este artículo, debe tener una buena comprensión integral de cómo funcionan en la práctica las rutas, las funciones asincrónicas, las vistas y los modelos\n\nControl de flujo asíncrono usando async\n\nEl código del controlador para algunas de nuestras páginas de LocalLibrary dependerá de los resultados de varias solicitudes asíncronas, que pueden ser necesarias para ejecutarse en un orden particular o en paralelo. Para administrar el control de flujo y mostrar páginas cuando tengamos toda la información requerida disponible, usaremos el popular módulo async de node.\n\n\n  -info-Hay otras formas de administrar el comportamiento asíncrono y el control de flujo en JavaScript, incluidas funciones relativamente recientes del lenguaje JavaScript como Promises.\n\n\nAsync tiene muchos métodos útiles. Algunas de las funciones más importantes son:\n\n\n  async.parallel() para ejecutar cualquier operación que deba realizarse en paralelo.\n  async.series() para cuando necesitamos asegurarnos de que las operaciones asíncronas se realicen en serie.\n  async.waterfall() para operaciones que deben ejecutarse en serie, y cada operación depende de los resultados de las operaciones anteriores.\n\n\n¿Por qué es necesario?\n\nLa mayoría de los métodos que usamos en Express son asíncronos: especificas una operación para realizar, pasando una devolución de llamada. El método regresa inmediatamente y la devolución de llamada se invoca cuando se completa la operación solicitada. Por convención en Express, las funciones de devolución de llamada pasan un valor de error como primer parámetro (o nulo en caso de éxito) y los resultados de la función (si los hay) como segundo parámetro.\n\nSi un controlador solo necesita realizar una operación asíncrona para obtener la información requerida para representar una página, entonces la implementación es fácil: representamos la plantilla en la devolución de llamada. El siguiente fragmento de código muestra esto para una función que representa el conteo de un modelo SomeModel (usando el método Mongoose countDocuments):\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nexports.some_model_count = function (req, res, next) {\n  SomeModel.countDocuments(\n    { a_model_field: \"match_value\" },\n    function (err, count) {\n      // Do something if there is an err.\n      // …\n\n      // On success, render the result by passing count into the render function (here, as the variable 'data').\n      res.render(\"the_template\", { data: count });\n    }\n  );\n};\n\n\n¿Qué sucede si necesitas realizar varias consultas asíncronas y no puedes representar la página hasta que se hayan completado todas las operaciones? Una implementación ingenua podría “conectar en cadena” las solicitudes, iniciar solicitudes posteriores en la devolución de llamada de una solicitud anterior y presentar la respuesta en la devolución de llamada final. El problema con este enfoque es que nuestras solicitudes tendrían que ejecutarse en serie, aunque podría ser más eficiente ejecutarlas en paralelo. Esto también podría resultar en un código anidado complicado, comúnmente conocido como callback hell.\n\nUna solución mucho mejor sería ejecutar todas las solicitudes en paralelo y luego tener una única devolución de llamada que se ejecute cuando se hayan completado todas las consultas. ¡Este es el tipo de operación de flujo que el módulo Async facilita!\n\nOperaciones asíncronas en paralelo\n\nEl método async.parallel() se usa para ejecutar varias operaciones asíncronas en paralelo.\n\nEl primer argumento para async.parallel() es una colección de funciones asíncronas para ejecutar (una matriz, un objeto u otro iterable). A cada función se le pasa una devolución de llamada (err, result) que debe llamar al finalizar con un error err (que puede ser nulo) y un valor results opcional.\n\nEl segundo argumento opcional de async.parallel() es una devolución de llamada que se ejecutará cuando se hayan completado todas las funciones del primer argumento. La devolución de llamada se invoca con un argumento de error y una colección de resultados que contiene los resultados de las operaciones asíncronas individuales. La colección de resultados es del mismo tipo que el primer argumento (es decir, si pasa una matriz de funciones asíncronas, la devolución de llamada final se invocará con una matriz de resultados). Si alguna de las funciones paralelas informa un error, la devolución de llamada se invoca antes (con el valor de error).\n\nEl siguiente ejemplo muestra cómo funciona esto cuando pasamos un objeto como primer argumento. Como puedes ver, los resultados se devuelven en un objeto con los mismos nombres de propiedad que las funciones originales que se pasaron.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nasync.parallel(\n  {\n    one(callback) {\n      /* … */\n    },\n    two(callback) {\n      /* … */\n    },\n    // …\n    something_else(callback) {\n      /* … */\n    },\n  },\n  // optional callback\n  function (err, results) {\n    // 'results' is now equal to: {one: 1, two: 2, …, something_else: some_value}\n  }\n);\n\n\nSi, en cambio, pasas una matriz de funciones como primer argumento, los resultados serán una matriz (los resultados del orden de la matriz coincidirán con el orden original en que se declararon las funciones, no con el orden en que se completaron).\n\nOperaciones asíncronas en serie\n\nEl método async.series() se usa para ejecutar varias operaciones asíncronas en secuencia, cuando las funciones posteriores no dependen de la salida de funciones anteriores. Básicamente se declara y se comporta de la misma manera que async.parallel().\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nasync.series(\n  {\n    one(callback) {\n      // …\n    },\n    two(callback) {\n      // …\n    },\n    // …\n    something_else(callback) {\n      // …\n    },\n  },\n  // optional callback after the last asynchronous function completes.\n  function (err, results) {\n    // 'results' is now equal to: {one: 1, two: 2, /* …, */ something_else: some_value}\n  }\n);\n\n\n\n  -info-La especificación del lenguaje ECMAScript (JavaScript) establece que el orden de enumeración de un objeto no está definido, por lo que es posible que las funciones no se llamen en el mismo orden en que las especifica en todas las plataformas. Si el orden es realmente importante, debes pasar una matriz en lugar de un objeto, como se muestra a continuación.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nasync.series(\n  [\n    function (callback) {\n      // do some stuff …\n      callback(null, \"one\");\n    },\n    function (callback) {\n      // do some more stuff …\n      callback(null, \"two\");\n    },\n  ],\n  // optional callback\n  function (err, results) {\n    // results is now equal to ['one', 'two']\n  }\n);\n\n\nOperaciones asíncronas dependientes en serie\n\nEl método async.waterfall() se usa para ejecutar múltiples operaciones asíncronas en secuencia cuando cada operación depende del resultado de la operación anterior.\n\nLa devolución de llamada invocada por cada función asíncrona contiene un valor nulo para el primer argumento y da como resultado argumentos posteriores. Cada función de la serie toma los argumentos de resultados de la devolución de llamada anterior como los primeros parámetros y luego una función de devolución de llamada. Cuando se completan todas las operaciones, se invoca una devolución de llamada final con el resultado de la última operación. La forma en que esto funciona es más clara cuando considera el fragmento de código a continuación (este ejemplo es de la documentación de async):\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nasync.waterfall(\n  [\n    function (callback) {\n      callback(null, \"one\", \"two\");\n    },\n    function (arg1, arg2, callback) {\n      // arg1 now equals 'one' and arg2 now equals 'two'\n      callback(null, \"three\");\n    },\n    function (arg1, callback) {\n      // arg1 now equals 'three'\n      callback(null, \"done\");\n    },\n  ],\n  function (err, result) {\n    // result now equals 'done'\n  }\n);\n\n\nInstalación de async\n\nInstala el módulo asíncrono usando el administrador de paquetes npm para que podamos usarlo en nuestro código. Haz esto de la manera habitual, abriendo una consola en la raíz del proyecto LocalLibrary e introduciendo el siguiente comando:\n\n1\nnpm install async\n\n\nPlantillas\n\nUna plantilla es un archivo de texto que define la estructura o el diseño de un archivo de salida, con marcadores de posición que se utilizan para representar dónde se insertarán los datos cuando se represente la plantilla (en Express, las plantillas se denominan vistas).\n\nOpciones de plantilla Expressd\n\nExpress se puede utilizar con muchos motores de representación de plantillas diferentes. En este tutorial usamos Pug (anteriormente conocido como Jade) para nuestras plantillas. Este es el lenguaje de plantillas de Node más popular y se describe a sí mismo como una “sintaxis limpia y sensible a los espacios en blanco para escribir HTML, fuertemente influenciada por Haml”.\n\nDiferentes lenguajes de plantilla usan diferentes enfoques para definir el diseño y marcar marcadores de posición para los datos; algunos usan HTML para definir el diseño, mientras que otros usan diferentes formatos de marcado que se pueden transpilar a HTML. Pug es del segundo tipo; usa una representación de HTML donde la primera palabra en cualquier línea generalmente representa un elemento HTML, y la sangría en las líneas subsiguientes se usa para representar el anidamiento. El resultado es una definición de página que se traduce directamente a HTML, pero es más concisa y posiblemente más fácil de leer.\n\n\n  -info-La desventaja de usar Pug es que es sensible a la sangría y los espacios en blanco (si agregas un espacio adicional en el lugar equivocado, puede obtener un código de error inútil). Sin embargo, una vez que tengas las plantillas en su lugar, son muy fáciles de leer y mantener.\n\n\nConfiguración de plantillas\n\nLocalLibrary se configuró para usar Pug cuando creamos el sitio web esqueleto. Deberías ver el módulo pug incluido como una dependencia en el archivo package.json del sitio web y los siguientes ajustes de configuración en el archivo app.js. La configuración nos dice que estamos usando pug como motor de visualización y que Express debe buscar plantillas en el subdirectorio /views.\n\n1\n2\n3\n// View engine setup\napp.set(\"views\", path.join(__dirname, \"views\"));\napp.set(\"view engine\", \"pug\");\n\n\nSi buscas en el directorio de vistas, verás los archivos .pug para las vistas predeterminadas del proyecto. Estos incluyen la vista de la página de inicio (index.pug) y la plantilla base (layout.pug) que necesitaremos reemplazar con nuestro propio contenido.\n\n1\n2\n3\n4\n5\n/express-locallibrary-tutorial  //the project root\n  /views\n    error.pug\n    index.pug\n    layout.pug\n\n\nSintaxis de plantilla\n\nEl archivo de plantilla de ejemplo a continuación muestra muchas de las características más útiles de Pug.\n\nLo primero que debes notar es que el archivo mapea la estructura de un archivo HTML típico, con la primera palabra en (casi) cada línea siendo un elemento HTML, y la sangría se usa para indicar elementos anidados. Entonces, por ejemplo, el elemento del cuerpo está dentro de un elemento html y los elementos de párrafo (p) están dentro del elemento del cuerpo, etc. Los elementos no anidados (por ejemplo, párrafos individuales) están en líneas separadas.\n\ndoctype html\nhtml(lang=\"en\")\n  head\n    title= title\n    script(type='text/javascript').\n  body\n    h1= title\n\n    p This is a line with #[em some emphasis] and #[strong strong text] markup.\n    p This line has un-escaped data: !{'&lt;em&gt; is emphasized&lt;/em&gt;'} and escaped data: #{'&lt;em&gt; is not emphasized&lt;/em&gt;'}.\n      | This line follows on.\n    p= 'Evaluated and &lt;em&gt;escaped expression&lt;/em&gt;:' + title\n    &lt;!-- You can add HTML comments directly --&gt;\n    // You can add single line JavaScript comments and they are generated to HTML comments\n    p A line with a link\n      a(href='/catalog/authors') Some link text\n      |  and some extra text.\n\n    #container.col\n      if title\n        p A variable named \"title\" exists.\n      else\n        p A variable named \"title\" does not exist.\n      p.\n        Pug is a terse and simple template language with a\n        strong focus on performance and powerful features.\n\n    h2 Generate a list\n\n    ul\n      each val in [1, 2, 3, 4, 5]\n        li= val\n\n\nLos atributos de los elementos se definen entre paréntesis después de su elemento asociado. Dentro de los paréntesis, los atributos se definen en listas separadas por comas o espacios en blanco de los pares de nombres de atributos y valores de atributos, por ejemplo:\n\nscript(type='text/javascript'), link(rel='stylesheet', href='/stylesheets/style.css')\nmeta(name='viewport' content='width=device-width initial-scale=1')\n\n\nLos valores de todos los atributos se escapan (por ejemplo, los caracteres como &gt; se convierten en sus equivalentes de código HTML como &amp;gt;) para evitar la inyección de JavaScript o cross-site scripting attacks.\n\nSi una etiqueta va seguida del signo igual, el siguiente texto se trata como una expresión de JavaScript. Entonces, por ejemplo, en la primera línea a continuación, el contenido de la etiqueta h1 será un título variable (ya sea definido en el archivo o pasado a la plantilla desde Express). En la segunda línea, el contenido del párrafo es una cadena de texto concatenada con la variable de título. En ambos casos, el comportamiento predeterminado es escapar de la línea.\n\nh1= title\np= 'Evaluated and &lt;em&gt;escaped expression&lt;/em&gt;:' + title\n\n\nSi no hay un símbolo de igual después de la etiqueta, el contenido se trata como texto sin formato. Dentro del texto sin formato, puedes insertar datos con y sin escape usando la sintaxis #{} y !{} respectivamente, como se muestra a continuación. También puedes agregar HTML sin procesar dentro del texto sin formato.\n\np This is a line with #[em some emphasis] and #[strong strong text] markup.\np This line has an un-escaped string: !{'&lt;em&gt; is emphasized&lt;/em&gt;'}, an escaped string: #{'&lt;em&gt; is not emphasized&lt;/em&gt;'}, and escaped variables: #{title}.\n\n\n\n  -info-Casi siempre querrás escapar de los datos de los usuarios (a través de la sintaxis #{}). Los datos en los que se puede confiar (por ejemplo, recuentos de registros generados, etc.) se pueden mostrar sin escapar de los valores.\n\n\nPuedes utilizar el carácter de barra vertical (|) al principio de una línea para indicar “texto sin formato”. Por ejemplo, el texto adicional que se muestra a continuación se mostrará en la misma línea que el ancla anterior, pero no estará vinculado.\n\na(href='http://someurl/') Link text\n| Plain text\n\n\nPug te permite realizar operaciones condicionales usando if, else, else if y unless, por ejemplo:\n\nif title\n  p A variable named \"title\" exists\nelse\n  p A variable named \"title\" does not exist\n\n\nTambién puedes realizar operaciones de bucle/iteración utilizando la sintaxis each-in o while. En el fragmento de código a continuación, hemos recorrido una matriz para mostrar una lista de variables (ten en cuenta el uso de ‘li =’ para evaluar el “val” como una variable a continuación. El valor que itera también se puede pasar al plantilla como una variable!\n\nul\n  each val in [1, 2, 3, 4, 5]\n    li= val\n\n\nLa sintaxis también admite comentarios (que se pueden representar en la salida, o no, según elija), mixins para crear bloques de código reutilizables, declaraciones de casos y muchas otras características. Para obtener información más detallada, consulta los documentos de The Pug.\n\nExtender plantillas\n\nEn un sitio, es habitual que todas las páginas tengan una estructura común, incluido el marcado HTML estándar para el encabezado, el pie de página, la navegación, etc. En lugar de obligar a los desarrolladores a duplicar este “repetitivo” en cada página, Pug te permite declarar un plantilla base y luego se extiende, reemplazando solo lo que es diferente para cada página específica.\n\nPor ejemplo, la plantilla base layout.pug creada en nuestro proyecto de esqueleto se ve así:\n\ndoctype html\nhtml\n  head\n    title= title\n    link(rel='stylesheet', href='/stylesheets/style.css')\n  body\n    block content\n\n\nLa etiqueta block se usa para marcar secciones de contenido que se pueden reemplazar en una plantilla derivada (si el bloque no se redefine, se usa su implementación en la clase base).\n\nEl index.pug predeterminado (creado para nuestro proyecto de esqueleto) muestra cómo anulamos la plantilla base. La etiqueta extends identifica la plantilla base a usar y luego usamos el bloque section_name para indicar el nuevo contenido de la sección que anularemos.\n\nextends layout\n\nblock content\n  h1= title\n  p Welcome to #{title}\n\n\nLa plantilla base\n\nAhora que entendemos cómo extender plantillas usando Pug, comencemos creando una plantilla base para el proyecto. Tendrá una barra lateral con enlaces para las páginas que esperamos crear en los artículos del tutorial (por ejemplo, para mostrar y crear libros, géneros, autores, etc.) y un área de contenido principal que anularemos en cada una de nuestras páginas individuales.\n\nAbre /views/layout.pug y reemplace el contenido con el siguiente código.\n\ndoctype html\nhtml(lang='en')\n  head\n    title= title\n    meta(charset='utf-8')\n    meta(name='viewport', content='width=device-width, initial-scale=1')\n    link(rel=\"stylesheet\", href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\", integrity=\"sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z\", crossorigin=\"anonymous\")\n    script(src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\", integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\", crossorigin=\"anonymous\")\n    script(src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js\", integrity=\"sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV\", crossorigin=\"anonymous\")\n    link(rel='stylesheet', href='/stylesheets/style.css')\n  body\n    div(class='container-fluid')\n      div(class='row')\n        div(class='col-sm-2')\n          block sidebar\n            ul(class='sidebar-nav')\n              li\n                a(href='/catalog') Home\n              li\n                a(href='/catalog/books') All books\n              li\n                a(href='/catalog/authors') All authors\n              li\n                a(href='/catalog/genres') All genres\n              li\n                a(href='/catalog/bookinstances') All book-instances\n              li\n                hr\n              li\n                a(href='/catalog/author/create') Create new author\n              li\n                a(href='/catalog/genre/create') Create new genre\n              li\n                a(href='/catalog/book/create') Create new book\n              li\n                a(href='/catalog/bookinstance/create') Create new book instance (copy)\n\n        div(class='col-sm-10')\n          block content\n\n\nLa plantilla usa (e incluye) JavaScript y CSS de Bootstrap para mejorar el diseño y la presentación de la página HTML. El uso de Bootstrap u otro marco web del lado del cliente es una forma rápida de crear una página atractiva que puede escalar bien en diferentes tamaños de navegador, y también nos permite manejar la presentación de la página sin tener que entrar en detalles, simplemente quiero centrarme en el código del lado del servidor aquí!\n\nEl diseño debería ser bastante obvio si has leído nuestro manual de plantilla anterior. Ten en cuenta el uso de block content como marcador de posición para el lugar donde se colocará el contenido de nuestras páginas individuales.\n\nLa plantilla base también hace referencia a un archivo CSS local (style.css) que proporciona un poco de estilo adicional. Abre /public/stylesheets/style.css y reemplace su contenido con el siguiente código CSS:\n\n1\n2\n3\n4\n5\n.sidebar-nav {\n  margin-top: 20px;\n  padding: 0;\n  list-style: none;\n}\n\n\nAhora tenemos una plantilla base para crear páginas con una barra lateral. En las próximas secciones lo usaremos para definir las páginas individuales.\n\nPágina de inicio\n\nLa primera página que crearemos será la página de inicio del sitio web, a la que se puede acceder desde la raíz del sitio (‘/’) o del catálogo (catalog/). Esto mostrará un texto estático que describe el sitio, junto con “recuentos” calculados dinámicamente de diferentes tipos de registros en la base de datos.\n\nYa hemos creado una ruta para la página de inicio. Para completar la página, necesitamos actualizar nuestra función de controlador para obtener “recuentos” de registros de la base de datos y crear una vista (plantilla) que podamos usar para representar la página.\n\nRuta\n\nCreamos nuestras rutas de página de índice en un tutorial anterior. Como recordatorio, todas las funciones de ruta están definidas en /routes/catalog.js:\n\n1\n2\n// GET catalog home page.\nrouter.get(\"/\", book_controller.index); //This actually maps to /catalog/ because we import the route with a /catalog prefix\n\n\nDonde el parámetro de la función de devolución de llamada (book_controller.index) se define en /controllers/bookController.js:\n\nEs esta función de controlador la que ampliamos para obtener información de nuestros modelos y luego representarla usando una plantilla (vista).\n\nControlador\n\nLa función de controlador de índice necesita obtener información sobre cuántos registros Book, BookInstance, BookInstance disponibles, Author y Genre tenemos en la base de datos, representar estos datos en una plantilla para crear una página HTML y luego devolverlos en una respuesta HTTP.\n\n\n  -info-Usamos el método countDocuments() para obtener el número de instancias de cada modelo. Esto se llama en un modelo, con un conjunto opcional de condiciones para comparar en el primer argumento y una devolución de llamada en el segundo argumento (como se explica en Uso de una base de datos (con Mongoose), y también puede devolver una Query y luego ejecutar con una devolución de llamada más tarde). La devolución de llamada se invocará cuando la base de datos devuelva el recuento, con un valor de error como primer parámetro (o nulo) y el recuento de documentos como segundo parámetro (o nulo si hubo un error).\n\n  1\n2\n3\n4\nSomeModel.countDocuments({ a_model_field: \"match_value\" }, (err, count) =&gt; {\n  // Do something if there is an err\n  // Do something with the count if there was no error\n});\n  \n\n\nAbre /controllers/bookController.js. Cerca de la parte superior del archivo, deberías ver la función index() exportada.\n\n1\n2\n3\n4\n5\nconst Book = require(\"../models/book\");\n\nexports.index = (req, res, next) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Site Home Page\");\n};\n\n\nReemplaza todo el código anterior con el siguiente fragmento de código. Lo primero que hace es importar (require()) todos los modelos. Necesitamos hacer esto porque los usaremos para obtener nuestros conteos de documentos. Luego importa el módulo async (que discutimos anteriormente en Control de flujo asíncrono usando async).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nconst Book = require(\"../models/book\");\nconst Author = require(\"../models/author\");\nconst Genre = require(\"../models/genre\");\nconst BookInstance = require(\"../models/bookinstance\");\n\nconst async = require(\"async\");\n\nexports.index = (req, res) =&gt; {\n  async.parallel(\n    {\n      book_count(callback) {\n        Book.countDocuments({}, callback); // Pass an empty object as match condition to find all documents of this collection\n      },\n      book_instance_count(callback) {\n        BookInstance.countDocuments({}, callback);\n      },\n      book_instance_available_count(callback) {\n        BookInstance.countDocuments({ status: \"Available\" }, callback);\n      },\n      author_count(callback) {\n        Author.countDocuments({}, callback);\n      },\n      genre_count(callback) {\n        Genre.countDocuments({}, callback);\n      },\n    },\n    (err, results) =&gt; {\n      res.render(\"index\", {\n        title: \"Local Library Home\",\n        error: err,\n        data: results,\n      });\n    }\n  );\n};\n\n\nAl método async.parallel() se le pasa un objeto con funciones para obtener los recuentos de cada uno de nuestros modelos. Todas estas funciones se inician al mismo tiempo. Cuando todos han completado, se invoca la devolución de llamada final con los recuentos en el parámetro de resultados (o un error).\n\nEn caso de éxito, la función de devolución de llamada llama a res.render(), especificando una vista (plantilla) llamada index y un objeto que contiene los datos que se insertarán en él (esto incluye el objeto de resultados que contiene nuestro modelo). Los datos se proporcionan como pares clave-valor y se puede acceder a ellos en la plantilla mediante la clave.\n\nView\n\nAbre /views/index.pug y reemplaza su contenido con el texto a continuación.\n\nextends layout\n\nblock content\n  h1= title\n  p Welcome to #[em LocalLibrary], a very basic Express website developed as a tutorial example on the Mozilla Developer Network.\n\n  h1 Dynamic content\n\n  if error\n    p Error getting dynamic content.\n  else\n    p The library has the following record counts:\n\n    ul\n      li #[strong Books:] !{data.book_count}\n      li #[strong Copies:] !{data.book_instance_count}\n      li #[strong Copies available:] !{data.book_instance_available_count}\n      li #[strong Authors:] !{data.author_count}\n      li #[strong Genres:] !{data.genre_count}\n\n\nLa vista es sencilla. Extendemos la plantilla base de layout.pug, anulando el bloque llamado content. El primer encabezado h1 será el texto escapado para la variable de título que se pasó a la función render(); ten en cuenta el uso de h1= para que el siguiente texto se trate como una expresión de JavaScript. Luego incluimos un párrafo que presenta LocalLibrary.\n\nBajo el encabezado Dynamic content, verificamos si la variable de error que se pasó desde la función render() se ha definido. Si es así, anotamos el error. Si no, obtenemos y enumeramos el número de copias de cada modelo de la variable de datos.\n\n\n  -info-No escapamos de los valores de conteo (es decir, usamos la sintaxis !{}) porque los valores de conteo se calculan. Si la información fue proporcionada por los usuarios finales, escaparíamos de la variable para mostrarla.\n\n\nCómo se ve?\n\nEn este punto, deberíamos haber creado todo lo necesario para mostrar la página de índice. Ejecute la aplicación y abra su navegador en http://localhost:3000/. Si todo está configurado correctamente, su sitio debería parecerse a la siguiente captura de pantalla.\n\n\n\nPágina de lista de libros\n\nA continuación, implementaremos nuestra página de lista de libros. Esta página debe mostrar una lista de todos los libros en la base de datos junto con su autor, y cada título de libro es un hipervínculo a su página de detalles de libro asociada.\n\nControlador\n\nLa función del controlador de la lista de libros necesita obtener una lista de todos los objetos Book en la base de datos, ordenarlos y luego pasarlos a la plantilla para su representación.\n\nAbre /controllers/bookController.js. Busca el método del controlador book_list() exportado y reemplázalo con el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n// Display list of all Books.\nexports.book_list = function (req, res, next) {\n  Book.find({}, \"title author\")\n    .sort({ title: 1 })\n    .populate(\"author\")\n    .exec(function (err, list_books) {\n      if (err) {\n        return next(err);\n      }\n      //Successful, so render\n      res.render(\"book_list\", { title: \"Book List\", book_list: list_books });\n    });\n};\n\n\nEl método usa la función find() del modelo para devolver todos los objetos Book, seleccionando devolver solo el title y el author ya que no necesitamos los otros campos (también devolverá el _id y los campos virtuales), y luego ordena los resultados por title alfabéticamente usando el método sort(). Aquí también llamamos populate() en Book, especificando el campo de author; esto reemplazará la identificación del autor del libro almacenado con los detalles completos del autor.\n\nEn caso de éxito, la devolución de llamada pasada a la consulta representa la plantilla book_list (.pug), pasando el título y book_list (lista de libros con autores) como variables.\n\nVista\n\nCrea /views/book_list.pug y copie el texto a continuación.\n\nextends layout\n\nblock content\n  h1= title\n\n  ul\n    each book in book_list\n      li\n        a(href=book.url) #{book.title}\n        |  (#{book.author.name})\n\n    else\n      li There are no books.\n\n\nLa vista extiende la plantilla base de layout.pug y anula el bloque llamado contect. Muestra el título que le pasamos desde el controlador (a través del método render()) e itera a través de la variable book_list usando la sintaxis each-in-else. Se crea un elemento de lista para cada libro que muestra el título del libro como un enlace a la página de detalles del libro seguido del nombre del autor. Si no hay libros en book_list, se ejecuta la cláusula else y se muestra el texto ‘There are no books’.\n\n\n  -info-Usamos book.url para proporcionar el enlace al registro detallado de cada libro (hemos implementado esta ruta, pero aún no la página). Esta es una propiedad virtual del modelo Book que utiliza el campo _id de la instancia del modelo para producir una ruta URL única.\n\n\nDe interés aquí es que cada libro se define como dos líneas, utilizando la tubería para la segunda línea. Este enfoque es necesario porque si el nombre del autor estuviera en la línea anterior, sería parte del hipervínculo.\n\n\n\nPágina de instancias de libros\n\n\n  -reto-Crea el controlador que muestre todas las instancias de libros. La plantilla es la siguiente:\n\n  extends layout\n\nblock content\n  h1= title\n\n  ul\n    each val in bookinstance_list\n      li\n        a(href=val.url) #{val.book.title} : #{val.imprint} -\n        if val.status=='Available'\n          span.text-success #{val.status}\n        else if val.status=='Maintenance'\n          span.text-danger #{val.status}\n        else\n          span.text-warning #{val.status}\n        if val.status!='Available'\n          span  (Due: #{val.due_back} )\n\n    else\n      li There are no book copies in this library.\n\n\n\n\n\n\nFormateo de fechas usando luxon\n\nEl renderizado de las fechas es bastante feo:\n\n1\n(Due: Sun Jan 22 2023 19:11:04 GMT+0100 (hora estándar de Europa central) )\n\n\nVamos a usar la librería luxon\n\nPara instalarla, usamos npm\n\n1\nnpm install luxon\n\n\nCrear una propiedad virtual\n\n\n  \n    Abre modles/bookinstance.js\n  \n  \n    Al principio de la página, importa luxon\n\n    1\nconst { DateTime } = require(\"luxon\");\n    \n  \n  \n    Añade la propiedad virtual due_back_formatted al modelo después de la propiedad URL\n\n    1\n2\n3\nBookInstanceSchema.virtual(\"due_back_formatted\").get(function () {\n  return    DateTime.fromJSDate(this.due_back).toLocaleString(DateTime.DATE_MED);\n});\n    \n  \n\n\nActualizar la vista\n\nModifica la vista para que ahora renderice esta propiedad virtual.\n\n1\n2\n3\n4\n      if val.status != 'Available'\n        //span  (Due: #{val.due_back} )\n        span  (Due: #{val.due_back_formatted} )\n\n\n\nPágina de libros\n\n\n  -reto-Crea la página para listar los libros. Modifica las fechas de nacimiento y defunción al igual que hicimos en bookinstance\n\n\n\n\nPágina de géneros\n\n\n  -reto-Crea la página para listar los géneros\n\n\n\n\nPágina detalle de género\n\nLa página de detalles del género debe mostrar la información de una instancia de género en particular, utilizando su valor de campo _id generado automáticamente como identificador. La página debe mostrar el nombre del género y una lista de todos los libros del género con enlaces a la página de detalles de cada libro.\n\nControlador\n\nAbre /controllers/genreController.js e importa los módulos async y Book en la parte superior del archivo.\n\n1\n2\nconst Book = require(\"../models/book\");\nconst async = require(\"async\");\n\n\nEncuentra el método genre_detail() y sustitúyelo por el siguiente código:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n// Display detail page for a specific Genre.\nexports.genre_detail = (req, res, next) =&gt; {\n  async.parallel(\n    {\n      genre(callback) {\n        Genre.findById(req.params.id).exec(callback);\n      },\n\n      genre_books(callback) {\n        Book.find({ genre: req.params.id }).exec(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      if (results.genre == null) {\n        // No results.\n        const err = new Error(\"Genre not found\");\n        err.status = 404;\n        return next(err);\n      }\n      // Successful, so render\n      res.render(\"genre_detail\", {\n        title: \"Genre Detail\",\n        genre: results.genre,\n        genre_books: results.genre_books,\n      });\n    }\n  );\n};\n\n\nEl método usa async.parallel() para consultar el nombre del género y sus libros asociados en paralelo, y la devolución de llamada muestra la página cuando (if) ambas solicitudes se completan correctamente.\n\nEl ID del registro de género requerido se codifica al final de la URL y se extrae automáticamente según la definición de la ruta (/genre/:id). Se accede a la ID dentro del controlador a través de los parámetros de solicitud: req.params.id. Se usa en Genre.findById() para obtener el género actual. También se utiliza para obtener todos los objetos Book que tienen el ID de género en su campo de género: Book.find({ 'genre': req.params.id }).\n\n\n  -info-Si el género no existe en la base de datos (es decir, es posible que se haya eliminado), findById() volverá correctamente sin resultados. En este caso, queremos mostrar una página “no encontrada”, por lo que creamos un objeto de error y lo pasamos a la siguiente función de middleware en la cadena.\n\n  1\n2\n3\n4\n5\n6\nif (results.genre == null) {\n  // No results.\n  const err = new Error(\"Genre not found\");\n  err.status = 404;\n  return next(err);\n}\n  \n\n  Luego, el mensaje se propagará a través de nuestro código de manejo de errores (esto se configuró cuando generamos el esqueleto de la aplicación; para obtener más información, consulta Manejo de errores).\n\n\nLa vista renderizada es gender_detail y se le pasan variables para el título, el género y la lista de libros de este género (genre_books).\n\nVista\n\nCrea views/genre_detail.pug y pega el siguiente código:\n\nextends layout\n\nblock content\n\n  h1 Genre: #{genre.name}\n\n  div(style='margin-left:20px;margin-top:20px')\n\n    h4 Books\n\n    dl\n      each book in genre_books\n        dt\n          a(href=book.url) #{book.title}\n        dd #{book.summary}\n\n      else\n        p This genre has no books\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación y abre el  navegador en http://localhost:3000/. Seleccione el enlace All genres, luego selecciona uno de los géneros (por ejemplo, “Fantasy”). Si todo está configurado correctamente, la página debería verse como la siguiente captura de pantalla.\n\n\n\nPágina detalle del libro\n\nLa página de detalles del libro debe mostrar la información de un libro específico (identificado mediante su valor de campo _id generado automáticamente), junto con información sobre cada copia asociada en la biblioteca (BookInstance). Dondequiera que mostremos un autor, género o instancia de libro, estos deben estar vinculados a la página de detalles asociada a ese elemento.\n\nControlador\n\nAbre /controllers/bookController.js. Busca el método de controlador exportado book_detail() y reemplácelo con el siguiente código.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n// Display detail page for a specific book.\nexports.book_detail = (req, res, next) =&gt; {\n  async.parallel(\n    {\n      book(callback) {\n        Book.findById(req.params.id)\n          .populate(\"author\")\n          .populate(\"genre\")\n          .exec(callback);\n      },\n      book_instance(callback) {\n        BookInstance.find({ book: req.params.id }).exec(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        return next(err);\n      }\n      if (results.book == null) {\n        // No results.\n        const err = new Error(\"Book not found\");\n        err.status = 404;\n        return next(err);\n      }\n      // Successful, so render.\n      res.render(\"book_detail\", {\n        title: results.book.title,\n        book: results.book,\n        book_instances: results.book_instance,\n      });\n    }\n  );\n};\n\n\nVista\n\nCrea /views/book_detail.pug y pega el siguiente código:\n\nextends layout\n\nblock content\n  h1 Title: #{book.title}\n\n  p #[strong Author:]\n    a(href=book.author.url) #{book.author.name}\n  p #[strong Summary:] #{book.summary}\n  p #[strong ISBN:] #{book.isbn}\n  p #[strong Genre:]\n    each val, index in book.genre\n      a(href=val.url) #{val.name}\n      if index &lt; book.genre.length - 1\n        |,\n\n  div(style='margin-left:20px;margin-top:20px')\n    h4 Copies\n\n    each val in book_instances\n      hr\n      if val.status=='Available'\n        p.text-success #{val.status}\n      else if val.status=='Maintenance'\n        p.text-danger #{val.status}\n      else\n        p.text-warning #{val.status}\n      p #[strong Imprint:] #{val.imprint}\n      if val.status!='Available'\n        p #[strong Due back:] #{val.due_back}\n      p #[strong Id:]\n        a(href=val.url) #{val._id}\n\n    else\n      p There are no copies of this book in the library.\n\n\n\n  -info-La lista de géneros asociados con el libro se implementa en la plantilla como se muestra a continuación. Esto agrega una coma después de cada género asociado con el libro excepto el último.\n\n    p #[strong Genre:]\n    each val, index in book.genre\n      a(href=val.url) #{val.name}\n      if index &lt; book.genre.length - 1\n        |,\n\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación y abre el navegador en http://localhost:3000/. Selecciona el enlace  All books, luego selecciona uno de los libros. Si todo está configurado correctamente, su página debería verse como la siguiente captura de pantalla.\n\n\n\nPágina detalle de autor\n\nLa página de detalles del autor debe mostrar la información sobre el autor especificado, identificado mediante su valor de campo _id (generado automáticamente), junto con una lista de todos los objetos Book asociados con ese autor.\n\nControlador\n\nAbre controllers/authorControler.js y pega lo siguiente al principio:\n\n1\n2\nconst async = require(\"async\");\nconst Book = require(\"../models/book\");\n\n\nEncuentra el método author_detail y sustitúyelo por el siguiente código:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n// Display detail page for a specific Author.\nexports.author_detail = (req, res, next) =&gt; {\n  async.parallel(\n    {\n      author(callback) {\n        Author.findById(req.params.id).exec(callback);\n      },\n      authors_books(callback) {\n        Book.find({ author: req.params.id }, \"title summary\").exec(callback);\n      },\n    },\n    (err, results) =&gt; {\n      if (err) {\n        // Error in API usage.\n        return next(err);\n      }\n      if (results.author == null) {\n        // No results.\n        const err = new Error(\"Author not found\");\n        err.status = 404;\n        return next(err);\n      }\n      // Successful, so render.\n      res.render(\"author_detail\", {\n        title: \"Author Detail\",\n        author: results.author,\n        author_books: results.authors_books,\n      });\n    }\n  );\n};\n\n\nEl método usa async.parallel() para consultar al autor y sus instancias de libro asociadas en paralelo, y la devolución de llamada muestra la página cuando (if) ambas solicitudes se completan correctamente. El enfoque es exactamente el mismo que se describe en la página de detalles del género anterior.\n\nVista\n\nCrea views/authorDetail.pug y pega el siguiente código:\n\nextends layout\n\nblock content\n\n  h1 Author: #{author.name}\n  p #{author.date_of_birth} - #{author.date_of_death}\n\n  div(style='margin-left:20px;margin-top:20px')\n\n    h4 Books\n\n    dl\n      each book in author_books\n        dt\n          a(href=book.url) #{book.title}\n        dd #{book.summary}\n\n      else\n        p This author has no books.\n\n\n¿Cómo se ve?\n\nEjecuta la aplicación y abre el navegador en http://localhost:3000/. Selecciona el enlace  All authors, luego selecciona uno de los autores. Si todo está configurado correctamente, la página debería verse como la siguiente captura de pantalla.\n\n\n\n",
        "url": "/node-express-library-teoria/visualizacion-de-datos"
      }
      ,
    
      "rutas-y-controladores": {
        "title": "Tutorial Express - parte 4: Rutas y controladores",
        "content": "En este tutorial, configuraremos rutas (código de manejo de URL) con funciones de controlador “ficticias” para todos los puntos finales de recursos que eventualmente necesitaremos en el sitio web de LocalLibrary. Al finalizar, tendremos una estructura modular para nuestro código de manejo de rutas, que podemos ampliar con funciones de controlador reales en los siguientes artículos. ¡También comprenderemos muy bien cómo crear rutas modulares usando Express!\n\nDescripción general\n\nEn el último artículo del tutorial, definimos modelos Mongoose para interactuar con la base de datos y usamos un script (independiente) para crear algunos registros de biblioteca iniciales. Ahora podemos escribir el código para presentar esa información a los usuarios. Lo primero que debemos hacer es determinar qué información queremos poder mostrar en nuestras páginas y luego definir las URL apropiadas para devolver esos recursos. Luego, necesitaremos crear las rutas (controladores de URL) y las vistas (plantillas) para mostrar esas páginas.\n\nEl siguiente diagrama se proporciona como un recordatorio del flujo principal de datos y las cosas que deben implementarse al manejar una solicitud/respuesta HTTP. Además de las vistas y las rutas, el diagrama muestra “controladores”, funciones que separan el código para enrutar las solicitudes del código que realmente procesa las solicitudes.\n\nComo ya hemos creado los modelos, las cosas principales que necesitaremos crear son:\n\n\n  “Rutas” para reenviar las solicitudes admitidas (y cualquier información codificada en las URL de solicitud) a las funciones de controlador correspondientes.\n  El controlador funciona para obtener los datos solicitados de los modelos, crea una página HTML que muestra los datos y se los devuelve al usuario para que los vea en el navegador.\n  Vistas (plantillas) utilizadas por los controladores para representar los datos.\n\n\n\n\nEn última instancia, podríamos tener páginas para mostrar listas e información detallada de libros, géneros, autores e instancias de libros, junto con páginas para crear, actualizar y eliminar registros. Eso es mucho para documentar en un artículo. Por lo tanto, la mayor parte de este artículo se concentrará en configurar nuestras rutas y controladores para devolver contenido “ficticio”. Ampliaremos los métodos del controlador en nuestros artículos posteriores para trabajar con datos del modelo.\n\nLa primera sección a continuación proporciona una breve “instrucción” sobre cómo usar el middleware Express Router. Luego usaremos ese conocimiento en las siguientes secciones cuando configuremos las rutas de LocalLibrary.\n\nIntroducción a las rutas\n\nUna ruta es una sección de código Express que asocia un verbo HTTP (GET, POST, PUT, DELETE, etc.), una ruta/patrón de URL y una función que se llama para manejar ese patrón.\n\nHay varias formas de crear rutas. Para este tutorial, vamos a utilizar el middleware express.Router, ya que nos permite agrupar los controladores de ruta para una parte particular de un sitio y acceder a ellos usando un prefijo de ruta común. Mantendremos todas nuestras rutas relacionadas con la biblioteca en un módulo de “catálogo” y, si agregamos rutas para manejar cuentas de usuario u otras funciones, podemos mantenerlas agrupadas por separado.\n\nDefinición y uso de módulos de ruta separados\n\nEl siguiente código proporciona un ejemplo concreto de cómo podemos crear un módulo de ruta y luego usarlo en una aplicación Express.\n\nPrimero creamos rutas para una wiki en un módulo llamado wiki.js. El código primero importa el objeto de la aplicación Express, lo usa para obtener un objeto de enrutador y luego le agrega un par de rutas usando el método get(). Por último, el módulo exporta el objeto Router.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// wiki.js - Wiki route module.\n\nconst express = require(\"express\");\nconst router = express.Router();\n\n// Home page route.\nrouter.get(\"/\", function (req, res) {\n  res.send(\"Wiki home page\");\n});\n\n// About page route.\nrouter.get(\"/about\", function (req, res) {\n  res.send(\"About this wiki\");\n});\n\nmodule.exports = router;\n\n\n\n  -info-Arriba, estamos definiendo las devoluciones de llamada de nuestro controlador de ruta directamente en las funciones del enrutador. En LocalLibrary, definiremos estas devoluciones de llamada en un módulo de controlador separado.\n\n\nPara usar el módulo de enrutador en nuestro archivo de aplicación principal, primero hacemos require() el módulo de ruta (wiki.js). Luego llamamos a use() en la aplicación Express para agregar el enrutador a la ruta de manejo del middleware, especificando una ruta URL de ‘wiki’.\n\n1\n2\n3\nconst wiki = require(\"./wiki.js\");\n// …\napp.use(\"/wiki\", wiki);\n\n\nLas dos rutas definidas en nuestro módulo de ruta wiki son accesibles desde /wiki/ y /wiki/about/.\n\nFunciones del router\n\nNuestro módulo anterior define un par de funciones de ruta típicas. La ruta “acerca de” (reproducida a continuación) se define mediante el método Router.get(), que responde solo a las solicitudes HTTP GET. El primer argumento de este método es la ruta de la URL, mientras que el segundo es una función de devolución de llamada que se invocará si se recibe una solicitud HTTP GET con la ruta.\n\n1\n2\n3\nrouter.get(\"/about\", function (req, res) {\n  res.send(\"About this wiki\");\n});\n\n\nLa devolución de llamada toma tres argumentos (generalmente denominados como se muestra: req, res, next), que contendrán el objeto de solicitud HTTP, la respuesta HTTP y la siguiente función en la cadena de middleware.\n\n\n  -info-Las funciones del enrutador son middleware Express, lo que significa que deben completar (responder) la solicitud o llamar a la siguiente función en la cadena. En el caso anterior, completamos la solicitud usando send(), por lo que no se usa el siguiente argumento (y elegimos no especificarlo).\n\n\nLa función de enrutador anterior toma una sola devolución de llamada, pero puede especificar tantos argumentos de devolución de llamada como desee, o una matriz de funciones de devolución de llamada. Cada función es parte de la cadena de middleware y se llamará en el orden en que se agrega a la cadena (a menos que una función anterior complete la solicitud).\n\nLa función de devolución de llamada aquí llama a send() en la respuesta para devolver la cadena “Acerca de este wiki” cuando recibimos una solicitud GET con la ruta (‘/acerca de’). Hay una serie de otros métodos de respuesta para finalizar el ciclo de solicitud/respuesta. Por ejemplo, podría llamar a res.json() para enviar una respuesta JSON o res.sendFile() para enviar un archivo. El método de respuesta que usaremos con más frecuencia a medida que construimos la biblioteca es render(), que crea y devuelve archivos HTML usando plantillas y datos. ¡Hablaremos mucho más sobre eso en un artículo posterior!\n\nVerbos HTTP\n\nEl ejemplo anterior hace uso de Router.get() para responder a peticiones con el método GET\n\nTambién se pueden usar los siguientes métodos: post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), proppatch(), unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), subscribe(), unsubscribe(), patch(), search(), y connect().\n\nPor ejemplo, el siguiente código se comporta como la ruta /about anterior, pero solo responde a las solicitudes HTTP POST.\n\n1\n2\n3\nrouter.post(\"/about\", (req, res) =&gt; {\n  res.send(\"About this wiki\");\n});\n\n\nPaths en las rutas\n\nLos paths de ruta definen los puntos finales en los que se pueden realizar solicitudes. Los ejemplos que hemos visto hasta ahora son solo cadenas y se usan exactamente como están escritos: ‘/’, ‘/about’, ‘/book’, ‘/any-random.path’.\n\nLos paths de ruta también pueden ser patrones de cadenas. Los patrones de cadena utilizan una forma de sintaxis de expresión regular para definir patrones de puntos finales que coincidirán. La sintaxis se enumera a continuación (ten en cuenta que el guión (-) y el punto (.) se interpretan literalmente mediante rutas basadas en cadenas):\n\n\n  ? : El endpoint debe tener 0 o 1 del carácter anterior (o grupo). Un path de ruta de '/ab?cd' coincidirá con los endpoint acd o abcd.\n  + : El endpoint debe tener 1 o más del carácter anterior (o grupo). Un path de ruta de '/ab+cd' coincidirá con los endpoints abcd, abbcd, abbbcd, etc.\n  *: el punto final puede tener una cadena arbitraria donde se coloca el carácter. Un path de ruta '/ab*cd' coincidirá con los endpoints abcd, abXcd, abSOMErandomTEXTcd, etc.\n  () : Coincidencia de agrupación en un conjunto de caracteres para realizar otra operación. '/ab(cd)?e' realizará una coincidencia ? en el grupo (cd) — coincidirá con abe y abcde.\n\n\nLos paths de ruta también pueden ser expresiones regulares de JavaScript. Por ejemplo, el siguiente path de ruta coincidirá con catfish y dogfish, pero no con catflap, catfishhead, etc. Ten en cuenta que la ruta de una expresión regular utiliza la sintaxis de expresiones regulares (no es una cadena entre comillas como en los casos anteriores).\n\n1\n2\n3\napp.get(/.*fish$/, function (req, res) {\n  // …\n});\n\n\nParámetros en las rutas\n\nLos parámetros de ruta son segmentos de URL con nombre que se utilizan para capturar valores en posiciones específicas de la URL. Los segmentos nombrados tienen el prefijo de dos puntos y luego el nombre (por ejemplo, /:your_parameter_name/). Los valores capturados se almacenan en el objeto req.params usando los nombres de los parámetros como claves (por ejemplo, req.params.your_parameter_name).\n\nEntonces, por ejemplo, considere una URL codificada para contener información sobre usuarios y libros: http://localhost:3000/users/34/books/8989. Podemos extraer esta información como se muestra a continuación, con los parámetros de ruta userId y bookId:\n\n1\n2\n3\n4\n5\napp.get(\"/users/:userId/books/:bookId\", (req, res) =&gt; {\n  // Access userId via: req.params.userId\n  // Access bookId via: req.params.bookId\n  res.send(req.params);\n});\n\n\nLos nombres de los parámetros de ruta deben estar formados por “caracteres de palabra” (A-Z, a-z, 0-9 y _).\n\n\n  -info-La URL /book/create coincidirá con una ruta como /book/:bookId (que extraerá un valor “bookid” de ‘create’). Se utilizará la primera ruta que coincida con una URL entrante, por lo que si deseas procesar /book/create URL por separado, su controlador de ruta debes definirse antes de tu ruta /book/:bookId.\n\n\nEso es todo lo que necesitas para comenzar con las rutas; si es necesario, puedes encontrar más información en los documentos Express: Enrutamiento básico y Guía de enrutamiento. Las siguientes secciones muestran cómo configuraremos nuestras rutas y controladores para LocalLibrary.Los nombres de los parámetros de ruta deben estar formados por “caracteres de palabra” (A-Z, a-z, 0-9 y _).\n\nRutas necesarias para LocalLibrary\n\nLas URL que finalmente necesitaremos para nuestras páginas se enumeran a continuación, donde objeto se reemplaza por el nombre de cada uno de nuestros modelos (book, bookinstance, genre, author), objects es el plural de object e id es el campo de instancia único (_id) que se otorga a cada instancia del modelo Mongoose de forma predeterminada.\n\n\n  catalog/ — La página de inicio/índice.\n  catalog/&lt;objects&gt;/ — La lista de todos los libros, instancias de libros, géneros o autores (por ejemplo, /catalog/books/, /catalog/genres/, etc.)\n  catalog/&lt;object&gt;/&lt;id&gt; — La página de detalles para un libro específico, instancia de libro, género o autor con el valor de campo _id dado (por ejemplo, /catalog/book/584493c1f4887f06c0e67d37).\n  catalog/&lt;object&gt;/create — El formulario para crear un nuevo libro, instancia de libro, género o autor (por ejemplo, /catalog/book/create).\n  catalog/&lt;object&gt;/&lt;id&gt;/update — El formulario para actualizar un libro específico, instancia de libro, género o autor con el valor de campo _id dado (por ejemplo, /catalog/book/584493c1f4887f06c0e67d37/update).\n  catalog/&lt;object&gt;/&lt;id&gt;/delete: el formulario para eliminar un libro específico, una instancia de libro, un género o un autor con el valor de campo _id dado (por ejemplo, /catalog/book/584493c1f4887f06c0e67d37/delete).\n\n\nLa primera página de inicio y las páginas de lista no codifican ninguna información adicional. Si bien los resultados devueltos dependerán del tipo de modelo y el contenido de la base de datos, las consultas que se ejecutan para obtener la información siempre serán las mismas (de manera similar, el código que se ejecuta para la creación de objetos siempre será similar).\n\nPor el contrario, las otras URL se utilizan para actuar en una instancia específica de documento/modelo; estas codifican la identidad del elemento en la URL (que se muestra como &lt;id&gt; arriba). Usaremos parámetros de ruta para extraer la información codificada y pasarla al controlador de ruta (y en un artículo posterior usaremos esto para determinar dinámicamente qué información obtener de la base de datos). Al codificar la información en nuestra URL, solo necesitamos una ruta para cada recurso de un tipo particular (por ejemplo, una ruta para manejar la visualización de cada elemento de libro).\n\n\n  -info-Express te permite construir sus URL de la forma que desees; puedes codificar información en el cuerpo de la URL como se muestra arriba o usar parámetros GET de URL (por ejemplo, /book/?id=6). Independientemente del enfoque que utilices, las URL deben mantenerse limpias, lógicas y legibles (consulta los consejos del W3C).\n\n\nA continuación, creamos nuestras funciones de devolución de llamada del controlador de ruta y el código de ruta para todas las URL anteriores.\n\nCrear las callback del controlador de ruta\n\nAntes de definir nuestras rutas, primero crearemos todas las funciones de devolución de llamada ficticias/esqueléticas que invocarán. Las devoluciones de llamada se almacenarán en módulos de “controlador” separados para libros, instancias de libros, géneros y autores (puedes usar cualquier estructura de archivo/módulo, pero parece una granularidad apropiada para este proyecto).\n\nComienza creando una carpeta para nuestros controladores en la raíz del proyecto (/controllers) y luego crea archivos/módulos de controlador separados para manejar cada uno de los modelos:\n\n1\n2\n3\n4\n5\n6\n/express-locallibrary-tutorial  //the project root\n  /controllers\n    authorController.js\n    bookController.js\n    bookinstanceController.js\n    genreController.js\n\n\nAuthor controller\n\nAbre el controlador /controller/authorcontroller.js e introduce el siguiente código:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nconst Author = require(\"../models/author\");\n\n// Display list of all Authors.\nexports.author_list = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author list\");\n};\n\n// Display detail page for a specific Author.\nexports.author_detail = (req, res) =&gt; {\n  res.send(`NOT IMPLEMENTED: Author detail: ${req.params.id}`);\n};\n\n// Display Author create form on GET.\nexports.author_create_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author create GET\");\n};\n\n// Handle Author create on POST.\nexports.author_create_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author create POST\");\n};\n\n// Display Author delete form on GET.\nexports.author_delete_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author delete GET\");\n};\n\n// Handle Author delete on POST.\nexports.author_delete_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author delete POST\");\n};\n\n// Display Author update form on GET.\nexports.author_update_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author update GET\");\n};\n\n// Handle Author update on POST.\nexports.author_update_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Author update POST\");\n};\n\n\nEl módulo primero requiere el modelo que luego usaremos para acceder y actualizar nuestros datos. Luego exporta funciones para cada una de las URL que deseamos manejar (las operaciones de creación, actualización y eliminación usan formularios y, por lo tanto, también tienen métodos adicionales para manejar solicitudes de publicación de formularios; discutiremos esos métodos en el “artículo de formularios” más adelante).\n\nTodas las funciones tienen la forma estándar de una función de middleware Express, con argumentos para la solicitud y la respuesta. También podríamos incluir la siguiente función a llamar si el método no completa el ciclo de solicitud, pero en todos estos casos lo hace, por lo que la hemos omitido. Los métodos devuelven una cadena que indica que la página asociada aún no se ha creado. Si se espera que una función de controlador reciba parámetros de ruta, estos se emiten en la cadena de mensaje (ver req.params.id arriba).\n\nBookinstance Controller\n\nAbre el archivo /controller/bookinstanceController.js y escribe el siguiente código. Sigue el mismo patrón que el controlador para Autores\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nconst BookInstance = require(\"../models/bookinstance\");\n\n// Display list of all BookInstances.\nexports.bookinstance_list = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance list\");\n};\n\n// Display detail page for a specific BookInstance.\nexports.bookinstance_detail = (req, res) =&gt; {\n  res.send(`NOT IMPLEMENTED: BookInstance detail: ${req.params.id}`);\n};\n\n// Display BookInstance create form on GET.\nexports.bookinstance_create_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance create GET\");\n};\n\n// Handle BookInstance create on POST.\nexports.bookinstance_create_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance create POST\");\n};\n\n// Display BookInstance delete form on GET.\nexports.bookinstance_delete_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance delete GET\");\n};\n\n// Handle BookInstance delete on POST.\nexports.bookinstance_delete_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance delete POST\");\n};\n\n// Display BookInstance update form on GET.\nexports.bookinstance_update_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance update GET\");\n};\n\n// Handle bookinstance update on POST.\nexports.bookinstance_update_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: BookInstance update POST\");\n};\n\n\nGenre Controller\n\nAbre el archivo /controller/genreController.js y escribe el siguiente código. Sigue el mismo patrón que los otros controladores:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nconst Genre = require(\"../models/genre\");\n\n// Display list of all Genre.\nexports.genre_list = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre list\");\n};\n\n// Display detail page for a specific Genre.\nexports.genre_detail = (req, res) =&gt; {\n  res.send(`NOT IMPLEMENTED: Genre detail: ${req.params.id}`);\n};\n\n// Display Genre create form on GET.\nexports.genre_create_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre create GET\");\n};\n\n// Handle Genre create on POST.\nexports.genre_create_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre create POST\");\n};\n\n// Display Genre delete form on GET.\nexports.genre_delete_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre delete GET\");\n};\n\n// Handle Genre delete on POST.\nexports.genre_delete_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre delete POST\");\n};\n\n// Display Genre update form on GET.\nexports.genre_update_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre update GET\");\n};\n\n// Handle Genre update on POST.\nexports.genre_update_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Genre update POST\");\n};\n\n\nBook Controller\n\nAbre el archivo /controller/bookController.js y escribe el siguiente código. Sigue el mismo patrón que los otros controladores pero además tiene un método index() para mostrar la página de inicio:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\nconst Book = require(\"../models/book\");\n\nexports.index = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Site Home Page\");\n};\n\n// Display list of all books.\nexports.book_list = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book list\");\n};\n\n// Display detail page for a specific book.\nexports.book_detail = (req, res) =&gt; {\n  res.send(`NOT IMPLEMENTED: Book detail: ${req.params.id}`);\n};\n\n// Display book create form on GET.\nexports.book_create_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book create GET\");\n};\n\n// Handle book create on POST.\nexports.book_create_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book create POST\");\n};\n\n// Display book delete form on GET.\nexports.book_delete_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book delete GET\");\n};\n\n// Handle book delete on POST.\nexports.book_delete_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book delete POST\");\n};\n\n// Display book update form on GET.\nexports.book_update_get = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book update GET\");\n};\n\n// Handle book update on POST.\nexports.book_update_post = (req, res) =&gt; {\n  res.send(\"NOT IMPLEMENTED: Book update POST\");\n};\n\n\nCrear el módulo de ruta del catálogo\n\nA continuación, creamos rutas para todas las URL que necesita el sitio web de LocalLibrary, que llamará a las funciones del controlador que definimos en la sección anterior.\n\nEl esqueleto ya tiene una carpeta ./routes que contiene rutas para el índice y los usuarios. Creea otro archivo de ruta, catalog.js, dentro de esta carpeta, como se muestra.\n\n1\n2\n3\n4\n5\n/express-locallibrary-tutorial //the project root\n  /routes\n    index.js\n    users.js\n    catalog.js\n\n\nAbre routes/catalog.js y pega el siguiente código:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\nconst express = require(\"express\");\nconst router = express.Router();\n\n// Require controller modules.\nconst book_controller = require(\"../controllers/bookController\");\nconst author_controller = require(\"../controllers/authorController\");\nconst genre_controller = require(\"../controllers/genreController\");\nconst book_instance_controller = require(\"../controllers/bookinstanceController\");\n\n/// BOOK ROUTES ///\n\n// GET catalog home page.\nrouter.get(\"/\", book_controller.index);\n\n// GET request for creating a Book. NOTE This must come before routes that display Book (uses id).\nrouter.get(\"/book/create\", book_controller.book_create_get);\n\n// POST request for creating Book.\nrouter.post(\"/book/create\", book_controller.book_create_post);\n\n// GET request to delete Book.\nrouter.get(\"/book/:id/delete\", book_controller.book_delete_get);\n\n// POST request to delete Book.\nrouter.post(\"/book/:id/delete\", book_controller.book_delete_post);\n\n// GET request to update Book.\nrouter.get(\"/book/:id/update\", book_controller.book_update_get);\n\n// POST request to update Book.\nrouter.post(\"/book/:id/update\", book_controller.book_update_post);\n\n// GET request for one Book.\nrouter.get(\"/book/:id\", book_controller.book_detail);\n\n// GET request for list of all Book items.\nrouter.get(\"/books\", book_controller.book_list);\n\n/// AUTHOR ROUTES ///\n\n// GET request for creating Author. NOTE This must come before route for id (i.e. display author).\nrouter.get(\"/author/create\", author_controller.author_create_get);\n\n// POST request for creating Author.\nrouter.post(\"/author/create\", author_controller.author_create_post);\n\n// GET request to delete Author.\nrouter.get(\"/author/:id/delete\", author_controller.author_delete_get);\n\n// POST request to delete Author.\nrouter.post(\"/author/:id/delete\", author_controller.author_delete_post);\n\n// GET request to update Author.\nrouter.get(\"/author/:id/update\", author_controller.author_update_get);\n\n// POST request to update Author.\nrouter.post(\"/author/:id/update\", author_controller.author_update_post);\n\n// GET request for one Author.\nrouter.get(\"/author/:id\", author_controller.author_detail);\n\n// GET request for list of all Authors.\nrouter.get(\"/authors\", author_controller.author_list);\n\n/// GENRE ROUTES ///\n\n// GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id).\nrouter.get(\"/genre/create\", genre_controller.genre_create_get);\n\n//POST request for creating Genre.\nrouter.post(\"/genre/create\", genre_controller.genre_create_post);\n\n// GET request to delete Genre.\nrouter.get(\"/genre/:id/delete\", genre_controller.genre_delete_get);\n\n// POST request to delete Genre.\nrouter.post(\"/genre/:id/delete\", genre_controller.genre_delete_post);\n\n// GET request to update Genre.\nrouter.get(\"/genre/:id/update\", genre_controller.genre_update_get);\n\n// POST request to update Genre.\nrouter.post(\"/genre/:id/update\", genre_controller.genre_update_post);\n\n// GET request for one Genre.\nrouter.get(\"/genre/:id\", genre_controller.genre_detail);\n\n// GET request for list of all Genre.\nrouter.get(\"/genres\", genre_controller.genre_list);\n\n/// BOOKINSTANCE ROUTES ///\n\n// GET request for creating a BookInstance. NOTE This must come before route that displays BookInstance (uses id).\nrouter.get(\n  \"/bookinstance/create\",\n  book_instance_controller.bookinstance_create_get\n);\n\n// POST request for creating BookInstance.\nrouter.post(\n  \"/bookinstance/create\",\n  book_instance_controller.bookinstance_create_post\n);\n\n// GET request to delete BookInstance.\nrouter.get(\n  \"/bookinstance/:id/delete\",\n  book_instance_controller.bookinstance_delete_get\n);\n\n// POST request to delete BookInstance.\nrouter.post(\n  \"/bookinstance/:id/delete\",\n  book_instance_controller.bookinstance_delete_post\n);\n\n// GET request to update BookInstance.\nrouter.get(\n  \"/bookinstance/:id/update\",\n  book_instance_controller.bookinstance_update_get\n);\n\n// POST request to update BookInstance.\nrouter.post(\n  \"/bookinstance/:id/update\",\n  book_instance_controller.bookinstance_update_post\n);\n\n// GET request for one BookInstance.\nrouter.get(\"/bookinstance/:id\", book_instance_controller.bookinstance_detail);\n\n// GET request for list of all BookInstance.\nrouter.get(\"/bookinstances\", book_instance_controller.bookinstance_list);\n\nmodule.exports = router;\n\n\nEl módulo requiere Express y luego lo usa para crear un objeto de enrutador. Todas las rutas se configuran en el enrutador, que luego se exporta.\n\nLas rutas se definen utilizando los métodos .get() o .post() en el objeto del enrutador. Todas las rutas se definen mediante cadenas (no utilizamos patrones de cadenas ni expresiones regulares). Las rutas que actúan sobre algún recurso específico (por ejemplo, un libro) usan parámetros de ruta para obtener la identificación del objeto de la URL.\n\nTodas las funciones del controlador se importan de los módulos del controlador que creamos en la sección anterior.\n\nActualiza el módulo de ruta de índice\n\nHemos configurado todas nuestras rutas nuevas, pero todavía tenemos una ruta a la página original. En su lugar, redirijamos esto a la nueva página de índice que hemos creado en la ruta /catalog.\n\nAbre /routes/index.js y reemplaza la ruta existente con la función a continuación.\n\n1\n2\n3\n4\n// GET home page.\nrouter.get(\"/\", function (req, res) {\n  res.redirect(\"/catalog\");\n});\n\n\n\n  -info-Este es nuestro primer uso del método de respuesta redirect(). Esto redirige a la página especificada, enviando de forma predeterminada el código de estado HTTP “302 Encontrado”. Puede cambiar el código de estado devuelto si es necesario y proporcionar rutas absolutas o relativas.\n\n\nActualizar app.js\n\nEl último paso es agregar las rutas a la cadena de middleware. Hacemos esto en app.js.\n\nAbre app.js y solicite la ruta del catálogo debajo de las otras rutas (agrega la tercera línea que se muestra a continuación, debajo de las otras dos):\n\n1\n2\n3\nvar indexRouter = require(\"./routes/index\");\nvar usersRouter = require(\"./routes/users\");\nconst catalogRouter = require(\"./routes/catalog\"); //Import routes for \"catalog\" area of site\n\n\nA continuación, agrega la ruta del catálogo a la pila de middleware debajo de las otras rutas (agrega la tercera línea que se muestra a continuación, debajo de las otras dos):\n\n1\n2\n3\napp.use(\"/\", indexRouter);\napp.use(\"/users\", usersRouter);\napp.use(\"/catalog\", catalogRouter); // Add catalog routes to middleware chain.\n\n\n\n  -info-Hemos agregado nuestro módulo de catálogo en una ruta /catalog. Esto se antepone a todas las rutas definidas en el módulo de catálogo. Entonces, por ejemplo, para acceder a una lista de libros, la URL será: /catalog/books/.\n\n\nEso es. Ahora deberíamos tener rutas y funciones básicas habilitadas para todas las URL que admitiremos eventualmente en el sitio web de LocalLibrary.\n\nTestear las rutas\n\nPrimero lanzamos node\n\n1\nDEBUG=express-locallibrary-tutorial:* npm run devstart\n\n\nLuego navega a varias URL de LocalLibrary y verifica que no obtengas una página de error (HTTP 404). A continuación se incluye un pequeño conjunto de direcciones URL para tu comodidad:\n\n\n  http://localhost:3000/\n  http://localhost:3000/catalog\n  http://localhost:3000/catalog/books\n  http://localhost:3000/catalog/bookinstances/\n  http://localhost:3000/catalog/authors/\n  http://localhost:3000/catalog/genres/\n  http://localhost:3000/catalog/book/5846437593935e2f8c2aa226\n  http://localhost:3000/catalog/book/create\n\n",
        "url": "/node-express-library-teoria/rutas-y-controladores"
      }
      ,
    
      "base-de-datos": {
        "title": "Tutorial Express - parte 3: Base de datos - con Mongoose",
        "content": "Este artículo presenta brevemente las bases de datos y cómo usarlas con las aplicaciones Node/Express. Luego pasa a mostrar cómo podemos usar Mongoose para proporcionar acceso a la base de datos para el sitio web de LocalLibrary. Explica cómo se declaran el esquema y los modelos de objetos, los principales tipos de campos y la validación básica. También muestra brevemente algunas de las formas principales en las que puede acceder a los datos del modelo.\n\nDescripción general\n\nEl personal de la biblioteca usará el sitio web de la biblioteca local para almacenar información sobre libros y prestatarios, mientras que los miembros de la biblioteca lo usarán para navegar y buscar libros, averiguar si hay copias disponibles y luego reservarlas o tomarlas prestadas. Para almacenar y recuperar información de manera eficiente, la almacenaremos en una base de datos.\n\nLas aplicaciones Express pueden usar muchas bases de datos diferentes, y hay varios enfoques que puede usar para realizar operaciones de creación, lectura, actualización y eliminación (CRUD). Este tutorial proporciona una breve descripción general de algunas de las opciones disponibles y luego continúa mostrando en detalle los mecanismos particulares seleccionados.\n\n¿Qué bases de datos se pueden usar?\n\nLas aplicaciones Express pueden usar cualquier base de datos admitida por Node (Express en sí no define ningún comportamiento/requisito adicional específico para la administración de la base de datos). Hay muchas opciones populares, incluidas PostgreSQL, MySQL, Redis, SQLite y MongoDB.\n\nAl elegir una base de datos, debe considerar aspectos como el tiempo de productividad/curva de aprendizaje, el rendimiento, la facilidad de replicación/copia de seguridad, el costo, el apoyo de la comunidad, etc. Si bien no existe una única base de datos “mejor”, casi todas las soluciones populares debería ser más que aceptable para un sitio de tamaño pequeño a mediano como nuestra biblioteca local.\n\nPara obtener más información sobre las opciones, consulta Integración de la base de datos\n\n¿Cuál es la mejor manera de interactuar con una base de datos?\n\nHay dos enfoques comunes para interactuar con una base de datos:\n\n\n  Usar el lenguaje de consulta nativo de las bases de datos (por ejemplo, SQL)\n  Usando un modelo de datos de objetos (“ODM”) o un modelo relacional de objetos (“ORM”). Un ODM/ORM representa los datos del sitio web como objetos JavaScript, que luego se asignan a la base de datos subyacente. Algunos ORM están vinculados a una base de datos específica, mientras que otros proporcionan un backend independiente de la base de datos.\n\n\nSe puede obtener el mejor rendimiento utilizando SQL o cualquier lenguaje de consulta que admita la base de datos. Los ODM suelen ser más lentos porque usan código de traducción para mapear entre objetos y el formato de la base de datos, lo que puede no usar las consultas de base de datos más eficientes (esto es particularmente cierto si el ODM admite diferentes backends de bases de datos y debe comprometerse más en términos de qué base de datos características son compatibles).\n\nEl beneficio de usar un ORM es que los programadores pueden seguir pensando en términos de objetos de JavaScript en lugar de la semántica de la base de datos; esto es particularmente cierto si necesita trabajar con diferentes bases de datos (ya sea en el mismo sitio web o en sitios diferentes). También proporcionan un lugar obvio para realizar la validación de datos.\n\n\n  -info- ¡El uso de ODM/ORM a menudo resulta en menores costos de desarrollo y mantenimiento! A menos que esté muy familiarizado con el lenguaje de consulta nativo o el rendimiento sea primordial, debería considerar seriamente el uso de un ODM.\n\n\n¿Qué ORM/ODM debo usar?\n\nHay muchas soluciones ODM/ORM disponibles en el sitio del administrador de paquetes npm (consulta las etiquetas odm y orm para ver un subconjunto).\n\nAlgunas soluciones que eran populares en el momento de escribir este artículo son:\n\n\n  Mongoose: Mongoose es una herramienta de modelado de objetos MongoDB diseñada para trabajar en un entorno asíncrono.\n  Waterline: un ORM extraído del marco web de Sails basado en Express. Proporciona una API uniforme para acceder a numerosas bases de datos diferentes, incluidas Redis, MySQL, LDAP, MongoDB y Postgres.\n  Bookshelf: presenta interfaces de devolución de llamadas tradicionales y basadas en promesas, que brindan soporte de transacciones, carga de relaciones ansiosas/anidadas, asociaciones polimórficas y soporte para relaciones uno a uno, uno a muchos y muchos a muchos. Funciona con PostgreSQL, MySQL y SQLite3.\n  Objection: Facilita al máximo el uso de toda la potencia de SQL y el motor de base de datos subyacente (compatible con SQLite3, Postgres y MySQL).\n  Sequelize es un ORM basado en promesas para Node.js e io.js. Es compatible con los dialectos PostgreSQL, MySQL, MariaDB, SQLite y MSSQL y presenta un sólido soporte de transacciones, relaciones, replicación de lectura y más.\n  Node ORM2 es un administrador de relaciones de objetos para NodeJS. Es compatible con MySQL, SQLite y Progress, lo que ayuda a trabajar con la base de datos utilizando un enfoque orientado a objetos.\n  GraphQL: principalmente un lenguaje de consulta para API tranquilas, GraphQL es muy popular y tiene funciones disponibles para leer datos de bases de datos.\n\n\nComo regla general, debes considerar tanto las funciones proporcionadas como la “actividad de la comunidad” (descargas, contribuciones, informes de errores, calidad de la documentación, etc.) al seleccionar una solución. Al momento de escribir, Mongoose es, con mucho, el ODM más popular y es una opción razonable si estás utilizando MongoDB para su base de datos.\n\nUsar Mongoose y MongoDB para la biblioteca\n\nPara el ejemplo de la biblioteca local (y el resto de este tema), vamos a utilizar Mongoose ODM para acceder a los datos de nuestra biblioteca. Mongoose actúa como interfaz para MongoDB, una base de datos NoSQL de código abierto que utiliza un modelo de datos orientado a documentos. Una “colección” de “documentos” en una base de datos MongoDB es análoga a una “tabla” de “filas” en una base de datos relacional.\n\nEsta combinación de ODM y base de datos es extremadamente popular en la comunidad de Node, en parte porque el sistema de consulta y almacenamiento de documentos se parece mucho a JSON y, por lo tanto, es familiar para los desarrolladores de JavaScript.\n\n\n  -info-No necesitas conocer MongoDB para usar Mongoose, aunque partes de la documentación de Mongoose son más fáciles de usar y comprender si ya estás familiarizado con MongoDB.\n\n\nEl resto de este tutorial muestra cómo definir y acceder al esquema y los modelos de Mongoose para el ejemplo del sitio web LocalLibrary.\n\nDiseñar los modelos\n\nAntes de saltar y comenzar a codificar los modelos, vale la pena tomarse unos minutos para pensar qué datos necesitamos almacenar y las relaciones entre los diferentes objetos.\n\nSabemos que necesitamos almacenar información sobre libros (título, resumen, autor, género, ISBN) y que podemos tener varias copias disponibles (con identificaciones únicas a nivel mundial, estados de disponibilidad, etc.). Es posible que necesitemos almacenar más información sobre el autor que solo su nombre, y puede haber varios autores con el mismo nombre o nombres similares. Queremos poder clasificar la información según el título del libro, el autor, el género y la categoría.\n\nAl diseñar sus modelos, tiene sentido tener modelos separados para cada “objeto” (un grupo de información relacionada). En este caso, algunos candidatos obvios para estos modelos son los libros, las instancias de libros y los autores.\n\nTambién es posible que desees utilizar modelos para representar las opciones de la lista de selección (por ejemplo, como una lista desplegable de opciones), en lugar de codificar las opciones en el propio sitio web; esto se recomienda cuando no se conocen todas las opciones por adelantado. o puede cambiar. Un buen ejemplo es un género (por ejemplo, fantasía, ciencia ficción, etc.).\n\nUna vez que hemos decidido nuestros modelos y campos, debemos pensar en las relaciones entre ellos.\n\nCon eso en mente, el siguiente diagrama de asociación UML muestra los modelos que definiremos en este caso (como cuadros). Como se discutió anteriormente, hemos creado modelos para el libro (los detalles genéricos del libro), la instancia del libro (estado de las copias físicas específicas del libro disponibles en el sistema) y el autor. También hemos decidido tener un modelo para el género para que los valores se puedan crear dinámicamente. Hemos decidido no tener un modelo para BookInstance:status; codificaremos los valores aceptables porque no esperamos que cambien. Dentro de cada uno de las cajas, puedes ver el nombre del modelo, los nombres y tipos de campo, y también los métodos y sus tipos de devolución.\n\nEl diagrama también muestra las relaciones entre los modelos, incluidas sus multiplicidades. Las multiplicidades son los números en el diagrama que muestra los números (máximo y mínimo) de cada modelo que puede estar presente en la relación. Por ejemplo, la línea de conexión entre las cajas muestra que el Book y Genre están relacionados. Los números cerca del modelo Boolk muestran que un Genre debe tener cero o más Libros (tantos como desee), mientras que los números en el otro extremo de la línea al lado del Genre muestran que un libro puede tener cero o más Genre asociados. .\n\n\n\nPrimeros pasos con Mongoose\n\nEsta sección proporciona una descripción general de cómo conectar Mongoose a una base de datos MongoDB, cómo definir un esquema y un modelo, y cómo realizar consultas básicas.\n\n\n  -info- Este manual está fuertemente influenciado por el inicio rápido de Mongoose en npm y la documentación oficial.\n\n\nInstalación de Mongoose y MongoDB\n\nMongoose se instala en el proyecto (package.json) como cualquier otra dependencia, usando npm. Para instalarlo, use el siguiente comando dentro de la carpeta de su proyecto:\n\n1\nnpm instalar mangoose\n\n\nLa instalación de Mongoose agrega todas sus dependencias, incluido el controlador de la base de datos MongoDB, pero no instala MongoDB en sí. Si deseas instalar un servidor MongoDB, puede descargar instaladores desde aquí para varios sistemas operativos e instalarlo localmente. También puedes utilizar instancias de MongoDB basadas en la nube.\n\n\n  -info-Para este tutorial, usaremos la base de datos basada en la nube de MongoDB Atlas como un nivel gratuito de servicio para proporcionar la base de datos. Esto es adecuado para el desarrollo y tiene sentido para el tutorial porque hace que la “instalación” del sistema operativo sea independiente (la base de datos como servicio también es un enfoque que puede usar para su base de datos de producción).\n\n\nConexión a MongoDB\n\nMongoose requiere una conexión a una base de datos MongoDB. Puedes usar require() y conectarte a una base de datos alojada localmente con mongoose.connect() como se muestra a continuación (para el tutorial, en su lugar, nos conectaremos a una base de datos alojada en Internet).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// Import the mongoose module\nconst mongoose = require(\"mongoose\");\n\n// Set `strictQuery: false` to globally opt into filtering by properties that aren't in the schema\n// Included because it removes preparatory warnings for Mongoose 7.\n// See: https://mongoosejs.com/docs/migrating_to_6.html#strictquery-is-removed-and-replaced-by-strict\nmongoose.set('strictQuery', false);\n\n// Define the database URL to connect to.\nconst mongoDB = \"mongodb://127.0.0.1/my_database\";\n\n// Wait for database to connect, logging an error if there is a problem \nmain().catch(err =&gt; console.log(err));\nasync function main() {\n  await mongoose.connect(mongoDB);\n}\n\n\nPuedes obtener el objeto Connection predeterminado con mongoose.connection. Si necesitas crear conexiones adicionales, puedes usar mongoose.createConnection(). Toma la misma forma de URI de base de datos (con host, base de datos, puerto, opciones, etc.) que connect() y devuelve un objeto Connection). Ten en cuenta que createConnection() regresa inmediatamente; si necesitas esperar a que se establezca la conexión, puede llamarla con asPromise() para devolver una promesa (mongoose.createConnection(mongoDB).asPromise()).\n\nDefinir y crear modelo\n\nLos modelos se definen mediante la interfaz Schema. El Schema te permite definir los campos almacenados en cada documento junto con sus requisitos de validación y valores predeterminados. Además, puedes definir métodos auxiliares estáticos y de instancia para facilitar el trabajo con sus tipos de datos, y también propiedades virtuales que puede usar como cualquier otro campo, pero que en realidad no están almacenadas en la base de datos (hablaremos un poco más abajo).\n\nLuego, los esquemas se “compilan” en modelos utilizando el método mongoose.model(). Una vez que tengas un modelo, puedes usarlo para buscar, crear, actualizar y eliminar objetos del tipo dado.\n\n\n  -info-Cada modelo se asigna a una colección de documentos en la base de datos MongoDB. Los documentos contendrán los campos/tipos de esquema definidos en el esquema modelo.\n\n\nDefinir schemas\n\nEl siguiente fragmento de código muestra cómo se puede definir un esquema simple. Primero usas requiere() mongoose, luego usas el constructor de esquema para crear una nueva instancia de esquema, definiendo los diversos campos dentro de él en el parámetro de objeto del constructor.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n// Require Mongoose\nconst mongoose = require(\"mongoose\");\n\n// Define a schema\nconst Schema = mongoose.Schema;\n\nconst SomeModelSchema = new Schema({\n  a_string: String,\n  a_date: Date,\n});\n\n\n\nEn el caso anterior, solo tenemos dos campos, una cadena y una fecha. En las siguientes secciones, mostraremos algunos de los otros tipos de campos, validación y otros métodos.\n\nCrear un modelo\n\nLos modelos se crean a partir de esquemas utilizando el método mongoose.model():\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n// Define schema\nconst Schema = mongoose.Schema;\n\nconst SomeModelSchema = new Schema({\n  a_string: String,\n  a_date: Date,\n});\n\n// Compile model from schema\nconst SomeModel = mongoose.model(\"SomeModel\", SomeModelSchema);\n\n\nEl primer argumento es el nombre singular de la colección que se creará para su modelo (Mongoose creará la colección de la base de datos para el modelo SomeModel anterior), y el segundo argumento es el esquema que desea usar para crear el modelo.\n\n\n  -info-Una vez que hayas definido tus clases de modelo, puedes usarlas para crear, actualizar o eliminar registros y ejecutar consultas para obtener todos los registros o subconjuntos particulares de registros. Te mostraremos cómo hacer esto en la sección Uso de modelos, y cuando creamos nuestras vistas.\n\n\nSchema types (fields)\n\nUn esquema puede tener una cantidad arbitraria de campos; cada uno representa un campo en los documentos almacenados en MongoDB. A continuación se muestra un esquema de ejemplo que muestra muchos de los tipos de campo comunes y cómo se declaran.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nconst schema = new Schema({\n  name: String,\n  binary: Buffer,\n  living: Boolean,\n  updated: { type: Date, default: Date.now() },\n  age: { type: Number, min: 18, max: 65, required: true },\n  mixed: Schema.Types.Mixed,\n  _someId: Schema.Types.ObjectId,\n  array: [],\n  ofString: [String], // You can also have an array of each of the other types too.\n  nested: { stuff: { type: String, lowercase: true, trim: true } },\n});\n\n\nLa mayoría de los SchemaTypes (los descriptores después de “tipo:” o después de los nombres de campo) se explican por sí mismos. Las excepciones son:\n\n\n  ObjectId: representa instancias específicas de un modelo en la base de datos. Por ejemplo, un libro podría usar esto para representar su objeto de autor. Esto realmente contendrá la ID única (_id) para el objeto especificado. Podemos usar el método populate() para extraer la información asociada cuando sea necesario.\n  Mixed: un tipo de esquema arbitrario.\n  []: una matriz de elementos. Puedes realizar operaciones de matriz de JavaScript en estos modelos (push, pop, unshift, etc.). Los ejemplos  anteriores muestran una matriz de objetos sin un tipo específico y una matriz de objetos String, pero puede tener una matriz de cualquier tipo de objeto.\n\n\nEl código también muestra ambas formas de declarar un campo:\n\n\n  Nombre y tipo de campo como un par clave-valor (es decir, como se hizo con los campos nombre, binario y vivo).\n  Nombre de campo seguido de un objeto que define el tipo y cualquier otra opción para el campo. Las opciones incluyen cosas como:\n    \n      valores predeterminados.\n      validadores incorporados (por ejemplo, valores máximos/mínimos) y funciones de validación personalizadas.\n      Si el campo es obligatorio\n      Si los campos de cadena deben configurarse automáticamente en minúsculas, mayúsculas o recortados (por ejemplo, { type: String, lowercase: true, trim: true }))\n    \n  \n\n\nPara obtener más información sobre las opciones, consulta SchemaTypes.\n\nValidación\n\nMongoose proporciona validadores integrados y personalizados, y validadores síncronos y asíncronos. Te permite especificar tanto el rango aceptable de valores como el mensaje de error por fallo de validación en todos los casos.\n\nLos validadores integrados incluyen:\n\n\n  Todos los SchemaTypes tienen el validador required incorporado. Se utiliza para especificar si se debe proporcionar el campo para guardar un documento.\n  Los números tienen validadores min y max.\n  Las cadenas tienen:\n    \n      enum: especifica el conjunto de valores permitidos para el campo.\n      match: especifica una expresión regular con la que debe coincidir la cadena.\n      maxLength y minLength para la cadena.\n    \n  \n\n\nEl siguiente ejemplo (ligeramente modificado de los documentos de Mongoose) muestra cómo se pueden especificar algunos de los tipos de validadores y mensajes de error:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nconst breakfastSchema = new Schema({\n  eggs: {\n    type: Number,\n    min: [6, \"Too few eggs\"],\n    max: 12,\n    required: [true, \"Why no eggs?\"],\n  },\n  drink: {\n    type: String,\n    enum: [\"Coffee\", \"Tea\", \"Water\"],\n  },\n});\n\n\nPara obtener información completa sobre la validación de campos, consulta Validación\n\nPropiedades virtuales\n\nLas propiedades virtuales son propiedades de documentos que se pueden obtener y establecer, pero que no se conservan en MongoDB. Los getters son útiles para dar formato o combinar campos, mientras que los setters son útiles para descomponer un solo valor en varios valores para su almacenamiento. El ejemplo de la documentación construye (y deconstruye) una propiedad virtual de nombre completo a partir de un campo de nombre y apellido, que es más fácil y limpio que construir un nombre completo cada vez que se usa uno en una plantilla.\n\n\n  -info-Usaremos una propiedad virtual en la biblioteca para definir una URL única para cada registro de modelo usando una ruta y el valor _id del registro.\n\n\nPara obtener más información, consulta Virtuals\n\nMétodos y asistentes de consulta\n\nUn esquema también puede tener métodos de instancia, métodos estáticos y asistentes de consulta. Los métodos de instancia y estáticos son similares, pero con la diferencia obvia de que un método de instancia está asociado con un registro en particular y tiene acceso al objeto actual. Los asistentes de consulta te permiten ampliar la API de generador de consultas encadenable de mongoose (por ejemplo, permitiéndole agregar una consulta “byName” además de los métodos find(), findOne() y findById()).\n\nUsar modelos\n\nUna vez que hayas creado un esquema, puedes usarlo para crear modelos. El modelo representa una colección de documentos en la base de datos que puedes buscar, mientras que las instancias del modelo representan documentos individuales que puede guardar y recuperar.\n\nOfrecemos una breve descripción a continuación. Para obtener más información, consulta: Modelos\n\nCrear y modificar documentos\n\nPara crear un registro, puedes definir una instancia del modelo y luego llamar a save(). Los ejemplos a continuación asumen que SomeModel es un modelo (con un solo campo “name”) que hemos creado a partir de nuestro esquema.\n\n1\n2\n3\n4\n5\n6\n7\n8\n// Create an instance of model SomeModel\nconst awesome_instance = new SomeModel({ name: \"awesome\" });\n\n// Save the new model instance, passing a callback\nawesome_instance.save((err) =&gt; {\n  if (err) return handleError(err);\n  // saved!\n});\n\n\nLa creación de registros (junto con actualizaciones, eliminaciones y consultas) son operaciones asincrónicas: proporciona una devolución de llamada que se llama cuando se completa la operación. La API utiliza la convención de primer argumento de error, por lo que el primer argumento para la devolución de llamada siempre será un valor de error (o nulo). Si la API devuelve algún resultado, este se proporcionará como segundo argumento.\n\nTambién puedes usar create() para definir la instancia del modelo al mismo tiempo que la guarda. La devolución de llamada devolverá un error para el primer argumento y la instancia de modelo recién creada para el segundo argumento.\n\n1\n2\n3\n4\nSomeModel.create({ name: \"also_awesome\" }, function (err, awesome_instance) {\n  if (err) return handleError(err);\n  // saved!\n});\n\n\nCada modelo tiene una conexión asociada (esta será la conexión predeterminada cuando uses mongoose.model()). Creas una nueva conexión y llamas a .model() para crear los documentos en una base de datos diferente.\n\nPuedes acceder a los campos en este nuevo registro utilizando la sintaxis de puntos y cambiar los valores. Debes llamar a save() o update() para almacenar los valores modificados en la base de datos.\n\n1\n2\n3\n4\n5\n6\n7\n8\n// Access model field values using dot notation\nconsole.log(awesome_instance.name); //should log 'also_awesome'\n\n// Change record by modifying the fields, then calling save().\nawesome_instance.name = \"New cool name\";\nawesome_instance.save((err) =&gt; {\n  if (err) return handleError(err); // saved!\n});\n\n\nBuscar registros\n\nPuedes buscar registros utilizando métodos de consulta, especificando las condiciones de consulta como un documento JSON. El fragmento de código a continuación muestra cómo puedes encontrar a todos los atletas en una base de datos que juegan a  tenis, devolviendo solo los campos para el nombre y la edad del atleta. Aquí solo especificamos un campo coincidente (deporte), pero puedes agregar más criterios, especificar criterios de expresión regular o eliminar las condiciones por completo para devolver a todos los atletas.\n\n1\n2\n3\n4\n5\n6\n7\nconst Athlete = mongoose.model(\"Athlete\", yourSchema);\n\n// find all athletes who play tennis, selecting the 'name' and 'age' fields\nAthlete.find({ sport: \"Tennis\" }, \"name age\", (err, athletes) =&gt; {\n  if (err) return handleError(err);\n  // 'athletes' contains the list of athletes that match the criteria.\n});\n\n\nSi especificas una devolución de llamada, como se muestra arriba, la consulta se ejecutará de inmediato. La devolución de llamada se invocará cuando se complete la búsqueda.\n\n\n  -info-Todas las devoluciones de llamada en Mongoose usan la devolución de llamada de patrón (error, resultado). Si ocurre un error al ejecutar la consulta, el parámetro de error contendrá un documento de error y el resultado será nulo. Si la consulta es exitosa, el parámetro de error será nulo y el resultado se completará con los resultados de la consulta.\n\n\n\n  -info-Es importante recordar que no encontrar ningún resultado no es un error para una búsqueda, pero puede ser un caso fallido en el contexto de su aplicación. Si su aplicación espera que una búsqueda encuentre un valor, puedes verificar el resultado en la devolución de llamada (resultados == null) o conectar en cadena el método orFail() en la consulta.\n\n\nSi no especificas una devolución de llamada, la API devolverá una variable de tipo Query. Puedes usar este objeto de consulta para crear tu consulta y luego ejecutarla (con una devolución de llamada) más tarde usando el método exec().\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// find all athletes that play tennis\nconst query = Athlete.find({ sport: \"Tennis\" });\n\n// selecting the 'name' and 'age' fields\nquery.select(\"name age\");\n\n// limit our results to 5 items\nquery.limit(5);\n\n// sort by age\nquery.sort({ age: -1 });\n\n// execute the query at a later time\nquery.exec((err, athletes) =&gt; {\n  if (err) return handleError(err);\n  // athletes contains an ordered list of 5 athletes who play Tennis\n});\n\n\nArriba hemos definido las condiciones de consulta en el método find(). También podemos hacer esto usando una función where(), y podemos encadenar todas las partes de nuestra consulta usando el operador de punto (.) en lugar de agregarlas por separado. El fragmento de código a continuación es el mismo que nuestra consulta anterior, con una condición adicional para la edad.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nAthlete.find()\n  .where(\"sport\")\n  .equals(\"Tennis\")\n  .where(\"age\")\n  .gt(17)\n  .lt(50) // Additional where query\n  .limit(5)\n  .sort({ age: -1 })\n  .select(\"name age\")\n  .exec(callback); // where callback is the name of our callback function.\n\n\nEl método find() obtiene todos los registros coincidentes, pero a menudo solo deseas obtener una coincidencia. Los siguientes métodos consultan por un solo registro:\n\n\n  findById(): encuentra el documento con la identificación especificada (cada documento tiene una identificación única).\n  findOne(): busca un solo documento que coincida con los criterios especificados.\n  findByIdAndRemove(), findByIdAndUpdate(), findOneAndRemove(), findOneAndUpdate(): busca un solo documento por ID o criterio y lo actualiza o lo elimina. Estas son funciones de conveniencia útiles para actualizar y eliminar registros.\n\n\n\n  -hint-También hay un método count() que puedes usar para obtener la cantidad de elementos que coinciden con las condiciones. Esto es útil si desea realizar un conteo sin obtener realmente los registros.\n\n\nHay mucho más que puedes hacer con las consultas. Para más información ver: Queries\n\nTrabajar con documentos relacionados: population\n\nPuedes crear referencias de una instancia de documento/modelo a otra usando el campo de esquema ObjectId, o de un documento a muchos usando una matriz de ObjectIds. El campo almacena el id del modelo relacionado. Si necesitas el contenido real del documento asociado, puedes usar el método populate() en una consulta para reemplazar la identificación con los datos reales.\n\nPor ejemplo, el siguiente esquema define autores e historias. Cada autor puede tener varias historias, que representamos como una matriz de ObjectId. Cada historia puede tener un solo autor. La propiedad ref le dice al esquema qué modelo se puede asignar a este campo.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nconst mongoose = require(\"mongoose\");\n\nconst Schema = mongoose.Schema;\n\nconst authorSchema = Schema({\n  name: String,\n  stories: [{ type: Schema.Types.ObjectId, ref: \"Story\" }],\n});\n\nconst storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref: \"Author\" },\n  title: String,\n});\n\nconst Story = mongoose.model(\"Story\", storySchema);\nconst Author = mongoose.model(\"Author\", authorSchema);\n\n\nPodemos guardar nuestras referencias al documento relacionado asignando el valor _id. A continuación, creamos un autor, luego una historia y asignamos la identificación del autor al campo de autor de nuestra historia.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nconst bob = new Author({ name: \"Bob Smith\" });\n\nbob.save((err) =&gt; {\n  if (err) return handleError(err);\n\n  // Bob now exists, so lets create a story\n  const story = new Story({\n    title: \"Bob goes sledding\",\n    author: bob._id, // assign the _id from our author Bob. This ID is created by default!\n  });\n\n  story.save((err) =&gt; {\n    if (err) return handleError(err);\n    // Bob now has his story\n  });\n});\n\n\nNuestro documento de historia ahora tiene un autor al que se hace referencia mediante el ID del documento de autor. Para obtener la información del autor en los resultados de la historia, usamos populate(), como se muestra a continuación.\n\n1\n2\n3\n4\n5\n6\n7\nStory.findOne({ title: \"Bob goes sledding\" })\n  .populate(\"author\") // This populates the author id with actual author information!\n  .exec((err, story) =&gt; {\n    if (err) return handleError(err);\n    console.log(\"The author is %s\", story.author.name);\n    // prints \"The author is Bob Smith\"\n  });\n\n\n\n  -info- Los lectores astutos habrán notado que agregamos un autor a nuestra historia, pero no hicimos nada para agregar nuestra historia a la matriz de historias de nuestro autor. Entonces, ¿cómo podemos obtener todas las historias de un autor en particular? Una forma sería agregar nuestra historia a la matriz de historias, pero esto daría como resultado que tengamos dos lugares donde se debe mantener la información relacionada con los autores y las historias.\n\n  Una mejor manera es obtener el _id de nuestro autor, luego usar find() para buscarlo en el campo del autor en todas las historias.\n\n  1\n2\n3\n4\nStory.find({ author: bob._id }).exec((err, stories) =&gt; {\n  if (err) return handleError(err);\n  // returns all stories that have Bob's id as their author.\n});\n  \n\n\nEsto es casi todo lo que necesitas saber sobre cómo trabajar con elementos relacionados para este tutorial. Para obtener información más detallada, consulta Population\n\nUn esquema/modelo por fichero\n\nSi bien puedes crear esquemas y modelos utilizando cualquier estructura de archivo que desees, te recomiendo que definas cada esquema de modelo en su propio módulo (archivo) y luego exportes el método para crear el modelo. Esto se muestra a continuación:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n// File: ./models/somemodel.js\n\n// Require Mongoose\nconst mongoose = require(\"mongoose\");\n\n// Define a schema\nconst Schema = mongoose.Schema;\n\nconst SomeModelSchema = new Schema({\n  a_string: String,\n  a_date: Date,\n});\n\n// Export function to create \"SomeModel\" model class\nmodule.exports = mongoose.model(\"SomeModel\", SomeModelSchema);\n\n\nA continuación, puede hacer require y utilizar el modelo inmediatamente en otros archivos. A continuación, mostramos cómo puedes usarlo para obtener todas las instancias del modelo.\n\n1\n2\n3\n4\n5\n// Create a SomeModel model just by requiring the module\nconst SomeModel = require(\"../models/somemodel\");\n\n// Use the SomeModel object (model) to find all SomeModel records\nSomeModel.find(callback_function);\n\n\nConfiguración de la base de datos MongoDB\n\nAhora que entendemos algo de lo que Mongoose puede hacer y cómo queremos diseñar nuestros modelos, es hora de comenzar a trabajar en el sitio web de LocalLibrary. Lo primero que queremos hacer es configurar una base de datos MongoDB que podamos usar para almacenar los datos de nuestra biblioteca.\n\nPara este tutorial, vamos a utilizar la base de datos sandbox alojada en la nube de MongoDB Atlas. Este nivel de base de datos no se considera adecuado para sitios web de producción porque no tiene redundancia, pero es excelente para el desarrollo y la creación de prototipos. Lo estamos usando aquí porque es gratis y fácil de configurar, y porque MongoDB Atlas es una base de datos popular como proveedor de servicios que podría elegir razonablemente para su base de datos de producción (otras opciones populares en el momento de escribir este artículo incluyen Compose, ScaleGrid y ObjectRocket).\n\nPrimero deberás crear una cuenta con MongoDB Atlas (esto es gratis y solo requiere que ingreses los datos de contacto básicos y reconozcas sus términos de servicio).\n\nDespués de iniciar sesión, accederá a la pantalla de inicio:\n\n\n  Haz clic en el botón Crear una base de datos en la sección Implementaciones de base de datos.\n\n\n\n\n\n  \n    Esto abrirá la pantalla Deploy una base de datos en la nube. Haga clic en el botón Crear debajo de la opción Shared Deployment\n\n    \n  \n  \n    Esto abrirá la pantalla  Create a Shared Cluster\n\n    \n  \n\n\n\n  Selecciona cualquier proveedor de la sección Proveedor de la nube y región. Diferentes regiones ofrecen diferentes proveedores.\n  No es necesario cambiar el nivel de clúster y la configuración adicional. Puedes cambiar el nombre de su clúster en Nombre del clúster. Lo estamos nombrando Cluster0 para este tutorial.\n  Haz clic en el botón Crear clúster (la creación del clúster tardará unos minutos).\n\n\n\n  \n    Esto abrirá la sección Security Quickstart.\n\n    \n\n    Introduce un nombre de usuario y contraseña. Recuerda copiar y almacenar las credenciales de forma segura, ya que las necesitaremos más adelante. Haz clic en el botón Crear usuario.\n\n    \n      -alert-Evita usar caracteres especiales en tu contraseña de usuario de MongoDB, ya que es posible que mongoose no analice la cadena de conexión correctamente.\nIntroduce 0.0.0.0/0 en el campo Dirección IP. Esto le dice a MongoDB que queremos permitir el acceso desde cualquier lugar. Haga clic en el botón Agregar entrada.\n    \n\n    \n      -info-Es una buena práctica limitar las direcciones IP que pueden conectarse a su base de datos y otros recursos. Aquí permitimos una conexión desde cualquier lugar porque no sabemos de dónde vendrá la solicitud después de la implementación.\n\n      Haga clic en el botón Finalizar y cerrar.\n    \n  \n  \n    Esto abrirá la siguiente pantalla. Haga clic en el botón Ir a bases de datos.\n\n    \n  \n  \n    Volverás a la pantalla  Database Deployments . Haz clic en Browse Collections\n\n    \n  \n  \n    Esto abrirá la sección Collections. Haz clic en Add My Own Data.\n\n    \n  \n  \n    Esto abrirá la pantalla Create Database\n\n    \n\n    \n      Introducr el nombre de la nueva base de datos como local_library.\n      Introduce el nombre de la colección como Collection0.\n      Haga clic en el botón Crear para crear la base de datos.\n    \n  \n  \n    Volverás a la pantalla de colecciones con la base de datos creada\n\n    \n\n    Haz clic en la pestaña Overview para volver al clúster\n  \n  \n    Haz clic en el botón Connect\n\n    \n  \n  \n    Esto abrirá la pantalla Connect to Cluster screen. Haz clic en Connect your application .\n\n    \n  \n  \n    Se mostrará la pantalla Connect\n\n\n    \n      Selecciona el controlador y la versión de node como se muestra.\n      Haz clic en el icono Copiar para copiar la cadena de conexión.\n      Pega esto en su editor de texto local.\n      Actualiza el nombre de usuario y la contraseña con tu contraseña de usuario.\n      Inserte el nombre de la base de datos “local_library” en la ruta antes de las opciones (…mongodb.net/local_library?retryWrites…)/\n      Guarda el archivo que contiene esta cadena en un lugar seguro.\n    \n  \n\n\nAhora has creado la base de datos y tienes una URL (con nombre de usuario y contraseña) que se puede usar para acceder a ella. Esto se verá así:\n\n1\nmongodb+srv://tu_nombre_de_usuario:tu_contraseña@cluster0.lz91hw2.mongodb.net/local_library?retryWrites=true&amp;w=majority\n\n\nInstalar mongoose\n\nAbre un símbolo del sistema y navega hasta el directorio donde creaste el esqueleto de sitio web  de la biblioteca local. Introduce el siguiente comando para instalar Mongoose (y sus dependencias) y se agregará a tu archivo package.json, a menos que ya lo hayas hecho.\n\n1\nnpm install mongoose\n\n\nConectar a la base de datos\n\nAbre /app.js (en la raíz de tu proyecto) y copia el siguiente texto debajo donde declara el objeto de la aplicación Express (después de la línea var app = express();). Reemplaza la cadena de URL de la base de datos (‘insert_your_database_url_here’) con la ubicación URL que representa su propia base de datos (es decir, utilizando la información de mongoDB Atlas).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// Set up mongoose connection\nconst mongoose = require(\"mongoose\");\nmongoose.set('strictQuery', false);\nconst mongoDB = \"insert_your_database_url_here\";\n\nmain().catch(err =&gt; console.log(err));\nasync function main() {\n  await mongoose.connect(mongoDB);\n}\n\n\nDefinir el esquema\n\nDefiniremos un módulo separado para cada modelo, como se discutió anteriormente. Comienza creando una carpeta para nuestros modelos en la raíz del proyecto (/models) y luego cree archivos separados para cada uno de los modelos:\n\n1\n2\n3\n4\n5\n6\n/express-locallibrary-tutorial  // the project root\n  /models\n    author.js\n    book.js\n    bookinstance.js\n    genre.js\n\n\nAuthor model\n\nCopia el código del esquema de autor que se muestra a continuación y pégalo en el archivo ./models/author.js. El esquema define que un autor tiene tipos de esquema de cadena para el nombre y el apellido (obligatorio, con un máximo de 100 caracteres) y campos de fecha para las fechas de nacimiento y muerte.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nconst mongoose = require(\"mongoose\");\n\nconst Schema = mongoose.Schema;\n\nconst AuthorSchema = new Schema({\n  first_name: { type: String, required: true, maxLength: 100 },\n  family_name: { type: String, required: true, maxLength: 100 },\n  date_of_birth: { type: Date },\n  date_of_death: { type: Date },\n});\n\n// Virtual for author's full name\nAuthorSchema.virtual(\"name\").get(function () {\n  // To avoid errors in cases where an author does not have either a family name or first name\n  // We want to make sure we handle the exception by returning an empty string for that case\n  let fullname = \"\";\n  if (this.first_name &amp;&amp; this.family_name) {\n    fullname = `${this.family_name}, ${this.first_name}`;\n  }\n  if (!this.first_name || !this.family_name) {\n    fullname = \"\";\n  }\n  return fullname;\n});\n\n// Virtual for author's URL\nAuthorSchema.virtual(\"url\").get(function () {\n  // We don't use an arrow function as we'll need the this object\n  return `/catalog/author/${this._id}`;\n});\n\n// Export model\nmodule.exports = mongoose.model(\"Author\", AuthorSchema);\n\n\nTambién declaramos un virtual para AuthorSchema llamado “url” que devuelve la URL absoluta requerida para obtener una instancia particular del modelo; usaremos la propiedad en nuestras plantillas siempre que necesitemos obtener un enlace a un autor en particular.\n\n\n  -info-Declarar nuestras URL como virtuales en el esquema es una buena idea porque entonces la URL de un elemento solo necesita cambiarse en un lugar. En este punto, un enlace que use esta URL no funcionaría, porque no tenemos ningún código de manejo de rutas para instancias de modelos individuales. ¡Los configuraremos en un artículo posterior!\n\n\nAl final del módulo, exportamos el modelo.\n\nBook model\n\nCopa el código de esquema del libro que se muestra a continuación y pégalo en su archivo ./models/book.js. La mayor parte de esto es similar al modelo de autor: hemos declarado un esquema con varios campos de cadena y un virtual para obtener la URL de registros de libros específicos, y hemos exportado el modelo.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nconst mongoose = require(\"mongoose\");\n\nconst Schema = mongoose.Schema;\n\nconst BookSchema = new Schema({\n  title: { type: String, required: true },\n  author: { type: Schema.Types.ObjectId, ref: \"Author\", required: true },\n  summary: { type: String, required: true },\n  isbn: { type: String, required: true },\n  genre: [{ type: Schema.Types.ObjectId, ref: \"Genre\" }],\n});\n\n// Virtual for book's URL\nBookSchema.virtual(\"url\").get(function () {\n  // We don't use an arrow function as we'll need the this object\n  return `/catalog/book/${this._id}`;\n});\n\n// Export model\nmodule.exports = mongoose.model(\"Book\", BookSchema);\n\n\nLa principal diferencia aquí es que hemos creado dos referencias a otros modelos:\n\n\n  author es una referencia a un solo objeto de modelo Author y es obligatorio.\n  genre es una referencia a una matriz de objetos de modelo Género. ¡Aún no hemos declarado este objeto!\n\n\nBookinstance model\n\nFinalmente, copia el código de esquema de BookInstance que se muestra a continuación y pégalo en el archivo ./models/bookinstance.js. BookInstance representa una copia específica de un libro que alguien podría tomar prestada e incluye información sobre si la copia está disponible, en qué fecha se espera que se devuelva y detalles de “impresión” (o versión).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nconst mongoose = require(\"mongoose\");\n\nconst Schema = mongoose.Schema;\n\nconst BookInstanceSchema = new Schema({\n  book: { type: Schema.Types.ObjectId, ref: \"Book\", required: true }, // reference to the associated book\n  imprint: { type: String, required: true },\n  status: {\n    type: String,\n    required: true,\n    enum: [\"Available\", \"Maintenance\", \"Loaned\", \"Reserved\"],\n    default: \"Maintenance\",\n  },\n  due_back: { type: Date, default: Date.now },\n});\n\n// Virtual for bookinstance's URL\nBookInstanceSchema.virtual(\"url\").get(function () {\n  // We don't use an arrow function as we'll need the this object\n  return `/catalog/bookinstance/${this._id}`;\n});\n\n// Export model\nmodule.exports = mongoose.model(\"BookInstance\", BookInstanceSchema);\n\n\nLas cosas nuevas que mostramos aquí son las opciones de campo:\n\n\n  enum: Esto nos permite establecer los valores permitidos de una cadena. En este caso, lo usamos para especificar el estado de disponibilidad de nuestros libros (usar una enumeración significa que podemos evitar errores ortográficos y valores arbitrarios para nuestro estado).\n  default: usamos default para establecer el estado predeterminado para las instancias de libros recién creadas en mantenimiento y la fecha de vencimiento predeterminada para ahora (¡observa cómo puedes llamar a la función Date al configurar la fecha!).\n\n\nTodo lo demás debe ser familiar de nuestro esquema anterior.\n\nGenre model\n\n\n  -reto-Abre tu archivo ./models/genre.js y crea un esquema para almacenar géneros (la categoría del libro, por ejemplo, si es ficción o no ficción, romance o historia militar, etc.).\n\n  La definición será muy similar a los otros modelos:\n\n  \n    \n      El modelo debe tener un campo de tipo String llamado  name para describir el género.\n    \n    \n      Este nombre debe ser obligatorio y tener entre 3 y 100 caracteres.\n    \n    \n      Declara una virtual para la URL del género, llamada url.\n    \n  \n\n  Exporta el modelo.\n\n\nTesteo. Crear unos cuantos ítems\n\nEso es. ¡Ya tenemos todos los modelos para el sitio configurados!\n\nPara probar los modelos (y crear algunos libros de ejemplo y otros elementos que podemos usar en nuestros próximos artículos), ahora ejecutaremos un script independiente para crear elementos de cada tipo:\n\n\n  \n    Descarga el archivo populatedb.js dentro de tu directorio express-locallibrary-tutorial (en el mismo nivel que package.json).\n  \n  \n    Introduce los siguientes comandos en la raíz del proyecto para instalar el módulo async que requiere el script\n\n    1\nnpm install async\n    \n  \n  \n    Ejecuta el script usando node en el símbolo del sistema, pasando la URL de su base de datos MongoDB (la misma con la que reemplazaste el marcador de posición insert_your_database_url_here, dentro de app.js anteriormente):\n\n    1\nnode populatedb &lt;your mongodb url&gt;\n    \n  \n  \n    El script debe ejecutarse hasta su finalización, mostrando los elementos a medida que los crea en la terminal.\n  \n\n\n\n  -info-Ve a tu base de datos en mongoDB Atlas (en la pestaña Colecciones). Ahora deberías poder profundizar en colecciones individuales de libros, autores, géneros e instancias de libros, y consultar documentos individuales.\n\n\nVéase también\n\n\n  Database integration\n  Mongoose website\n  Mongoose Guide\n  Validation\n  Schema Types\n  Models\n  Queries\n  Population\n\n",
        "url": "/node-express-library-teoria/base-de-datos"
      }
      ,
    
      "esqueleto-de-la-aplicacion": {
        "title": "Tutorial Express - parte 2: Esqueleto de la aplicación",
        "content": "Este segundo artículo de nuestro Tutorial Express muestra cómo puede crear un “esqueleto” para un proyecto de sitio web que luego puede completar con rutas, plantillas/vistas, y llamadas a base de datos especifícas del sitio.\n\n\n  \n    \n      Prerequisitos:\n      \n        Configurar un entorno de desarrollo de Node. Revise el Tutorial Express.\n      \n    \n    \n      Objetivo:\n      \n        Poder empezar sus nuevos proyectos web usando el\n        Generador de Aplicaciones Express.\n      \n    \n  \n\n\nVisión General\n\nEste artículo muestra cómo puedes crear un sitio web “esqueleto” usando la herramienta Generador de Aplicaciones Express, que luego puedes completar con rutas, vistas/plantillas, y llamadas a base de datos específicas del sitio. En este caso usaremos la herramienta para crear el framework para nuestro sitio web, al que luego agregaremos todo el código que el sitio necesite. El proceso es extremadamente simple, requiriendo sólo que se invoque el generador en la línea de comandos con un nombre para el nuevo proyecto, opcionalmente especificando también el motor de plantillas y el generador de CSS a utilizar.\n\nLas siguientes secciones muestran como puedes llamar al generador de aplicaciones, y proporcionan una pequeña explicación sobre las diferentes opciones para vistas y CSS. También explicaremos como está estructurado el esqueleto del sitio web. Al final, mostraremos cómo puedes ejecutar el sitio web para verificar que funciona.\n\n\n  -info- El Generador de Aplicaciones Express no es el único generador para aplicaciones Express, y el proyecto generado no es la única forma viable para estructurar sus archivos y directorios. El sitio generado, sin embargo, tiene una estructura modular que es fácil de extender y comprender. Para informacion sobre una mínima aplicación Express, vea el Ejemplo Hello world.\n\n\nUsando el generador de aplicaciones\n\nYa debe haber instalado el generador como parte de Configurar un entorno de desarrollo de Node. Como un rápido recordatorio, la herramienta generador se instala para todos los sitios usando el manejador de paquetes npm, como se muestra:\n\n1\nnpm install express-generator -g\n\n\nEl generador tiene un número de opciones, las cuales puede observar en la línea de comandos usando el comando --help (o bien -h):\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n&gt; express --help\n\n  Usage: express [options] [dir]\n\n  Options:\n\n        --version        output the version number\n    -e, --ejs            add ejs engine support\n        --pug            add pug engine support\n        --hbs            add handlebars engine support\n    -H, --hogan          add hogan.js engine support\n    -v, --view &lt;engine&gt;  add view &lt;engine&gt; support (dust|ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)\n        --no-view        use static html instead of view engine\n    -c, --css &lt;engine&gt;   add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)\n        --git            add .gitignore\n    -f, --force          force on non-empty directory\n    -h, --help           output usage information\n\n\nSimplemente puedes especificar express para crear un proyecto dentro del directorio actual usando el motor de plantillas Jade y CSS plano (si especifica un nombre de directorio entonces el proyecto será creado en un subdirectorio con ese nombre).\n\n1\nexpress\n\n\nTambién puedes seleccionar el motor de plantillas para las vistas usando --view y/o un motor generador de CSS usando --css.\n\n\n  -info- Las otras opciones para elegir motores de plantillas (e.g. --hogan, --ejs, --hbs etc.) están descontinuadas. Use --view (o bien -v)!\n\n\n¿Qué motor de vistas debo usar?\n\nEl Generador de Aplicaciones Express le permite configurar un número de populares motores de plantillas, incluyendo EJS, Hbs, Pug (Jade), Twig, y Vash, aunque si no se especifica una opcion de vista, selecciona Jade por defecto. Express puede soportar un gran número de motores de plantillas aquí una lista.\n\n\n  -info- Si quieres usar un motor de plantillas que no es soportado por el generador entonces échale un vistazo al artículo Usando motores de plantillas con Express (Express docs) y la documentación de su motor de plantillas.\n\n\nGeneralmente hablando debes seleccionar un motor de plantillas que le brinde toda la funcionalidad que necesite y le permita ser productivo rápidamente — o en otras palabras, en la misma forma en que selecciona cualquier otro componente. Alguna de las cosas a considerar cuando se comparan motores de plantillas:\n\n\n  Tiempo de productividad — Si tu equipo ya tiene experiencia con un lenguaje de plantillas entonces es probable que sean más productivos usando ese lenguaje. Si no, debería considerar la curva de aprendizaje relativa del motor de plantillas candidato.\n  Popularidad y actividad — Revise la popularidad del motor y si tiene una comunidad activa. Es importante obtener soporte para el motor cuando tenga problemas durante la vida útil del sitio web.\n  Estilo — Algunos motores de plantillas usan marcas específicas para indicar inserción de contenido dentro del HTML “ordinario”, mientras que otros construyen el HTML usando una sintaxis diferente (por ejemplo, usando indentación (sangría) y nombres de bloque).\n  Tiempo Renderizado/desempeño.\n  \n    Características — debe considerar si los motores que elija poseen las siguientes características disponibles:\n\n    \n      Herencia del diseño: Le permite definir una plantilla base y luego “heredar” sólo las partes que desea que sean diferentes para una página particular. Típicamente esto es un mejor enfoque que construir plantillas incluyendo un número de componentes requeridos, contruyéndolas desde cero cada vez.\n      Soporte para incluir: Le permite construir plantillas incluyendo otras plantillas.\n      Control conciso de la sintaxis de variables y ciclos.\n      Habilidad para filtrar valores de variables a nivel de las plantillas (e.g. convertir variables en mayúsculas, o darle formato a una fecha).\n      Habilidad para generar formatos de salida distintos al HTML (e.g. JSON o XML).\n      Soporte para operaciones asíncronas y de transmisión.\n      Pueden ser usadas tanto en el cliente como en el servidor. Si un motor de plantillas puede ser usado del lado del cliente esto da la posibilidad de servir datos y tener todo o la mayoría del renderizado del lado del cliente.\n    \n  \n\n\n\n  -info- En Internet hay muchos recursos que le ayudarán a comparar diferentes opciones.\n\n\nPara este proyecto usaremos el motor de plantillas Pug (este es el recientemente renombrado motor Jade), ya que es de los más populares lenguajes de plantillas Express/JavaScript y es soportado por el generador por defecto.\n\n¿Qué motor de hojas de estilo CSS debería usar?\n\nEl Generador de Aplicaciones Express le permite crear un proyecto que puede usar los más comunes motores de hojas de estilos CSS: LESS, SASS, Compass, Stylus.\n\n\n  -info- CSS tiene algunas limitaciones que dificultan ciertas tareas. Los motores de hojas de estilos CSS le permiten usar una sintaxis más poderosa para definir su CSS, y luego compilar la definición en texto plano para su uso en los navegadores .\n\n\nComo los motores de plantillas, debería usar el motor CSS que le permita a su equipo ser más productivo. Para este proyecto usaremos CSS ordinario (opción por defecto) ya que nuestros requerimientos no son lo suficientemente complicados para justificar el uso de un motor CSS.\n\n¿Qué base de datos debería usar?\n\nEl código generado no usa o incluye ninguna base de datos. Las aplicaciones Express pueden usar cualquier mecanismo de bases de datos soportado por Node (Express por si mismo no define ningún comportamiento o requerimiento para el manejo de bases de datos).\n\nDiscutiremos la integración con una base de datos en un posterior artículo.\n\nCreando el proyecto\n\nPara el ejemplo que vamos a crear la app Local Library, crearemos un proyecto llamado express-locallibrary-tutorial usando la librería de plantillas Pug y ningún motor CSS.\n\nPrimero navega a donde quieras crear el proyecto y luego ejecute el Generador de Aplicaciones Express en la línea de comandos como se muestra:\n\n1\nexpress express-locallibrary-tutorial --view=pug\n\n\nEl generador creará (y listará) los archivos del proyecto.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n   create : express-locallibrary-tutorial\n   create : express-locallibrary-tutorial/package.json\n   create : express-locallibrary-tutorial/app.js\n   create : express-locallibrary-tutorial/public/images\n   create : express-locallibrary-tutorial/public\n   create : express-locallibrary-tutorial/public/stylesheets\n   create : express-locallibrary-tutorial/public/stylesheets/style.css\n   create : express-locallibrary-tutorial/public/javascripts\n   create : express-locallibrary-tutorial/routes\n   create : express-locallibrary-tutorial/routes/index.js\n   create : express-locallibrary-tutorial/routes/users.js\n   create : express-locallibrary-tutorial/views\n   create : express-locallibrary-tutorial/views/index.pug\n   create : express-locallibrary-tutorial/views/layout.pug\n   create : express-locallibrary-tutorial/views/error.pug\n   create : express-locallibrary-tutorial/bin\n   create : express-locallibrary-tutorial/bin/www\n\n   install dependencies:\n     &gt; cd express-locallibrary-tutorial &amp;&amp; npm install\n\n   run the app:\n     &gt; SET DEBUG=express-locallibrary-tutorial:* &amp; npm start\n\n\nAl final de la lista el generador mostrará instrucciones sobre como instalar las dependencias necesarias (mostradas en el archivo package.json) y luego como ejecutar la aplicación (las instrucciones anteriores son para windows; en Linux/macOS serán ligeramente diferentes).\n\nEjecutando el esqueleto del sitio web\n\nEn este punto tenemos un esqueleto completo de nuestro proyecto. El sitio web no hace mucho actualmente, pero es bueno ejecutarlo para ver como funciona.\n\n\n  \n    Primero instale las dependencias (el comando install recuperará todas las dependencias listadas en sel archivo package.json del proyecto).\n\n    1\n2\n cd express-locallibrary-tutorial\n npm install\n    \n  \n  \n    Luego ejecute la aplicación.\n\n    \n      \n        En Windows, use este comando:\n\n        1\nSET DEBUG=express-locallibrary-tutorial:* &amp; npm start\n        \n      \n      \n        En macOS o Linux, use este comando:\n\n        1\nDEBUG=express-locallibrary-tutorial:* npm start\n        \n      \n    \n  \n  \n    Luego abre en el navegador http://localhost:3000/ para acceder a la aplicación.\n  \n\n\nDeberías ver una página parecida a esta:\n\n\n\nTienes una aplicación Express funcional, ejecutándose en localhost:3000.\n\n\n  -info- También podrías ejecutar la app usando el comando npm start. Especificado la variable DEBUG como se muestra para habilitar el logging/debugging por consola. Por ejemplo, cuando visites la página mostrada arriba verás la información de depuración como esta:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n$ SET DEBUG=express-locallibrary-tutorial:* &amp;#x26; npm start\n\n$ express-locallibrary-tutorial@0.0.0 start D:\\express-locallibrary-tutorial\n$ node ./bin/www\n\nexpress-locallibrary-tutorial:server Listening on port 3000 +0ms\nGET / 200 288.474 ms - 170\nGET /stylesheets/style.css 200 5.799 ms - 111\nGET /favicon.ico 404 34.134 ms - 1335\n  \n\n\nHabilita el reinicio del servidor cuando los archivos sean modificados\n\nCualquier cambio que le haga a su sitio web Express no será visible hasta que reinicie el servidor. Tener que detener y reiniciar el servidor cada vez que hacemos un cambio, se vuelve irritante, así que es beneficioso tomarse un tiempo y automatizar el reinicio del servidor cuando sea necesario.\n\nUna de las herramientas más sencillas para este propósito es nodemon. Éste usualmente se instala globalmente (ya que es una “herramienta”), pero aquí lo instalaremos y usaremos localmente como una dependencia de desarrollo, así cualquier desarrollador que esté trabajando con el proyecto lo obtendrá automáticamente cuando instale la aplicación. Usa el siguiente comando en el directorio raíz del esqueleto del proyecto:\n\n1\nnpm install --save-dev nodemon\n\n\nSi abres el archivo package.json de tu proyecto verás una nueva sección con esta dependencia:\n\n1\n2\n3\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.20\"\n  }\n\n\nDebido a que la herramienta no fue instalada globalmente no podemos ejecutarla desde la línea de comandos (a menos que la agreguemos a la ruta) pero podemos llamarla desde un script npm porque npm sabe todo sobre los paquetes instalados. Busca la sección scripts de tu package.json. Inicialmente contendrá una línea, la cual comienza con \"start\". Actualízala colocando una coma al final de la línea, y agregue la línea \"devstart\" mostrada abajo:\n\n1\n2\n3\n4\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n\n\nAhora podemos iniciar el servidor casi exactamente como antes, pero especificando el comando devstart:\n\n\n  \n    En Windows, use este comando:\n\n    1\nSET DEBUG=express-locallibrary-tutorial:* &amp; npm run devstart\n    \n  \n  \n    En macOS or Linux, use este comando:\n\n    1\nDEBUG=express-locallibrary-tutorial:* npm run devstart\n    \n  \n\n\n\n  -info Ahora si modificas cualquier archivo del proyecto el servidor se reiniciará. Aún necesitarás recargar el navegador para refrescar la página.\n\n  Ahora tendremos que llamar “npm run &lt;nombre del script&gt;” en vez de npm start, porque “start” es actualmente un comando npm que es mapeado al nombre del script. Podríamos haber reemplazado el comando en el script start pero sólo queremos usar nodemon durante el desarrollo, así que tiene sentido crear un nuevo script para este comando.\n\n\nEl proyecto generado\n\nObservemos el proyecto que hemos creado.\n\nEstructura del directorio\n\nEl proyecto generado, ahora que has instalado las dependencias, tiene la siguiente estructura de archivos (los archivos son los elementos que no están precedidos con “/”). El archivo package.json define las dependencias de la aplicación y otra información. También define un script de inicio que es el punto de entrada de la aplicación, el archivo JavaScript /bin/www. Éste establece algunos de los manejadores de error de la aplicación y luego carga el archivo app.js para que haga el resto del trabajo. Las rutas se almacenan en módulos separados en el directorio /routes. las plantillas se almacenan en el directorio /views.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n/express-locallibrary-tutorial\n    app.js\n    /bin\n        www\n    package.json\n    /node_modules\n        [about 4,500 subdirectories and files]\n    /public\n        /images\n        /javascripts\n        /stylesheets\n            style.css\n    /routes\n        index.js\n        users.js\n    /views\n        error.pug\n        index.pug\n        layout.pug\n\n\nLas siguientes secciones describen los archivos con más detalle.\n\npackage.json\n\nEl archivo package.json define las dependencias de la aplicación y otra información:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"name\": \"express-locallibrary-tutorial\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.18.2\",\n    \"cookie-parser\": \"~1.4.3\",\n    \"debug\": \"~2.6.9\",\n    \"express\": \"~4.16.2\",\n    \"morgan\": \"~1.9.0\",\n    \"pug\": \"~2.0.0-rc.4\",\n    \"serve-favicon\": \"~2.4.5\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^1.14.11\"\n  }\n}\n\n\nLas dependencias incluyen el paquete express y los paquetes para el motor de plantillas elegido (pug). Adicionalmente, tenemos los siguientes paquetes que son útiles en muchas aplicaciones web:\n\n\n  body-parser: Esto analiza la parte del cuerpo de una solicitud HTTP entrante y facilita la extracción de diferentes partes de la información contenida. Por ejemplo, puede usar esto para leer los parámetros POST.\n  cookie-parser: Se utiliza para analizar el encabezado de la cookie y rellenar req.cookies (esencialmente proporciona un método conveniente para acceder a la información de la cookie).\n  debug: Una pequeña utilidad de depuración de node modelada a partir de la técnica de depuración del núcleo de node.\n  morgan: Un middleware registrador de solicitudes HTTP para node.\n  serve-favicon: Middleware de node para servir un favicon (este es el icono utilizado para representar el sitio dentro de la pestaña del navegador, marcadores, etc.).\n\n\nLa sección de scripts define un script de “start”, que es lo que invocamos cuando llamamos a npm start para iniciar el servidor. Desde la definición del script, puede ver que esto realmente inicia el archivo JavaScript ./bin/www con node. También define un script “devstart”, que invocamos cuando llamamos a npm run devstart en su lugar. Esto inicia el mismo archivo ./bin/www, pero con nodemon en lugar de node.\n\n1\n2\n3\n4\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"devstart\": \"nodemon ./bin/www\"\n  },\n\nEste archivo es el equivalente a composer.json en Symfony\nEl archivo www\n\nEl archivo /bin/www es el punto de entrada de la aplicación. Lo primero que hace es require() del punto de entrada de la aplicación “real” (app.js, en la raíz del proyecto) que configura y devuelve el objeto de la aplicación express ().\n\n1\n2\n3\n4\n5\n6\n7\n#!/usr/bin/env node\n\n/**\n * Module dependencies.\n */\n\nvar app = require('../app');\n\n\n\n  -info- require() es una función de node global que se usa para importar módulos en el archivo actual. Aquí especificamos el módulo app.js utilizando una ruta relativa y omitiendo la extensión de archivo opcional (.js).\n\n\nEl resto del código en este archivo configura un servidor HTTP de node con la aplicación configurada en un puerto específico (definido en una variable de entorno o 3000 si la variable no está definida), y comienza a escuchar e informar errores y conexiones del servidor.\n\napp.js\n\nEste archivo crea un objeto de aplicación rápida, configura la aplicación con varias configuraciones y middleware, y luego exporta la aplicación desde el módulo. El siguiente código muestra solo las partes del archivo que crean y exportan el objeto de la aplicación:\n\n1\n2\n3\n4\nvar express = require('express');\nvar app = express();\n...\nmodule.exports = app;\n\n\nDe vuelta en el archivo de punto de entrada www anterior, es este objeto module.exports que se proporciona al llamante cuando se importa este archivo.\n\nPermite trabajar a través del archivo app.js en detalle. Primero importamos algunas bibliotecas de node útiles en el archivo usando require (), incluyendo express, serve-favicon, morgan, cookie-parser y body-parser que previamente descargamos para nuestra aplicación usando npm; y path, que es una biblioteca central de nodos para analizar rutas de archivos y directorios.\n\n1\n2\n3\n4\n5\n6\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\n\n\nLuego require() carga los módulos de nuestro directorio de rutas. Estos modules/files contienen código para manejar conjuntos particulares de “routes” relacionadas (rutas URL). Cuando extendemos la aplicación esqueleto, por ejemplo, para enumerar todos los libros de la biblioteca, agregaremos un nuevo archivo para tratar las rutas relacionadas con los libros.\n\n1\n2\nvar index = require('./routes/index');\nvar users = require('./routes/users');\n\n\n\n  -warning– En este punto, acabamos de importar el módulo; aún no hemos utilizado sus rutas (esto sucede un poco más abajo en el archivo).\nA continuación, creamos el objeto app usando nuestro módulo express importado y luego lo usamos para configurar el motor de vista (plantilla). Hay dos partes para configurar el motor. Primero establecemos el valor ‘views’ para especificar la carpeta donde se almacenarán las plantillas (en este caso, la subcarpeta /views). Luego establecemos el valor de view engine para especificar la biblioteca de plantillas (en este caso, “pug”).\n\n\n1\n2\n3\n4\n5\nvar app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');\n\nEl siguiente conjunto de funciones llama a app.use() para agregar las bibliotecas middleware a la cadena de manejo de solicitudes. Además de las bibliotecas de terceros que importamos anteriormente, usamos el middleware express.static para que Express sirva todos los archivos estáticos en el directorio /public en la raíz del proyecto.\n\n1\n2\n3\n4\n5\n6\n7\n// uncomment after placing your favicon in /public\n//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\nAhora que todo el otro middleware está configurado, agregamos nuestro código de manejo de rutas (previamente importado) a la cadena de manejo de solicitudes. El código importado definirá rutas particulares para las diferentes partes del sitio:\n\n1\n2\napp.use('/', index);\napp.use('/users', users);\n\nEl último middleware del archivo agrega métodos de controlador para errores y respuestas HTTP 404.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// catch 404 and forward to error handler\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\n\n// error handler\napp.use(function(err, req, res, next) {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\n\nEl objeto de la aplicación Express (aplicación) ahora está completamente configurado. El último paso es agregarlo a las exportaciones del módulo (esto es lo que permite que sea importado por /bin/www).\n\n1\nmodule.exports = app;\n\n\nRutas\n\nEl archivo de ruta /routes/users.js se muestra a continuación (los archivos de ruta comparten una estructura similar, por lo que no necesitamos mostrar también index.js). Primero carga el módulo express y lo usa para obtener un objeto express.Router. Luego, especifica una ruta en ese objeto y, por último, exporta el enrutador desde el módulo (esto es lo que permite importar el archivo a app.js).\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvar express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n\nLa ruta define una devolución de llamada que se invocará cada vez que se detecte una solicitud HTTP GET con el patrón correcto. El patrón coincidente es la ruta especificada cuando se importa el módulo (‘/users’) más lo que esté definido en este archivo (‘/’). En otras palabras, esta ruta se utilizará cuando se reciba una URL de /users/.\n\n\n  -info- Pruébalo ejecutando el servidor con node y visitando la URL en el navegador: http://localhost:3000/users/. Deberías ver un mensaje: ‘respond with a resource’.\nUna cosa de interés anterior es que la función de devolución de llamada tiene el tercer argumento next y, por lo tanto, es una función de middleware en lugar de una simple devolución de llamada de ruta. Si bien el código actualmente no usa el argumento next, puede ser útil en el futuro si desea agregar varios controladores de ruta a la ruta de ruta '/'.\n\n\nVistas (templates)\n\nLas vistas (plantillas) se almacenan en el directorio /views (como se especifica en app.js) y reciben la extensión de archivo .pug. El método Response.render() se usa para representar una plantilla específica junto con los valores de las variables con nombre pasadas en un objeto y, a continuación, envía el resultado como respuesta. En el siguiente código de /routes/index.js, puedes ver cómo esa ruta genera una respuesta usando la plantilla “index” pasando la variable de plantilla “title”.\n\n1\n2\n3\n4\n/* GET home page. */\nrouter.get('/', function(req, res) {\n  res.render('index', { title: 'Express' });\n});\n\nLa plantilla correspondiente para la ruta anterior se proporciona a continuación (index.pug). Hablaremos más sobre la sintaxis más adelante. Todo lo que necesitas saber por ahora es que la variable title (con el valor 'Express') se inserta donde se especifica en la plantilla.\n\n1\n2\n3\n4\n5\nextends layout\n\nblock content\n  h1= title\n  p Welcome to #{title}\n\n\nReto\n\n\n  -reto-Crea una nueva ruta en routes/users.js que mostrará el texto “You are so cool” en la URL /users/cool/. Pruébalo ejecutando el servidor y visitando http://localhost:3000/users/cool/ en tu navegador\n\n\n",
        "url": "/node-express-library-teoria/esqueleto-de-la-aplicacion"
      }
      ,
    
      "sitio-web-biblioteca": {
        "title": "Tutorial Express - parte 1: Sitio web Biblioteca",
        "content": "El primer artículo de nuestra serie de tutoriales prácticos explica lo que aprenderá y proporciona una descripción general del sitio web de ejemplo de la “biblioteca local” en el que trabajaremos y evolucionaremos en artículos posteriores.\n\n\n  \n    \n      Prerequisitos:\n      \n        Leer la\n        Introducción a Express.\n        Para los siguientes artículos, también deberá haber\n          configurado un entorno de desarrollo de Node.\n      \n    \n    \n      Objetivo:\n      \n        Presentar la aplicación de ejemplo utilizada en este tutorial, y\n            permitir a los lectores comprender qué temas se tratarán.\n      \n    \n  \n\n\nVisión General\n\nBienvenido al tutorial de MDN “Biblioteca Local” Express (Node), en el cual desarrollamos un sitio web que podría usarse para administrar el catálogo de una biblioteca local.\n\nEn esta serie de artículos tutoriales, usted:\n\n\n  Usará la herramienta Express Application Generator para crear un sitio web esquemático y una aplicación.\n  Iniciará y detendrá el servidor web Node.\n  Usará una base de datos para almacenar los datos de la aplicación.\n  Creará rutas para solicitar diferente información y plantillas (“vistas”) para representar los datos como HTML para que se muestren en el navegador\n  Trabajará con formularios\n  Implementará su aplicación en producción\n\n\nYa se ha aprendido sobre algunos de estos temas y se ha referido brevemente a otros. Al final de la serie de tutoriales, debe saber lo suficiente como para desarrollar aplicaciones Express simples usted mismo.\n\nThe LocalLibrary website\n\nLocalLibrary es el nombre del website que vamos a desarrollar en esta serie de tutoriales. Tal como esperas, el objetivo del website es proveer un catalogo online para una pequeña libreria, donde los usuarios exploren los libros disponibles y administren sus cuentas.\n\nEste ejemplo ha sido cuidadosamente elegido porque puede escalarse para mostrar tantos o pocos detalles como necesitemos, de igual forma puede usarse para presentar casi todas las caracteristicas de Express. Mas importante aún, nos permite proporcionar una ruta guiada a traves de la funcionalidad que necesita cualquier sitio web:\n\n\n  En los primeros articulos definiremos una biblioteca simple, unicamente de navegacion, que los miembros de la biblioteca usaran para saber que libros estan disponibles. Esto permite explorar las operationes mas comunes de los sitios web: lectura y presentacion de contenido de una base de datos.\n  A medida que avancemos, el ejemplo de la biblioteca se extenderá naturalmente para mostrar las caracteristicas mas avanzadas del sitio web. Por ejemplo, podemos extender la biblioteca para que se creen nuevos libros, de esta manera conoceremos como usar los formularios (forms) y la autenticacion de usuarios.\n\n\nAunque este ejemplo se puede extender mucho mas, se llama LocalLibrary por una razón , esperamos mostrar informacion minima que le ayudara a comenzar a utilizar Express rapidamente. Como resultado, almacenaremos informacion acerca de libros, copias de libros, autores y otra informacion clave. Sin embargo, no almacenaremos informacion sobre otros elementos que una biblioteca pueda tener, o proveer la infraestructura necesaria para soportar multiples sitios u otras caracteristicas de grandes bibliotecas.\n\nEstoy atascado, donde puedo obtener el codigo fuente?\n\nA medida que avance, le proporcionaremos los fragmentos de codigo adecuado para que usted los copie y pegue en cada punto, ademas, habrá otro código con el proposito de que usted lo complete para afianzar su conocimiento (con alguna orientacion).\n\nSi aun asi sigues atasaco, puedes encontrar la version completamente desarrollada del sitio web en Github aqui.\n\n\n  Nota: Las versiones especificas de node, Express, y los otros modulos con los que se probó esta documentación estan enumeradas en el projecto package.json.\n\n\n",
        "url": "/node-express-library-teoria/sitio-web-biblioteca"
      }
      ,
    
      "entorno-desarrollo-node-express": {
        "title": "Crear un entorno de desarrollo",
        "content": "Ahora que sabes para que sirve Express,  vamos a mostrar como preparar y testear un entorno de desarrollo Node/Express en: Windows, Linux (Ubuntu), y macOS. Este artículo te va a dar todo lo que se necesita para poder empezar a desarrollar apps en Express, sin importar el sistema operativo que se use.\n\n\n  \n    \n      Prerequisitos:\n      \n        Saber como abrir una terminal / línea de comando. Saber como instalar\n        paquetes de software en su sistema operativo de su computadora de\n        desarrollo.\n      \n    \n    \n      Objectivo:\n      \n        Configurar un entorno de desarrollo para Express (X.XX) en su\n        computadora.\n      \n    \n  \n\n\nNotas acerca del entorno de desarrollo\n\nNode y Express hacen muy fácil configurar su computadora con el propósito de iniciar el desarrollo de aplicaciones web. Esta sección provee unas notas acerca de qué herramientas son necesarias, explica algunos de los métodos más simples para instalar Node (y Express) en Ubuntu, macOS y Windows, y muestra como puede probar su instalación.\n\nQué es el entorno de desarrollo Express?\n\nEl entorno de desarrollo Express incluye una instalación de Nodejs, el npm administrador de paquetes, y (opcionalmente) el Generador de Aplicaciones de Express en su computadora local.\n\nNode y el administrador de paquetes npm se instalan juntos desde paquetes binarios, instaladores, administradores de paquetes del sistema operativo o desde los fuentes (como se muestra en las siguientes secciones). Express es entonces instalado por npm como una dependencia individual de sus aplicaciones web Express (conjuntamente con otras librerías como motores de plantillas, controladores de bases de datos, middleware de autenticación, middleware para servir archivos estáticos, etc.)\n\nnpm puede ser usado también para (globalmente) instalar el Generador de Aplicaciones de Express, una herramienta manual para crear la estructura de las web apps de Express que siguen el patrón MVC. El generador de aplicaciones es opcional porque no necesita utilizar esta herramienta para crear apps que usan Express, o construir apps Express que tienen el mismo diseño arquitectónico o dependencias. No obstante estaremos usandolo, porque hace mucho más fácil, y promueve una estructura modular de aplicación.\n\n\n  -info-A diferencia de otros frameworks web , el entorno de desarrollo no incluye un servidor web independiente. Una aplicación web Node/Express crea y ejecuta su propio servidor web!\n\n\nHay otras herramientas periféricas que son parte de un entorno de desarrollo típico, incluyendo editores de texto o IDEs para edición de código, y herramientas de administración de control de fuentes como Git para administrar con seguridad diferentes versiones de su código. Asumimos que usted ya tiene instaladas esta clase de herramientas (en particular un editor de texto).\n\nQué sistemas operativos son soportados?\n\nNode puede ser ejecutado en Windows, macOS, varias “versiones” de Linux, Docker, etc. (hay una lista completa de paginas de Downloads de nodejs). Casi cualquier computadora personal podría tener el desempeño necesario para ejecutar Node durante el desarrollo. Express es ejecutado en un entorno Node, y por lo tanto puede ejecutarse en cualquier plataforma que ejecute Node.\n\nEn este articulo proveemos instrucciones para configurarlo para Windows, macOS, and Ubuntu Linux.\n\n¿Qué versión de Node/Express puedo usar?\n\nHay varias versiones de Node — recientes que contienen reparaciones de bugs, soporte para versiones mas recientes de ECMAScript (JavaScript) estándares, y mejoras a las APIs de Node .\n\nGeneralmente se debe usar la versión más reciente LTS (Long Term Support), una versión como esta es más estable que la versión “actual”, mientras que sigue teniendo características relativamente recientes (y continua siendo activamente actualizado). Debería utilizar la versión Actual si necesita una característica que no esta presente en la versión LTS.\n\nPara Express siempre se debe utilizar la versión más reciente.\n\n¿Qué pasa con bases de datos y otras dependencias?\n\nOtras dependencias, tales como los controladores de bases de datos, motores de plantillas, motores de autenticación, etc. son parte de la aplicación, y son importadas dentro del entorno de la aplicación utilizando el administrador de paquetes npm.\n\nInstalar Node\n\nPara poder utilizar Express primero tienes que instalar Nodejs y el Administrador de Paquetes de Node (npm) en su sistema operativo. Las siguientes secciones explican la forma más fácil de instalar la versión Soporte de Largo-Plazo (LTS) de Nodejs en Ubuntu Linux 16.04, macOS, y Windows 10.\n\n\n  -info-Las secciones de abajo muestran la forma más fácil de instalar Node y npm en nuestras plataformas de sistemas operativo a elegir. Si esta utilizando otro SO o solo quiere ver alguna de otros enfoques para las plataformas actuales entonce vea Instalando Node.js via administrador de paquetes (nodejs.org).\n\n\nmacOS y Windows\n\nInstalar Node y npm en Windows y macOS es sencillo, porque simplemente debe utilizar el instalador provisto:\n\n\n  \n    Descargue el instalador requerido:\n\n    \n      Vaya a https://nodejs.org/es/\n      Seleccione el botón para descargar la versión LTS que es “Recomendada la mayoría de los usuarios”.\n    \n  \n  \n    Instala Node al dar doble-clic en el archivo de descarga y en seguida la instalación inicia.\n  \n\n\nUbuntu 20.04\n\nLa forma más fácil de instalar la versión LTS de Node es la usar el administrador de paquetes para obtenerlo del repositorio de distribuciones binarias de Ubuntu. Esto puede ser hecho muy simple al ejecutar los siguientes dos comandos en tu terminal:\n\n1\n2\ncurl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n\n\n  -warning-No instales directamente desde los repositorios normales de Ubuntu porque pueden contener versiones muy antiguas de Node.\n\n\nProbar su instalación de Nodejs y npm\n\nLa forma más fácil de probar que Node está instalado es ejecutar el comando “version” en su prompt de terminal/command y checar que una cadena de versión es devuelta:\n\n1\n2\n&gt;node -v\nv16.17.1\n\n\nEl administrador de paquetes npm de Nodejs también debería haber sido instalado y puede ser probado de la misma forma:\n\n1\n2\n&gt;npm -v\n8.19.2\n\n\nComo una prueba un poco más emocionante creemos un muy básico “servidor node” que simplemente imprima “Hola Mundo” en el navegador cuando visite la URL correcta en él:\n\n\n  \n    Copia el siguiente texto en un archivo llamado holanode.js. Este utiliza características básicas de Node (nada desde Express) y algo de sintaxis ES6:\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n //Load HTTP module\n const http = require(\"http\");\n const hostname = '127.0.0.1';\n const port = 3000;\n    \n //Create HTTP server and listen on port 3000 for requests\n const server = http.createServer((req, res) =&gt; {\n    \n   //Set the response HTTP header with HTTP status and Content type\n   res.statusCode = 200;\n   res.setHeader('Content-Type', 'text/plain');\n   res.end('Hello World\\n');\n });\n    \n //listen for request on port 3000, and as a callback function have the port listened on logged\n server.listen(port, hostname, () =&gt; {\n   console.log(`Server running at http://${hostname}:${port}/`);\n });\n    \n\n    El código importa el módulo “http” y lo usa para crear un servidor (createServer()) que escucha las solicitudes HTTP en el puerto 3000. Luego, el script imprime un mensaje en la consola con la URL del navegador que se puede usar para probar el servidor. La función createServer() toma como argumento una función callback que se invocará cuando se reciba una solicitud HTTP — esto simplemente devuelve una respuesta con un código de estado HTTP de 200 (“OK”) y el texto sin formato “Hello World”.\n\n    \n      -info-¡No te preocupes si aún no comprendes exactamente lo que está haciendo este código! ¡Explicaremos nuestro código con mayor detalle una vez que comencemos a usar Express!\n    \n  \n  \n    Inicia el servidor navegando en el mismo directorio que su archivo hellonode.js en su símbolo del sistema, y llamando a node junto con el nombre del script, así:\n\n    1\n2\n &gt;node hellonode.js\n Server running at http://127.0.0.1:3000/\n    \n  \n  \n    Navega a la URL http://127.0.0.1:3000. Sí todo esta funciona, el navegador simplemente debe mostrar la cadena de texto “Hello World”.\n  \n\n\nUsando npm\n\nJunto al propio node, npm es la herramienta más importante para trabajar con aplicaciones de node. npm se usa para obtener los paquetes (bibliotecas de JavaScript) que una aplicación necesita para el desarrollo, las pruebas y/o la producción, y también se puede usar para ejecutar pruebas y herramientas utilizadas en el proceso de desarrollo.\n\n\n  -info-Desde la perspectiva de Node, Express es solo otro paquete que necesita instalar usando npm y luego requerir en su propio código.\n\n\nSe puede usar npm manualmente para buscar por separado cada paquete necesario. Por lo general, administramos las dependencias utilizando un archivo de definición de texto plano llamado package.json. Este archivo enumera todas las dependencias para un “paquete” de JavaScript específico, incluido el nombre del paquete, la versión, la descripción, el archivo inicial a ejecutar, las dependencias de producción, las dependencias de desarrollo, las versiones de Node con las que puede trabajar, etc. El archivo package.json debería contener todo lo que npm necesita para buscar y ejecutar su aplicación (si estuviera escribiendo una biblioteca reutilizable, podría usar esta definición para cargar su paquete en el repositorio npm y ponerlo a disposición de otros usuarios).\n\nAgregando dependencias\n\nLos siguientes pasos muestran cómo puede usar npm para descargar un paquete, guardarlo en las dependencias del proyecto y luego requerirlo en una aplicación Node.\n\n\n  -info-Aquí mostramos las instrucciones para buscar e instalar el paquete Express. Más adelante mostraremos cómo este paquete y otros ya están especificados para nosotros utilizando el Generador de aplicaciones Express. Esta sección se proporciona porque es útil para comprender cómo funciona npm y qué está creando el generador de aplicaciones.\n\n\n\n  \n    Primero crea un directorio para su nueva aplicación y acceda a él:\n\n    1\n2\n mkdir myapp\n cd myapp\n    \n  \n  \n    Usa el comando npm init para crear un archivo package.json para su aplicación. Este comando te solicita varias cosas, incluido el nombre y la versión de su aplicación y el nombre del archivo de punto de entrada inicial (de forma predeterminada, esto es index.js). Por ahora, solo acepta los valores predeterminados:\n\n    1\n npm init\n    \n\n    Si muestras el archivo package.json (cat package.json), verás los valores predeterminados que aceptó, que finalizarán con la licencia.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n {\n   \"name\": \"myapp\",\n   \"version\": \"1.0.0\",\n   \"description\": \"\",\n   \"main\": \"index.js\",\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n   },\n   \"author\": \"\",\n   \"license\": \"ISC\"\n }\n    \n  \n  \n    Ahora instala Express en el directorio myapp y guárdalo en la lista de dependencias de su archivo package.json\n\n    1\n npm install express --save\n    \n\n    La sección de dependencias de su package.json ahora aparecerá al final del archivo package.json e incluirá Express.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n {\n   \"name\": \"myapp\",\n   \"version\": \"1.0.0\",\n   \"description\": \"\",\n   \"main\": \"index.js\",\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n   },\n   \"author\": \"\",\n   \"license\": \"ISC\",\n   \"dependencies\": {\n     \"express\": \"^4.16.3\"\n   }\n }\n    \n  \n  \n    Para usar la biblioteca, llama a la función require() como se muestra a continuación en tu archivo index.js.\n Crea un archivo llamado index.js en la raíz del directorio de la aplicación “myapp” con el contenido que se muestra a continuación.\n\n    1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n const express = require('express')\n const app = express();\n\n app.get('/', (req, res) =&gt; {\n   res.send('Hello World!')\n });\n\n app.listen(8000, () =&gt; {\n   console.log('Example app listening on port 8000!')\n });\n    \n\n    Este código muestra una aplicación web mínima “HelloWorld” Express. Esto importa el módulo “express” y lo usa para crear un servidor (app) que escucha las solicitudes HTTP en el puerto 8000 e imprime un mensaje en la consola que indica qué URL del navegador puede usar para probar el servidor. La función app.get () solo responde a las solicitudes HTTP GET con la ruta URL especificada ('/'), en este caso llamando a una función para enviar nuestro mensaje Hello World! .\n  \n  \n    Puedes iniciar el servidor llamando a node con el script en su símbolo del sistema:\n\n    1\n2\n &gt;node index.js\n Example app listening on port 8000\n    \n  \n  \n    Navega a la URL (http://127.0.0.1:8000/). Sí todo esta funciona, el navegador simplemente debe mostrar la cadena de texto “Hello World”.\n  \n\n\nDependencias de Desarrollo\n\nSi una dependencia solo se usa durante el desarrollo, debes guardarla como una “dependencia de desarrollo” (para que los usuarios de su paquete no tengan que instalarla en producción). Por ejemplo, para usar la popular herramienta Linting JavaScript eslint llamarías a npm como se muestra a continuación:\n\n1\nnpm install eslint --save-dev\n\n\nLa siguiente entrada se agregaría al paquete.json de su aplicación:\n\n1\n2\n3\n  \"devDependencies\": {\n    \"eslint\": \"^4.12.1\"\n  }\n\n\n\n  -info-“Linters” son herramientas que realizan análisis estáticos en el software para reconocer e informar la adhesión / no adhesión a algún conjunto de mejores prácticas de codificación.\n\n\nEjecutando tareas\n\nAdemás de definir y buscar dependencias, también puedes definir scripts con nombre en sus archivos package.json y llamar a npm para ejecutarlos con el comando run-script. Este enfoque se usa comúnmente para automatizar las pruebas en ejecución y partes de la cadena de herramientas de desarrollo o construcción (por ejemplo, ejecutar herramientas para minimizar JavaScript, reducir imágenes, LINT/analizar su código, etc.).\n\n\n  -info-Los ejecutadores de tareas como Gulp y Grunt también se pueden usar para ejecutar pruebas y otras herramientas externas.\n\n\nPor ejemplo, para definir un script para ejecutar la dependencia de desarrollo de eslint que especificamos en la sección anterior, podríamos agregar el siguiente bloque de script a nuestro archivo package.json (suponiendo que el origen de nuestra aplicación esté en una carpeta /src/js):\n\n1\n2\n3\n4\n5\n\"scripts\": {\n  ...\n  \"lint\": \"eslint src/js\"\n  ...\n}\n\n\nPara explicar un poco más, eslint src/js es un comando que podríamos ingresar en nuestra línea de terminal/linea de comandos para ejecutar eslint en archivos JavaScript contenidos en el directorio src/js dentro de nuestro directorio de aplicaciones. Incluir lo anterior dentro del archivo package.json de nuestra aplicación proporciona un acceso directo para este comando: lint.\n\nEntonces podríamos ejecutar eslint usando npm llamando a:\n\n1\n2\n3\nnpm run-script lint\n# OR (using the alias)\nnpm run lint\n\n\nEs posible que este ejemplo no parezca más corto que el comando original, pero puede incluir comandos mucho más grandes dentro de sus scripts npm, incluidas cadenas de comandos múltiples. Puede identificar un solo script npm que ejecute todas sus pruebas a la vez.\n\nInstalando Express Application Generator\n\nLa herramienta Express Application Generator genera un “esqueleto” de la aplicación Express. Instala el generador usando npm como se muestra (el indicador -g instala la herramienta globalmente para que pueda llamarla desde cualquier lugar):\n\n1\nnpm install express-generator -g\n\n\nPara crear una aplicación Express llamada “helloworld” con la configuración predeterminada, navegue hasta donde desea crearla y ejecute la aplicación como se muestra:\n\n1\nexpress helloworld\n\n\n\n  -info-También puedes especificar la biblioteca de plantillas para usar y una serie de otras configuraciones. Usa el comando --help para ver todas las opciones:\n\n  1\nexpress --help\n  \n\n\nnpm creará la nueva aplicación Express en una subcarpeta de su ubicación actual, mostrando el progreso de la compilación en la consola. Al finalizar, la herramienta mostrará los comandos que necesita ingresar para instalar las dependencias de Node e iniciar la aplicación.\n\n\n  -info-La nueva aplicación tendrá un archivo package.json en su directorio raíz. Puede abrir esto para ver qué dependencias están instaladas, incluidas Express y la biblioteca de plantillas Jade (pug):\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n{\n  \"name\": \"helloworld\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\"\n  },\n  \"dependencies\": {\n    \"body-parser\": \"~1.18.2\",\n    \"cookie-parser\": \"~1.4.3\",\n    \"debug\": \"~2.6.9\",\n    \"express\": \"~4.15.5\",\n    \"jade\": \"~1.11.0\",\n    \"morgan\": \"~1.9.0\",\n    \"serve-favicon\": \"~2.4.5\"\n  }\n}\n  \n\n\nInstala todas las dependencias para la aplicación helloworld usando npm como se muestra:\n\n1\n2\ncd helloworld\nnpm install\n\n\nLuego ejecuta la aplicación (los comandos son ligeramente diferentes para Windows y Linux/macOS), como se muestra a continuación:\n\n1\n2\n3\n4\n5\n6\n7\n8\n#  Ejecute helloworld en Windows con símbolo del sistema\nSET DEBUG=helloworld:* &amp; npm start\n\n#  Ejecute helloworld en Windows con PowerShell\nSET DEBUG=helloworld:* | npm start\n\n#  Ejecute helloworld en Linux/macOS\nDEBUG=helloworld:* npm start\n\n\nEl comando DEBUG crea registros útiles, lo que resulta en una salida como la que se muestra a continuación.\n\n1\n2\n3\n4\n5\n6\n&gt;SET DEBUG=helloworld:* &amp; npm start\n\n&gt; helloworld@0.0.0 start D:\\Github\\expresstests\\helloworld\n&gt; node ./bin/www\n\n  helloworld:server Listening on port 3000 +0ms\n\n\nAbre un navegador y navegue a http://127.0.0.1:3000/ para ver la página de bienvenida Express predeterminada.\n\n\n\nHablaremos más sobre la aplicación generada cuando lleguemos al artículo sobre la generación de una aplicación esqueleto.\n\nResumen\n\nAhora tiene un entorno de desarrollo de Node en funcionamiento en su computadora que puede usarse para crear aplicaciones web Express. También ha visto cómo se puede usar npm para importar Express en una aplicación, y también cómo puede crear aplicaciones usando la herramienta Express Application Generator y luego ejecutarlas.\n\nEn el siguiente artículo, comenzaremos a trabajar a través de un tutorial para crear una aplicación web completa utilizando este entorno y las herramientas asociadas.\n\nVer también\n\n\n  Downloads page (nodejs.org)\n  Installing Node.js via package manager (nodejs.org)\n  Installing Express (expressjs.com)\n  Express Application Generator (expressjs.com)\n\n\n",
        "url": "/node-express-library-teoria/entorno-desarrollo-node-express"
      }
      ,
    
      "node-introduccion": {
        "title": "Introducción",
        "content": "En este primer articulo de Express resolveremos las preguntas “¿Qué es Node?” y “¿Qué es Express?”, y te daremos una visión general de que hace especial al framework web “Express”. Delinearemos las características principales, y te mostraremos algunos de los principales bloques de construcción de una aplicación en Express (aunque en este punto no tendrás todavía un entorno de desarrollo en que probarlo).\n\n\n  \n    \n      Pre-requisitos:\n      \n        \n          Conocimientos básicos de informática. Noción general sobre\n          programación lado servidor de sitios web, y en particular los mecanismos de las interacciones\n          cliente-servidor en sitios web.\n        \n      \n    \n    \n      Objetivo:\n      \n        \n          Ganar familiaridad con lo que es Express y cómo encaja con Node, qué\n          funcionalidad proporciona y los pilares de construcción de una\n          aplicación Express.\n        \n      \n    \n  \n\n\nInstalación de node\n\nPara instalar node.js\n\n1\n2\ncurl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n\nY para instalar el gestor de paquetes nmp\n\n1\nsudo apt install npm\n\n\nAdemás vamos a instalar nodemon  para que rearranque automáticamente el servidor al realizar cualquier cambio en un archivo de la aplicación.\n\n1\nsudo npm install -g nodemon\n\n\n¿Qué son Express y Node?\n\nNode (o más correctamente: Node.js) es un entorno que trabaja en tiempo de ejecución, de código abierto, multi-plataforma, que permite a los desarrolladores crear toda clase de herramientas de lado servidor y aplicaciones en JavaScript. La ejecución en tiempo real está pensada para usarse fuera del contexto de un explorador web (es decir, ejecutarse directamente en una computadora o sistema operativo de servidor). Como tal, el entorno omite las APIs de JavaScript específicas del explorador web y añade soporte para APIs de sistema operativo más tradicionales que incluyen HTTP y bibliotecas de sistemas de ficheros.\n\nDesde una perspectiva de desarrollo de servidor web, Node tiene un gran número de ventajas:\n\n\n  ¡Gran rendimiento! Node ha sido diseñado para optimizar el rendimiento y la escalabilidad en aplicaciones web y es un muy buen complemento para muchos problemas comunes de desarrollo web (ej, aplicaciones web en tiempo real).\n  El código está escrito en “simple JavaScript”, lo que significa que se pierde menos tiempo ocupándose de las “conmutaciones de contexto” entre lenguajes cuando estás escribiendo tanto el código del explorador web como del servidor.\n  JavaScript es un lenguaje de programación relativamente nuevo y se beneficia de los avances en diseño de lenguajes cuando se compara con otros lenguajes de servidor web tradicionales (ej, Python, PHP, etc.) Muchos otros lenguajes nuevos y populares se compilan/convierten a JavaScript de manera que puedes también usar CoffeeScript, ClosureScript, Scala, LiveScript, etc.\n  El gestor de paquetes de Node (NPM del inglés: Node Packet Manager) proporciona acceso a cientos o miles de paquetes reutilizables. Tiene además la mejor en su clase resolución de dependencias y puede usarse para automatizar la mayor parte de la cadena de herramientas de compilación.\n  Es portable, con versiones que funcionan en Microsoft Windows, OS X, Linux, Solaris, FreeBSD, OpenBSD, WebOS, y NonStop OS. Además, está bien soportado por muchos de los proveedores de hospedaje web, que proporcionan infraestructura específica y documentación para hospedaje de sitios Node.\n  Tiene un ecosistema y comunidad de desarrolladores de terceros muy activa, con cantidad de gente deseosa de ayudar.\n\n\nPuedes crear de forma sencilla un servidor web básico para responder cualquier petición simplemente usando el paquete HTTP de Node, como se muestra abajo. Este, creará un servidor y escuchará cualquier clase de peticiones en la URL http://127.0.0.1:8000/; cuando se reciba una petición, se responderá enviando en texto la respuesta: “Hola Mundo!”.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// Se carga el módulo de HTTP\nvar http = require(\"http\");\n\n// Creación del servidor HTTP, y se define la escucha\n// de peticiones en el puerto 8000\nhttp.createServer(function(request, response) {\n\n   // Se define la cabecera HTTP, con el estado HTTP (OK: 200) y el tipo de contenido\n   response.writeHead(200, {'Content-Type': 'text/plain'});\n\n   // Se responde, en el cuerpo de la respuesta con el mensaje \"Hello World\"\n   response.end('Hola Mundo!\\n');\n}).listen(8000);\n\n// Se escribe la URL para el acceso al servidor\nconsole.log('Servidor en la url http://127.0.0.1:8000/');\n\n\nOtras tareas comunes de desarrollo web no están directamente soportadas por el mismo Node. Si quieres añadir el manejo específico de diferentes verbos HTTP (ej, GET, POST, DELETE, etc.), gestionar de forma separada las peticiones por medio de diferentes direcciones URL (“rutas”), servir ficheros estáticos o usar plantillas para crear la respuesta de forma dinámica, necesitarás escribir el código por tí mismo, o ¡puedes evitar reinventar la rueda usando un framework web!\n\nExpress es el framework web más popular de Node, y es la librería subyacente para un gran número de otros frameworks web de Node populares. Proporciona mecanismos para:\n\n\n  Escritura de manejadores de peticiones con diferentes verbos HTTP en diferentes caminos URL (rutas).\n  Integración con motores de renderización de “vistas” para generar respuestas mediante la introducción de datos en plantillas.\n  Establecer ajustes de aplicaciones web como qué puerto usar para conectar, y la localización de las plantillas que se utilizan para renderizar la respuesta.\n  Añadir procesamiento de peticiones “middleware” adicional en cualquier punto dentro de la tubería de manejo de la petición.\n\n\nA pesar de que Express es en sí mismo bastante minimalista, los desarrolladores han creado paquetes de middleware compatibles para abordar casi cualquier problema de desarrollo web. Hay librerías para trabajar con cookies, sesiones, inicios de sesión de usuario, parámetros URL, datos POST, cabeceras de seguridad y muchos más. Puedes encontrar una lista de paquetes middleware mantenida por el equipo de Express en Express Middleware (junto con una lista de algunos de los paquetes más populares de terceros).\n\n\n  -info-Esta flexibilidad es una espada de doble filo. Hay paquetes de middleware para abordar casi cualquier problema o requerimiento, pero deducir cuáles son los paquetes adecuados a usar algunas veces puede ser un auténtico reto. Tampoco hay una “forma correcta” de estructurar una aplicación, y muchos ejemplos que puedes encontrar en la Internet no son óptimos, o sólo muestran una pequeña parte de lo que necesitas hacer para desarrollar una aplicación web.\n\n\n¿Dónde comenzó?\n\nNode fué lanzado inicialmente, sólo para Linux, en 2009. El gestor de paquetes NPM fué lanzado en 2010, y el soporte nativo para Windows fue añadido en 2012. La versión actual LTS (Long Term Suppport) es Node v12.18.0 mientras que la última versión es Node 14.4.0. Ésto es sólo una pequeña foto de una historia muy rica; profundiza en Wikipedia si quieres saber más).\n\nExpress fue lanzado inicialmente en Noviembre de 2010 y está ahora en la versión 4.17.1 de la API. Puedes comprobar en el changelog la información sobre cambios en la versión actual, y en GitHub notas de lanzamiento históricas más detalladas.\n\n¿Qué popularidad tiene Node/Express?\n\nLa popularidad de un framework web es importante porque es un indicador de se continuará manteniendo y qué recursos tienen más probabilidad de estar disponibles en términos de documentación, librerías de extensiones y soporte técnico.\n\nNo existe una medida disponible de inmediato y definitiva de la popularidad de los frameworks de lado servidor (aunque sitios como Hot Frameworks intentan asesorar sobre popularidad usando mecanismos como contar para cada plataforma el número de preguntas sobre proyectos en GitHub y StackOverflow). Una pregunta mejor es si Node y Express son lo “suficientemente populares” para evitar los problemas de las plataformas menos populares. ¿Continúan evolucionando? ¿Puedes conseguir la ayuda que necesitas? ¿Hay alguna posibilidad de que consigas un trabajo remunerado si aprendes Express?\n\nDe acuerdo con el número de compañías de perfil alto que usan Express, el número de gente que contribuye al código base, y el número de gente que proporciona soporte tanto libre como pagado, podemos entonces decir que sí, !Express es un framework popular!\n\n¿Es Express dogmático?\n\nLos frameworks web frecuentemente se refieren a sí mismos como “dogmáticos” (“opinionated”) o “no dogmáticos” (“unopinionated”).\n\nLos frameworks dogmáticos son aquellos que opinan acerca de la “manera correcta” de gestionar cualquier tarea en particular. Ofrecen soporte para el desarrollo rápido en un dominio en particular (resolver problemas de un tipo en particular) porque la manera correcta de hacer cualquier cosa está generalmente bien comprendida y bien documentada. Sin embargo pueden ser menos flexibles para resolver problemas fuera de su dominio principal, y tienden a ofrecer menos opciones para elegir qué componentes y enfoques pueden usarse.\n\nLos framewoks no dogmáticos, en contraposición, tienen muchas menos restricciones sobre el modo mejor de unir componentes para alcanzar un objetivo, o incluso qué componentes deberían usarse. Hacen más fácil para los desarrolladores usar las herramientas más adecuadas para completar una tarea en particular, si bien al coste de que necesitas encontrar esos componentes por tí mismo.\n\nExpress es no dogmático, transigente. Puedes insertar casi cualquier middleware compatible que te guste dentro de la cadena de manejo de la petición, en casi cualquier orden que te apetezca. Puedes estructurar la app en un fichero o múltiples ficheros y usar cualquier estructura de directorios. ¡Algunas veces puedes sentir que tienes demasiadas opciones!\n\n¿Cómo es el código para Express?\n\nEn sitios web o aplicaciones web dinámicas, que accedan a bases de datos, el servidor espera a recibir peticiones HTTP del navegador (o cliente). Cuando se recibe una petición, la aplicación determina cuál es la acción adecuada correspondiente, de acuerdo a la estructura de la URL y a la información (opcional) indicada en la petición con los métodos POST o GET. Dependiendo de la acción a realizar, puede que se necesite leer o escribir en la base de datos, o realizar otras acciones necesarias para atender la petición correctamente. La aplicación ha de responder al navegador, normalmente, creando una página HTML dinámicamente para él, en la que se muestre la información pedida, usualmente dentro de un elemento especifico para este fin, en una plantilla HTML.\n\nExpress posee métodos para especificar que función ha de ser llamada dependiendo del verbo HTTP usado en la petición (GET, POST, SET, etc.) y la estructura de la URL (“ruta”). También tiene los métodos para especificar que plantilla (“view”) o gestor de visualización utilizar, donde están guardadas las plantillas de HTML que han de usarse y como generar la visualización adecuada para cada caso. El middleware de Express, puede usarse también para añadir funcionalidades para la gestión de cookies, sesiones y usuarios, mediante el uso de parámetros, en los métodos POST/GET. Puede utilizarse además cualquier sistema de trabajo con bases de datos, que sea soportado por Node (Express no especifica ningún método preferido para trabajar con bases de datos).\n\nEn las siguientes secciones, se explican algunos puntos comunes que se pueden encontrar cuando se trabaja con código de Node y Express.\n\nHola Mundo! - en Express\n\nPrimero consideremos el tradicional ejemplo de Hola Mundo! (se comentará cada parte a continuación).\n\n\n  -info- Si tiene Node y Express instalado (o piensa instalarlos posteriormente) puede guardar este código en un archivo llamado app.js y ejecutarlo posteriormente en la linea de comandos invocándolo mediante: node app.js.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nvar express = require('express');\nvar app = express();\n\napp.get('/', function(req, res) {\n  res.send('Hola Mundo!');\n});\n\napp.listen(3000, function() {\n  console.log('Aplicación ejemplo, escuchando el puerto 3000!');\n});\n\n\nLas primeras dos líneas incluyen (mediante la orden require()) el módulo de Express y crean una aplicación de Express. Este elemento se denomina comúnmente app, y posee métodos para el enrutamiento de las peticiones HTTP, configuración del ‘middleware’, y visualización de las vistas de HTML, uso del motores de ‘templates’, y gestión de las configuraciones de las aplicaciones que controlan la aplicación (por ejemplo el entorno, las definiciones para enrutado … etcetera.)\n\nLas líneas que siguen en el código (las tres líneas que comienzan con app.get) muestran una definición de ruta que se llamará cuando se reciba una petición HTTP GET con una dirección ('/') relativa al directorio raíz. La función ‘callback’ coge una petición y una respuesta como argumentos, y ejecuta un send() en la respuesta, para enviar la cadena de caracteres: “Hola Mundo!”.\n\nEl bloque final de código, define y crea el servidor, escuchando el puerto 3000 e imprime un comentario en la consola. Cuando se está ejecutando el servidor, es posible ir hasta la dirección localhost:3000 en un navegador, y ver como el servidor de este ejemplo devuelve el mensaje de respuesta.\n\nImportando y creando módulos\n\nUn módulo es una librería o archivo JavaScript que puede ser importado dentro de otro código utilizando la función require() de Node. Por sí mismo, Express es un módulo, como lo son el middleware y las librerías de bases de datos que se utilizan en las aplicaciones Express.\n\nEl código mostrado abajo, muestra como puede importarse un módulo con base a su nombre, como ejemplo se utiliza el framework Express . Primero se invoca la función require(), indicando como parámetro el nombre del módulo o librería como una cadena ('express'), posteriormente se invoca el objeto obtenido para crear una aplicación Express.\n\nPosteriormente, se puede acceder a las propiedades y funciones del objeto Aplicación.\n\n1\n2\nvar express = require('express');\nvar app = express();\n\n\nTambién podemos crear nuestros propios módulos que puedan posteriormente ser importados de la misma manera.\n\n\n  -info-Usted puede desear crear sus propios módulos, esto le permitirá organizar su código en partes más administrables; una aplicación que reside en un solo archivo es difícil de entender y manejar.El utilizar módulos independientes también le permite administrar el espacio de nombres, de esta manera unicamente las variables que exporte explícitamente son importadas cuando utilice un módulo.\n\n\nPara hacer que los objetos estén disponibles fuera de un módulo, solamente es necesario asignarlos al objeto exports. Por ejemplo, el módulo mostrado a continuación square.js es un archivo que exporta los métodos area() y perimeter() :\n\n1\n2\nexports.area = function(width) { return width * width; };\nexports.perimeter = function(width) { return 4 * width; };\n\n\nNosotros podemos importar este módulo utilizando la función require(), y entonces podremos invocar los métodos exportados de la siguiente manera:\n\n1\n2\n3\n4\n// Utilizamos la función require() El nombre del archivo se ingresa sin la extensión (opcional) .js\nvar square = require('./square');\n// invocamos el metodo area()\nconsole.log('El área de un cuadrado con lado de 4 es ' + square.area(4));\n\n\n\n  -info- Usted también puede especificar una ruta absoluta a la ubicación del módulo (o un nombre como se realizó inicialmente).\n\n\nSi usted desea exportar completamente un objeto en una asignación en lugar de construir cada propiedad por separado, debe asignarlo al módulo module.exports como se muestra a continuación (también puede hacer esto al inicio de un constructor o de otra función.)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nmodule.exports = {\n  area: function(width) {\n    return width * width;\n  },\n\n  perimeter: function(width) {\n    return 4 * width;\n  }\n};\n\n\nPara más información acerca de módulos vea Modulos (Node API docs).\n\nUsando APIs asíncronas\n\nEl código JavaScript usa frecuentemente APIs asíncronas antes que sincrónicas para operaciones que tomen algún tiempo en completarse. En una API sincrónica cada operación debe completarse antes de que la siguiente pueda comenzar. Por ejemplo, la siguiente función de registro es síncrona, y escribirá en orden el texto en la consola (Primero, Segundo).\n\n1\n2\nconsole.log('Primero');\nconsole.log('Segundo');\n\n\nEn contraste, en una API asincrónica, la API comenzará una operación e inmediatamente retornará (antes de que la operación se complete). Una vez que la operación finalice, la API usará algún mecanismo para realizar operaciones adicionales. Por ejemplo, el código de abajo imprimirá “Segundo, Primero” porque aunque el método setTimeout() es llamado primero y retorna inmediatamente, la operación no se completa por varios segundos.\n\n1\n2\n3\n4\nsetTimeout(function() {\n   console.log('Primero');\n   }, 3000);\nconsole.log('Segundo');\n\n\nUsar APIs asíncronas sin bloques es aun mas importante en Node que en el navegador, porque Node es un entorno de ejecución controlado por eventos de un solo hilo. “Un solo hilo” quiere decir que todas las peticiones al servidor son ejecutadas en el mismo hilo ( en vez de dividirse en procesos separados). Este modelo es extremadamente eficiente en términos de velocidad y recursos del servidor, pero eso significa que si alguna de sus funciones llama a métodos sincrónicos que tomen demasiado tiempo en completarse, bloquearan no solo la solicitud actual, sino también cualquier otra petición que este siendo manejada por tu aplicación web.\n\nHay muchas maneras para una API asincrónica de notificar a su aplicación que se ha completado. La manera mas común es registrar una función callback cuando usted invoca a una API asincrónica, la misma será llamada de vuelta cuando la operación se complete. Éste es el enfoque utilizado anteriormente.\n\n\n  -info- Usar “callbacks” puede ser un poco enmarañado si usted tiene una secuencia de operaciones asíncronas dependientes que deben ser llevadas a cabo en orden, porque esto resulta en múltiples niveles de “callbacks” anidadas. Este problema es comúnmente conocido como “callback hell” (callback del infierno). Este problema puede ser reducido con buenas practicas de código (vea http://callbackhell.com/), usando un módulo como async, o incluso avanzando a características de ES6 como las promesas.\n\n\n\n  -info-Una convención común para Node y Express es usar callbacks de error primero. En esta convención el primer valor en su función callback es un error, mientras que los argumentos subsecuentes contienen datos correctos. Hay una buena explicación de porque este enfoque es útil en este blog: The Node.js Way - Understanding Error-First Callbacks (fredkschott.com).\n\n\nCreando manejadores de rutas\n\nEn nuestro ejemplo anterior de “Hola Mundo!” en Express (véase mas arriba), definimos una función (callback) manejadora de ruta para peticiones HTTP GET a la raíz del sitio ('/').\n\n1\n2\n3\napp.get('/', function(req, res) {\n  res.send('Hello World!');\n});\n\n\nLa función callback toma una petición y una respuesta como argumentos. En este caso el método simplemente llama a send() en la respuesta para retornar la cadena “Hello World!”. Hay un número de otros métodos de respuesta para finalizar el ciclo de solicitud/respuesta, por ejemplo podrá llamar a res.json() para enviar una respuesta JSON o res.sendFile() para enviar un archivo.\n\n\n  -info- Usted puede utilizar cualquier nombre que quiera para los argumentos en las funciones callback; cuando la callback es invocada el primer argumento siempre sera la petición y el segundo siempre sera la respuesta. Tiene sentido nombrarlos de manera que pueda identificar el objeto con el que esta trabajando en el cuerpo de la callback.\n\n\nEl objeto que representa una aplicación de Express, también posee métodos para definir los manejadores de rutas para el resto de los verbos HTTP: post(), put(), delete(), options(), trace(), copy(), lock(), mkcol(), move(), purge(), propfind(), proppatch(), unlock(), report(), mkactivity(), checkout(), merge(), m-search(), notify(), subscribe(), unsubscribe(), patch(), search(), y connect().\n\nHay un método general para definir las rutas: app.all(), el cual será llamado en respuesta a cualquier método HTTP. Se usa para cargar funciones del middleware en una dirección particular para todos los métodos de peticiones. El siguiente ejemplo (de la documentación de Express) muestra el uso de los manejadores a /secret sin tener en cuenta el verbo HTTP utilizado (siempre que esté definido por el módulo http).\n\n1\n2\n3\n4\napp.all('/secret', function(req, res, next) {\n  console.log('Accediendo a la seccion secreta ...');\n  next(); // pasa el control al siguiente manejador\n});\n\n\nLas rutas le permiten igualar patrones particulares de caracteres en la URL, y extraer algunos valores de ella y pasarlos como parámetros al manejador de rutas (como atributo del objeto petición pasado como parámetro).\n\nUsualmente es útil agrupar manejadores de rutas para una parte del sitio juntos y accederlos usando un prefijo de ruta en común. (Ej: un sitio con una Wiki podría tener todas las rutas relacionadas a dicha sección en un archivo y siendo accedidas con el prefijo de ruta /wiki/. En Express esto se logra usando el objeto express.Router. Ej: podemos crear nuestra ruta wiki en un módulo llamado wiki.js, y entonces exportar el objeto Router, como se muestra debajo:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// wiki.js - Modulo de rutas Wiki\n\nvar express = require('express');\nvar router = express.Router();\n\n// Home page route\nrouter.get('/', function(req, res) {\n  res.send('Página de inicio Wiki');\n});\n\n// About page route\nrouter.get('/about', function(req, res) {\n  res.send('Acerca de esta wiki');\n});\n\nmodule.exports = router;\n\n\n\n  -info-Agregar rutas al objeto Router es como agregar rutas al objeto app (como se vio anteriormente).\n\n\nPara usar el router en nuestro archivo app principal, necesitamos require() el módulo de rutas (wiki.js), entonces llama a use() en la aplicación Express para agregar el Router al software intermediario que maneja las rutas. Las dos rutas serán accesibles entonces desde /wiki/ y /wiki/about/.\n\n1\n2\n3\nvar wiki = require('./wiki.js');\n// ...\napp.use('/wiki', wiki);\n\n\nLe mostraremos mucho más sobre como trabajar con rutas, y en particular, acerca de como usar el Router, más adelante en la sección Rutas y controladores .\n\nUsando middleware\n\nEl “middleware” es ampliamente utilizado en las aplicaciones de Express: desde tareas para servir archivos estáticos, a la gestión de errores o la compresión de las respuestas HTTP. Mientras las funciones de enrutamiento, con el objeto express.Router, se encargan del ciclo petición-respuesta, al gestionar la respuesta adecuada al cliente, las funciones de middleware normalmente realizan alguna operación al gestionar una petición o respuesta y a continuación llaman a la siguiente función en la “pila”, que puede ser otra función de middleware u otra función de enrutamiento. El orden en el que las funciones de middleware son llamadas depende del desarrollador de la aplicación.\n\n\n  -info-El middleware puede realizar cualquier operación: hacer cambios a una petición, ejecutar código, realizar cambios a la petición o al objeto pedido, puede también finalizar el ciclo de petición-respuesta. Si no finaliza el ciclo debe llamar a la función next() para pasar el control de la ejecución a la siguiente función del middleware ( o a la petición quedaría esperando una respuesta … ).\n\n\nLa mayoría de las aplicaciones usan middleware desarrollado por terceras partes, para simplificar funciones habituales en el desarrollo web, como puede ser: gestión de cookies, sesiones, autentificado de usuarios, peticiones POST y datos en JSON, registros de eventos, etc. Puede encontrar en el siguiente enlace una lista de middleware mantenido por el equipo de Express (que también incluye otros paquetes populares de terceras partes). Las librerías de Express están disponibles con la aplicación NPM (Node Package Manager).\n\nPara usar estas colecciones, primero ha de instalar la aplicación usando NPM. Por ejemplo para instalar el registro de peticiones HTTP morgan, se haría con el comando Bash:\n\n1\nnpm install morgan\n\n\nEntonces podrías llamar a la función use() en un objeto de aplicación Express para utilizar este middleware a su aplicación.\n\n1\n2\n3\n4\n5\nvar express = require('express');\nvar logger = require('morgan');\nvar app = express();\napp.use(logger('dev'));\n...\n\n\n\n  -info-Las funciones Middleware y routing son llamadas en el orden que son declaradas. Para algunos middleware el orden es importante (por ejemplo si el middleware de sesion depende del middleware de cookie, entonces el manejador de cookie tiene que ser llamado antes). Casi siempre es el caso que el middleware es llamado antes de configurar las rutas, o tu manejador de rutas no tendra acceso a la funcionalidad agregada por tu middleware.\n\n\nTu puedes escribir tu propia funcion middleware, y si quieres hacerlo así (solo para crear código de manejo de error). La única diferencia entre una función middleware y un callback manejador de rutas es que las funciones middleware tienen un tercer argumento next, cuyas funciones middleware son esperadas para llamarlas si ellas no completan el ciclo request (cuando la función midleware es llamada, esta contiene la próxima función que debe ser llamada).\n\nPuedes agregar una función middleware a la cadena de procesamiento con cualquier app.use() o app.add(), dependiendo de si quiere aplicar el middleware a todas las respuestas o a respuestas con un verbo particular HTTP (GET, POST, etc). Usted especifica rutas, lo mismo en ambos casos, aunque la ruta es opcional cuando llama app.use().\n\nEl ejemplo de abajo muestra como puede agregar la función middleware usando ambos métodos, y con/sin una ruta.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvar express = require('express');\nvar app = express();\n\n// An example middleware function\nvar a_middleware_function = function(req, res, next) {\n  // ... perform some operations\n  next(); // Call next() so Express will call the next middleware function in the chain.\n}\n\n// Function added with use() for all routes and verbs\napp.use(a_middleware_function);\n\n// Function added with use() for a specific route\napp.use('/someroute', a_middleware_function);\n\n// A middleware function added for a specific HTTP verb and route\napp.get('/', a_middleware_function);\n\napp.listen(3000);\n\n\n\n  -info-Arriba declaramos la función middleware separadamente y la configuramos como el callback. En nuestra función previous manejadora de ruta declaramos la función callback cuando esta fué usada. En JavaScript, cuealquer aproximación es valida.\n\n\nLa documentación Express tiene mucha mas documentación excelente acerca del uso y escritura de middleware Express.\n\nSirviendo archivos estáticos\n\nPuede utilizar el middleware express.static para servir archivos estáticos, incluyendo sus imagenes, CSS y JavaScript (static() es la única función middleware que es actualmente parte de Express). Por ejemplo, podria utilizar la linea de abajo para servir imágenes, archivos CSS, y archivos JavaScript desde un directorio nombrado ‘public’ al mismo nivel desde donde llama a node:\n\n1\napp.use(express.static('public'));\n\n\nCualesquiere archivos en el directorio público son servidos al agregar su nombre de archivo (relativo a la ubicación del directorio “público” ) de la ubicación URL. Por ejemplo:\n\n1\n2\n3\n4\nhttp://localhost:3000/images/dog.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/about.html\n\n\nPuede llamar static() multiples ocasiones a servir multiples directorios. Si un archivo no puede ser encontrado por una función middleware entonces este simplemente será pasado en la subsequente middleware (el orden en que el middleware está basado en su orden de declaración).\n\n1\n2\napp.use(express.static('public'));\napp.use(express.static('media'));\n\n\nTambién puede crear un prefijo virtual para sus URLs estáticas, aun más teniendo los archivos agregados en la ubicación URL. Por ejemplo, aqui especificamos a mount path tal que los archivos son bajados con el prefijo “/media”:\n\n1\napp.use('/media', express.static('public'));\n\n\nAhora, puede bajar los archivos que estan en el directorio publico del path con prefijo /media.\n\n1\n2\n3\nhttp://localhost:3000/media/images/dog.jpg\nhttp://localhost:3000/media/video/cat.mp4\nhttp://localhost:3000/media/cry.mp3\n\n\nPara más información, ver Sirviendo archivos estáticos en Express.\n\nManejando errores\n\nLos errores manejados por una o más funciones especiales middleware que tienen cuatro argumentos, en lugar de las usuales tres: (err, req, res, next). For example:\n\n1\n2\n3\n4\napp.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\n\nEstas pueden devolver cualquier contenido, pero deben ser llamadas despues de todas las otras app.use() llamadas de rutas tal que ellas son las últimas middleware en el proceso de manejo de request!\n\nExpress viene con un manejador de error integrado, el que se ocupa de error remanente que pudiera ser encontrado en la app. Esta función middleware manejador de error esta agregada al final del stack de funciones middleware. Si pasa un error a next() y no lo maneja en un manejador de error, este sera manejado por el manejador de error integrado; el error sera escrito en el cliente con el rastreo de pila.\n\n\n  -info-El rastreo de pila no esta incluido en el ambiente de producción. Para ejecutarlo en modo de producción necesita configurar la variable de ambiente NODE_ENV to ‘production'.\n\n  HTTP404 y otros códigos de estatus de “error” no son tratados como errores. Si quiere manejar estos, puede agregar una función middleware para hacerlo. Para mas información vea las FAQ.\n\n\nPara mayor información vea Manejo de error (Docs. Express).\n\nUsando Bases de datos\n\nLas apps de Express pueden usar cualquier mecanismo de bases de datos suportadas por Node (Express en sí mismo no define ninguna conducta/requerimiento especifico adicional para administración de bases de datos). Hay muchas opciones, incluyendo PostgreSQL, MySQL, Redis, SQLite, MongoDB, etc.\n\nCon el propósito de usar éste, debe primero instalar el manejador de bases de datos utilizando NPM. Por ejemplo, para instalar el manejador para el popular NoSQL MongoDB querría utilizar el comando:\n\n1\nnpm install mongodb\n\n\nLa base de datos por si misma puede ser instalada localmente o en un servidor de la nube. En su codigo Express requiere el manejador, conectarse a la base de datos, y entonces ejecutar operaciones crear, leer, actualizar, y borrar (CLAB). }El ejemplo de abajo (de la documentación Express documentation) muestra como puede encontrar registros en la colección “mamiferos” usando MongoDB.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nvar MongoClient = require('mongodb').MongoClient;\n\nMongoClient.connect('mongodb://localhost:27017/animals', function(err, db) {\n  if (err) throw err;\n\n  db.collection('mammals').find().toArray(function (err, result) {\n    if (err) throw err;\n\n    console.log(result);\n  });\n});\n\n\nOtra aproximación popular es acceder a su base de datos indirectamente, via an Mapeo Objeto Relacional (“MOR”). En esta aproximación usted define sus datos como “objetos” o “modelos” y el MOR mapea estos a través del delineamiento básico de la base de datos. Esta aproximación tiene el beneficio de que como un desarrollador puede continuar pensando en términos de objetos de JavaScript mas que en semántica de bases de datos, y en esto hay un lugar obvio para ejecutar la validación y chequeo de entrada de datos. Hablaremos más de bases de datos en un artículo posterior.\n\nPara más información ver Integracion de Bases de Datos (docs Express ).\n\nRenderización de data (vistas)\n\nEl Motor de plantilla (referido como “motor de vistas” por Express) le permite definir la estructura de documento de salida en una plantilla, usando marcadores de posición para datos que seran llenados cuando una pagina es generada. Las plantillas son utilizadas generalmete para crear HTML, pero tambien pueden crear otros tipos de documentos. Express tiene soporte para numerosos motores de plantillas, y hay una util comparación de los motores más populares aquí: Comparando Motores de Plantillas de JavaScript: Jade, Mustache, Dust and More.\n\nEn su código de configuración de su aplicación usted configura el motor de plantillas para usar y su localización Express podiría buscar plantillas usando las configuraciones de ‘vistas’ y ‘motores de vistas’, mostrado abajo (tendría también que instalar el paquete conteniendo su librería de plantillas!)\n\n1\n2\n3\n4\n5\n6\n7\n8\nvar express = require('express');\nvar app = express();\n\n// Set directory to contain the templates ('views')\napp.set('views', path.join(__dirname, 'views'));\n\n// Set view engine to use, in this case 'some_template_engine_name'\napp.set('view engine', 'some_template_engine_name');\n\n\nLa apariencia de la plantilla dependera de qué motor use. Asumiendo que tiene un archivo de plantillas nombrado “index.&lt;template_extension&gt;” este contiene placeholders para variables de datos nombradas ‘title’ y “message”, podría llamar Response.render() en una función manejadora de rutas para crear y enviar la HTML response:\n\n1\n2\n3\napp.get('/', function(req, res) {\n  res.render('index', { title: 'About dogs', message: 'Dogs rock!' });\n});\n\n\nPara más información vea Usando motores de plantillas con Express.\n\nEstructura de Archivos\n\nExpress no hace asunciones en términos de estructura o que componentes usted usa. Rutas, vistas, archivos estáticos, y otras lógicas de aplicación específica puede vivir en cualquier número de archivos con cualquier estructura de directorio. Mientras que esto es perfectamente posible, se puede tener toda la aplicación en un solo archivo, en Express, tipicamente esto tiene sentido al desplegar su aplicacion dentro de archivos basados en función (e.g. administracion de cuentas, blogs, tableros de discusion) y dominio de problema arquitectonico (e.g. modelo, vista or controlador si tu pasas a estar usando una arquitectura MVC).\n\nEn un tópico posterior usaremos el Generador de Aplicaciones Express Application Generator, el que crea un esquelo de una app modular que podemos facilmente extender para crear aplicaciones web.\n\nResumen\n\n¡Felicitaciones, ha completado el primer paso en su viaje Express/Node! Ahora debes comprender los principales beneficios de Express y Node, y más o menos cómo se verían las partes principales de una aplicación Express (rutas, middleware, manejo de errores y plantillas). ¡También debe comprender que con Express como un framework unopinionated, la forma en que une estas partes y las bibliotecas que usa dependen en gran medida de usted!\n\nPor supuesto, Express es deliberadamente un un framework de aplicaciones web muy ligero, por lo que gran parte de sus beneficios y potencial proviene de bibliotecas y características de terceros. Lo veremos con más detalle en los siguientes artículos. En nuestro próximo artículo, veremos cómo configurar un entorno de desarrollo de Node, para que pueda comenzar a ver código de Express en acción.\n\nVer también\n\n\n  Modules (Node API docs)\n  Express (home page)\n  Basic routing (Express docs)\n  Routing guide (Express docs)\n  Using template engines with Express (Express docs)\n  Using middleware (Express docs)\n  Writing middleware for use in Express apps (Express docs)\n  Database integration (Express docs)\n  Serving static files in Express (Express docs)\n  Error handling (Express docs)\n\n\n",
        "url": "/node-express-library-teoria/node-introduccion"
      }
      
    
  };
</script>
<script src="/node-express-library-teoria/assets/js/lunr.min.js"></script>
<script src="/node-express-library-teoria/assets/js/search.js"></script>

</div>

        <a href="#top" id='back-to-top-link'><i class='fa fa-angle-up'></i></a>
         <hr>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Licencia de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Esta obra está bajo una <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional</a>.

      </div>
    </div>    
    <script src="/node-express-library-teoria/assets/js/main.js"></script>
      <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-56FXN2KND3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-56FXN2KND3');
  </script>
  

  </body>
</html>
